{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IREE","text":"<p>IREE (Intermediate Representation Execution Environment<sup>1</sup>) is an MLIR-based end-to-end compiler and runtime that lowers Machine Learning (ML) models to a unified IR that scales up to meet the needs of the datacenter and down to satisfy the constraints and special considerations of mobile and edge deployments.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li> Ahead-of-time compilation of scheduling and execution logic together</li> <li> Support for dynamic shapes, flow control, streaming, and other advanced       model features</li> <li> Optimized for many CPU and GPU architectures</li> <li> Low overhead, pipelined execution for efficient power and resource usage</li> <li> Binary size as low as 30KB on embedded systems</li> <li> Debugging and profiling support</li> </ul>"},{"location":"#support-matrix","title":"Support matrix","text":"<p>IREE supports importing from a variety of ML frameworks:</p> <ul> <li> TensorFlow</li> <li> TensorFlow Lite</li> <li> JAX</li> <li> PyTorch</li> <li> ONNX (hoped for)</li> </ul> <p>The IREE compiler tools run on  Linux,  Windows, and  macOS and can generate efficient code for a variety of runtime platforms:</p> <ul> <li> Linux</li> <li> Windows</li> <li> Android</li> <li> macOS</li> <li> iOS</li> <li> Bare metal</li> <li> WebAssembly (planned)</li> </ul> <p>and architectures:</p> <ul> <li> ARM</li> <li> x86</li> <li> RISC-V</li> </ul> <p>Support for hardware accelerators and APIs is also included:</p> <ul> <li> Vulkan</li> <li> CUDA</li> <li> Metal (for Apple silicon devices)</li> <li> WebGPU (planned)</li> </ul>"},{"location":"#project-architecture","title":"Project architecture","text":"<p>IREE adopts a holistic approach towards ML model compilation: the IR produced contains both the scheduling logic, required to communicate data dependencies to low-level parallel pipelined hardware/API like Vulkan, and the execution logic, encoding dense computation on the hardware in the form of hardware/API-specific binaries like SPIR-V.</p> <p> </p>"},{"location":"#workflow-overview","title":"Workflow overview","text":"<p>Using IREE involves the following general steps:</p> <ol> <li> <p>Import your model</p> <p>Develop your program using one of the supported frameworks, then import into IREE</p> </li> <li> <p>Select your deployment configuration</p> <p>Identify your target platform, accelerator(s), and other constraints</p> </li> <li> <p>Compile your model</p> <p>Compile through IREE, picking settings based on your deployment configuration</p> </li> <li> <p>Run your model</p> <p>Use IREE's runtime components to execute your compiled model</p> </li> </ol>"},{"location":"#importing-models-from-ml-frameworks","title":"Importing models from ML frameworks","text":"<p>IREE supports importing models from a growing list of ML frameworks and model formats:</p> <ul> <li>TensorFlow and   TensorFlow Lite</li> <li>JAX</li> <li>PyTorch</li> </ul>"},{"location":"#selecting-deployment-configurations","title":"Selecting deployment configurations","text":"<p>IREE provides a flexible set of tools for various deployment scenarios. Fully featured environments can use IREE for dynamic model deployments taking advantage of multi-threaded hardware, while embedded systems can bypass IREE's runtime entirely or interface with custom accelerators.</p> <ul> <li>What platforms are you targeting? Desktop? Mobile? An embedded system?</li> <li>What hardware should the bulk of your model run on? CPU? GPU?</li> <li>How fixed is your model itself? Can the weights be changed? Do you want   to support loading different model architectures dynamically?</li> </ul> <p>IREE supports the full set of these configurations using the same underlying technology.</p>"},{"location":"#compiling-models","title":"Compiling models","text":"<p>Model compilation is performed ahead-of-time on a host machine for any combination of targets. The compilation process converts from layers and operators used by high level frameworks down into optimized native code and associated scheduling logic.</p> <p>For example, compiling for GPU execution using Vulkan generates SPIR-V kernels and Vulkan API calls. For CPU execution, native code with static or dynamic linkage and the associated function calls are generated.</p>"},{"location":"#running-models","title":"Running models","text":"<p>IREE offers a low level C API, as well as several sets of API bindings for compiling and running programs using various languages.</p>"},{"location":"#communication-channels","title":"Communication channels","text":"<ul> <li> GitHub issues: Feature requests,   bugs, and other work tracking</li> <li> IREE Discord server: Daily development   discussions with the core team and collaborators</li> <li> iree-discuss email list:   Announcements, general and low-priority discussion</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>IREE is in the early stages of development and is not yet ready for broad adoption. We use both GitHub Projects and GitHub Milestones to track progress.</p> <ol> <li> <p>Pronounced \"eerie\" and often styled with the   emoji\u00a0\u21a9</p> </li> </ol>"},{"location":"building-from-source/","title":"Building from source","text":"<p>While IREE does offer binary distributions for its compiler tools and Python bindings, building from source is still useful when using IREE's runtime or when making changes to the compiler or import tools themselves.</p>"},{"location":"building-from-source/#reference-pages","title":"Reference pages","text":"<ul> <li>Getting started</li> <li>Android cross-compilation</li> <li>iOS cross-compilation</li> <li>RISC-V cross-compilation</li> </ul>"},{"location":"building-from-source/android/","title":"Android cross-compilation","text":"<p>Running on a platform like Android involves cross-compiling from a host platform (e.g. Linux) to a target platform (a specific Android version and system architecture):</p> <ul> <li>IREE's compiler is built on the host and is used there to generate modules   for the target</li> <li>IREE's runtime is built on the host for the target. The runtime is then   either pushed to the target to run natively or is bundled into an Android   APK</li> </ul>","tags":["Android"]},{"location":"building-from-source/android/#prerequisites","title":"Prerequisites","text":"","tags":["Android"]},{"location":"building-from-source/android/#host-environment-setup","title":"Host environment setup","text":"<p>You should already be able to build IREE from source on your host platform. Please make sure you have followed the getting started steps.</p>","tags":["Android"]},{"location":"building-from-source/android/#install-android-ndk-and-adb","title":"Install Android NDK and ADB","text":"<p>The Android Native Developer Kit (NDK) is needed to use native C/C++ code on Android. You can download it here, or, if you have installed Android Studio, you can follow this guide instead.</p> <p>Note</p> <p>Make sure the <code>ANDROID_NDK</code> environment variable is set after installing the NDK.</p> <p>ADB (the Android Debug Bridge) is also needed to communicate with Android devices from the command line. Install it following the official user guide.</p>","tags":["Android"]},{"location":"building-from-source/android/#configure-and-build","title":"Configure and build","text":"","tags":["Android"]},{"location":"building-from-source/android/#host-configuration","title":"Host configuration","text":"<p>Build and install on your host machine:</p> <pre><code>cmake -GNinja -B ../iree-build/ \\\n-DCMAKE_INSTALL_PREFIX=../iree-build/install \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n.\ncmake --build ../iree-build/ --target install\n</code></pre>","tags":["Android"]},{"location":"building-from-source/android/#target-configuration","title":"Target configuration","text":"<p>Build the runtime using the Android NDK toolchain:</p>  Linux macOS Windows <pre><code>cmake -GNinja -B ../iree-build-android/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"${ANDROID_NDK?}/build/cmake/android.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=\"$PWD/../iree-build/install/bin\" \\\n-DANDROID_ABI=\"arm64-v8a\" \\\n-DANDROID_PLATFORM=\"android-29\" \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\ncmake --build ../iree-build-android/\n</code></pre> <pre><code>cmake -GNinja -B ../iree-build-android/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"${ANDROID_NDK?}/build/cmake/android.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=\"$PWD/../iree-build/install/bin\" \\\n-DANDROID_ABI=\"arm64-v8a\" \\\n-DANDROID_PLATFORM=\"android-29\" \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\ncmake --build ../iree-build-android/\n</code></pre> <pre><code>cmake -GNinja -B ../iree-build-android/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"%ANDROID_NDK%/build/cmake/android.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=\"%CD%/../iree-build/install/bin\" \\\n-DANDROID_ABI=\"arm64-v8a\" \\\n-DANDROID_PLATFORM=\"android-29\" \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\ncmake --build ../iree-build-android/\n</code></pre> <p>Note</p> <p>See the Android NDK CMake guide and Android Studio CMake guide for details on configuring CMake for Android.</p> <p>The specific <code>ANDROID_ABI</code> and <code>ANDROID_PLATFORM</code> used should match your target device.</p>","tags":["Android"]},{"location":"building-from-source/android/#running-android-tests","title":"Running Android tests","text":"<p>Make sure you enable developer options and USB debugging on your Android device and can see your it when you run <code>adb devices</code>, then run all tests through ctest:</p> <pre><code># Build test dependencies\ncmake --build ../iree-build-android/ --target iree-test-deps\n\n# Ensure that your Android device is visible\nadb devices\n\n# Run tests\nctest --test-dir ../iree-build-android/ --output-on-failure\n</code></pre> <p>This will automatically upload build artifacts to the connected Android device, run the tests, then report the status back to your host machine.</p>","tags":["Android"]},{"location":"building-from-source/android/#running-tools-directly","title":"Running tools directly","text":"<p>Invoke the host compiler tools to produce a bytecode module FlatBuffer:</p> <pre><code>../iree-build/install/bin/iree-compile \\\n--iree-hal-target-backends=vmvx \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre> <p>Push the Android runtime tools to the device, along with any FlatBuffer files:</p> <pre><code>adb push ../iree-build-android/tools/iree-run-module /data/local/tmp/\nadb shell chmod +x /data/local/tmp/iree-run-module\nadb push /tmp/simple_abs_vmvx.vmfb /data/local/tmp/\n</code></pre> <p>Run the tool:</p> <pre><code>adb shell /data/local/tmp/iree-run-module --device=local-task \\\n--module=/data/local/tmp/simple_abs_vmvx.vmfb \\\n--function=abs \\\n--input=\"f32=-5\"\n</code></pre>","tags":["Android"]},{"location":"building-from-source/getting-started/","title":"Getting started","text":""},{"location":"building-from-source/getting-started/#prerequisites","title":"Prerequisites","text":"<p>IREE can be built from source using CMake. We also recommend the Ninja CMake generator and the clang or MSVC C/C++ compilers.</p> Note - Other CMake generators and compilers <p>IREE developers and CIs primarily use Ninja, clang, and MSVC. Other configurations (including the Makefile generator and gcc) are \"best effort\". Patches to improve support are always welcome.</p>  Linux macOS Windows <ol> <li> <p>Install a compiler/linker (typically \"clang\" and \"lld\" package)</p> </li> <li> <p>Install CMake (typically \"cmake\" package)</p> </li> <li> <p>Install Ninja (typically \"ninja-build\"    package)</p> </li> </ol> <p>On Debian/Ubuntu:</p> <pre><code>sudo apt install cmake ninja-build clang lld\n</code></pre> <ol> <li> <p>Install CMake</p> </li> <li> <p>Install Ninja</p> </li> </ol> <p>If using Homebrew:</p> <pre><code>brew install cmake ninja\n</code></pre> <ol> <li> <p>Install MSVC from Visual Studio or \"Tools for Visual Studio\" on the    official downloads page</p> </li> <li> <p>Install CMake from the    official downloads page</p> </li> <li> <p>Install Ninja from the official site</p> </li> </ol> <p>Note</p> <p>Initialize MSVC by running <code>vcvarsall.bat</code> to build on the command line. See the official documentation for details.</p>"},{"location":"building-from-source/getting-started/#quickstart-clone-and-build","title":"Quickstart: clone and build","text":"<p>Use Git to clone the IREE repository and initialize its submodules:</p> <pre><code>git clone https://github.com/openxla/iree.git\ncd iree\ngit submodule update --init\n</code></pre> <p>The most basic CMake workflow is:</p> <pre><code># Configure\ncmake -G Ninja -B ../iree-build/ .\n\n# Build\ncmake --build ../iree-build/\n</code></pre> <p>Caution - slow builds</p> <p>The compiler build is complex. You will want a powerful machine and to tune the settings following the next section. In 2023, we've seen builds take around 5-10 minutes on 64-core Linux machines.</p> <p>Use case permitting, disabling the compiler build with <code>-DIREE_BUILD_COMPILER=OFF</code> will drastically simplify the build.</p>"},{"location":"building-from-source/getting-started/#configuration-settings","title":"Configuration settings","text":"<p>The configure step should be customized for your build environment. These settings can improve compile and link times substantially.</p>  Linux macOS Windows <pre><code># Recommended development options using clang and lld:\ncmake -G Ninja -B ../iree-build/ -S . \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DIREE_ENABLE_ASSERTIONS=ON \\\n-DIREE_ENABLE_SPLIT_DWARF=ON \\\n-DIREE_ENABLE_THIN_ARCHIVES=ON \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DIREE_ENABLE_LLD=ON\n</code></pre> <pre><code># Recommended development options using clang and lld:\ncmake -G Ninja -B ../iree-build/ -S . \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DIREE_ENABLE_ASSERTIONS=ON \\\n-DIREE_ENABLE_SPLIT_DWARF=ON \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DIREE_ENABLE_LLD=ON\n</code></pre> <p>It is also possible to add <code>-DIREE_ENABLE_THIN_ARCHIVES=ON</code> if the <code>CMAKE_AR</code> variable is defined and points to the path of either the GNU binutils or LLVM <code>ar</code> program, overriding the default Apple <code>ar</code>.</p> <pre><code># Recommended development options:\ncmake -G Ninja -B ../iree-build/ -S . \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DIREE_ENABLE_ASSERTIONS=ON\n</code></pre> Tip - CMAKE_BUILD_TYPE values <p>We recommend using the <code>RelWithDebInfo</code> build type by default for a good balance of debug info and performance. The <code>Debug</code>, <code>Release</code>, and <code>MinSizeRel</code> build types are useful in more specific cases. Note that several useful LLVM debugging features are only available in <code>Debug</code> builds. See the official CMake documentation for general details.</p> Tip - Faster recompilation with ccache <p>We recommend using <code>ccache</code> with CMake, especially when rebuilding the compiler. To use it, configure CMake with:</p> <pre><code>-DCMAKE_C_COMPILER_LAUNCHER=ccache -DCMAKE_CXX_COMPILER_LAUNCHER=ccache\n</code></pre> <p>See also our developer documentation for ccache.</p>"},{"location":"building-from-source/getting-started/#optional-components","title":"Optional components","text":"<p>By default, the CMake build includes:</p> <ul> <li>All compiler targets (<code>llvm-cpu</code>, <code>cuda</code>, <code>vulkan-spirv</code>, etc.)</li> <li>All runtime HAL drivers (<code>local-task</code>, <code>cuda</code>, <code>vulkan</code>, etc.)</li> <li>All compiler input formats (StableHLO, TOSA, etc.)</li> <li>All compiler output formats (VM bytecode, C)</li> </ul> <p>The default build does not include:</p> <ul> <li>Compiler or runtime bindings (Python, TFLite, etc.)</li> <li>Advanced features like AddressSanitizer or tracing instrumentation</li> <li>Experimental components</li> </ul> <p>These can be changed via the <code>IREE_</code> CMake options listed in the root <code>CMakeLists.txt</code>.</p>"},{"location":"building-from-source/getting-started/#extensions-and-integrations","title":"Extensions and integrations","text":"<p>When using IREE within other projects, you can register compiler plugins and runtime HAL drivers. You can also bring your own copy of LLVM and some other tools. See the root <code>CMakeLists.txt</code> for details.</p>"},{"location":"building-from-source/getting-started/#tests-and-samples","title":"Tests and samples","text":""},{"location":"building-from-source/getting-started/#running-tests","title":"Running tests","text":"<p>Tests are run via ctest. To build and run the core project tests:</p> <pre><code># Build default targets\ncmake --build ../iree-build/\n\n# Run tests\nctest --test-dir ../iree-build/\n</code></pre> <p>Caution</p> <p>This has two limitations:</p> <ol> <li>Large tests are excluded from the build by default</li> <li>Some tests require hardware like a GPU and will fail on unsupported systems</li> </ol> <p>To build and then run all tests:</p> <pre><code># 1. Build default targets\ncmake --build ../iree-build/\n\n# 2. Build test dependencies\ncmake --build ../iree-build/ --target iree-test-deps\n\n# 3. Run tests\nctest --test-dir ../iree-build/\n\n\n# Or combine all steps using a utility target\ncmake --build ../iree-build --target iree-run-tests\n</code></pre> <p>To run only certain tests, we have a helper script that converts environment variables into ctest filters:</p> <pre><code># Run default tests\n./build_tools/cmake/ctest_all.sh ../iree-build\n\n# Run tests, turning CUDA on and Vulkan off\nexport IREE_CUDA_DISABLE=0\nexport IREE_VULKAN_DISABLE=1\n./build_tools/cmake/ctest_all.sh ../iree-build\n</code></pre>"},{"location":"building-from-source/getting-started/#running-samples","title":"Running samples","text":"<pre><code># Build\ncmake --build ../iree-build/\n\n# Run a standalone sample application\n../iree-build/runtime/src/iree/runtime/demo/hello_world_embedded\n# 4xf32=1 1.1 1.2 1.3\n#  *\n# 4xf32=10 100 1000 10000\n#  =\n# 4xf32=10 110 1200 13000\n\n# Try out the developer tools\nls ../iree-build/tools/\n../iree-build/tools/iree-compile --help\n../iree-build/tools/iree-run-module --help\n</code></pre>"},{"location":"building-from-source/getting-started/#python-bindings","title":"Python bindings","text":"<p>Python packages can either be built from source or installed from our releases. See the Python bindings page for details about the bindings themselves.</p>"},{"location":"building-from-source/getting-started/#dependencies","title":"Dependencies","text":"<p>You will need a recent Python installation &gt;=3.9 (we aim to support non-eol Python versions).</p> Tip - Managing Python versions <p>Make sure your 'python' is what you expect:</p>  Linux macOS Windows <p>Note that on multi-python systems, this may have a version suffix, and on many Linuxes where python2 and python3 can co-exist, you may also want to use <code>python3</code>.</p> <pre><code>which python\npython --version\n</code></pre> <p>Note that on multi-python systems, this may have a version suffix, and on macOS where python2 and python3 can co-exist, you may also want to use <code>python3</code>.</p> <pre><code>which python\npython --version\n</code></pre> <p>The Python launcher for Windows (<code>py</code>) can help manage versions.</p> <pre><code>which python\npython --version\npy --list-paths\n</code></pre> Tip - Virtual environments <p>We recommend using virtual environments to manage python packages, such as through <code>venv</code> (about, tutorial):</p>  Linux macOS Windows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate.bat\n</code></pre> <p>When done, run <code>deactivate</code>.</p> <pre><code># Upgrade PIP before installing other requirements\npython -m pip install --upgrade pip\n\n# Install IREE build requirements\npython -m pip install -r runtime/bindings/python/iree/runtime/build_requirements.txt\n</code></pre>"},{"location":"building-from-source/getting-started/#building-with-cmake","title":"Building with CMake","text":"<p>To build the Python bindings, configure CMake with the <code>IREE_BUILD_PYTHON_BINDINGS</code> option. We also recommend explicitly setting which Python executable to use with <code>Python3_EXECUTABLE</code>:</p> <pre><code># Configure (including other options as discussed above)\ncmake -G Ninja -B ../iree-build/ \\\n-DIREE_BUILD_PYTHON_BINDINGS=ON  \\\n-DPython3_EXECUTABLE=\"$(which python)\" \\\n.\n\n# Build\ncmake --build ../iree-build/\n</code></pre>"},{"location":"building-from-source/getting-started/#using-the-python-bindings","title":"Using the Python bindings","text":"<p>Extend your <code>PYTHONPATH</code> with IREE's <code>bindings/python</code> paths and try importing:</p>  Linux macOS Windows <pre><code>source ../iree-build/.env &amp;&amp; export PYTHONPATH\n# The 'PYTHONPATH' environment variable should now contain\n#   iree-build/compiler/bindings/python;iree-build/runtime/bindings/python\n\npython -c \"import iree.compiler; help(iree.compiler)\"\npython -c \"import iree.runtime; help(iree.runtime)\"\n</code></pre> <pre><code>source ../iree-build/.env &amp;&amp; export PYTHONPATH\n# The 'PYTHONPATH' environment variable should now contain\n#   iree-build/compiler/bindings/python;iree-build/runtime/bindings/python\n\npython -c \"import iree.compiler; help(iree.compiler)\"\npython -c \"import iree.runtime; help(iree.runtime)\"\n</code></pre> <pre><code>..\\iree-build\\.env.ps1  # or ..\\iree-build\\.env.bat\n# The 'PYTHONPATH' environment variable should now contain\n#   iree-build/compiler/bindings/python;iree-build/runtime/bindings/python\n\npython -c \"import iree.compiler; help(iree.compiler)\"\npython -c \"import iree.runtime; help(iree.runtime)\"\n</code></pre> <p>Using IREE's ML framework importers requires a few extra steps:</p> <pre><code># Install test requirements\npython -m pip install -r integrations/tensorflow/test/requirements.txt\n\n# Install pure Python packages (no build required)\npython -m pip install integrations/tensorflow/python_projects/iree_tf\npython -m pip install integrations/tensorflow/python_projects/iree_tflite\n\n# Then test the tools:\niree-import-tf --help\niree-import-tflite --help\n</code></pre>"},{"location":"building-from-source/ios/","title":"iOS cross-compilation","text":"<p>Cross-compilation for iOS consists of the two steps below.</p> <ul> <li>On the macOS host, build the IREE compiler.  We can run it to create   IREE modules.</li> <li>Build the IREE runtime on the macOS host for iOS devices and the   simulator.  We can then run the IREE module on the simulator.</li> </ul>","tags":["iOS"]},{"location":"building-from-source/ios/#prerequisites","title":"Prerequisites","text":"","tags":["iOS"]},{"location":"building-from-source/ios/#install-xcode-and-ios-sdk","title":"Install Xcode and iOS SDK","text":"<p>For cross-compilation, you need Xcode. It comes with the SDKs for iOS devices and the simulator, as well as the <code>simctl</code> tool for controlling the simulator from the command line.</p>","tags":["iOS"]},{"location":"building-from-source/ios/#host-environment-setup","title":"Host environment setup","text":"<p>On your host platform, you should already be able to build IREE from source.  Please make sure you've gone through the steps in getting started.</p>","tags":["iOS"]},{"location":"building-from-source/ios/#configure-and-build","title":"Configure and build","text":"","tags":["iOS"]},{"location":"building-from-source/ios/#build-the-iree-compiler-for-the-host","title":"Build the IREE compiler for the Host","text":"<p>Build and install on your macOS host:</p> <pre><code>cmake -S . -B ../iree-build/ -GNinja \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DCMAKE_INSTALL_PREFIX=../iree-build/install\n\ncmake --build ../iree-build/ --target install\n</code></pre>","tags":["iOS"]},{"location":"building-from-source/ios/#cross-compile-the-iree-runtime-for-ios","title":"Cross-compile the IREE runtime for iOS","text":"<p>Build the runtime for the iOS Simulator.</p> <pre><code>cmake -S . -B ../build-ios-sim -GNinja \\\n-DCMAKE_SYSTEM_NAME=iOS \\\n-DCMAKE_OSX_SYSROOT=$(xcodebuild -version -sdk iphonesimulator Path) \\\n-DCMAKE_OSX_ARCHITECTURES=arm64 \\\n-DCMAKE_SYSTEM_PROCESSOR=arm64 \\\n-DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 \\\n-DCMAKE_IOS_INSTALL_COMBINED=YES \\\n-DIREE_HOST_BIN_DIR=\"$PWD/../iree-build/install/bin\" \\\n-DCMAKE_INSTALL_PREFIX=../build-ios-sim/install \\\n-DIREE_BUILD_COMPILER=OFF\n\ncmake --build ../build-ios-sim --config Release --target install\n</code></pre> <p>Or, we can build the runtime for iOS devices it by changing the value of the <code>-DCMAKE OSX SYSROOT</code> option to:</p> <pre><code>  -DCMAKE_OSX_SYSROOT=$(xcodebuild -version -sdk iphoneos Path)\n</code></pre>","tags":["iOS"]},{"location":"building-from-source/ios/#running-iree-modules-on-the-ios-simulator","title":"Running IREE modules on the iOS Simulator","text":"<p>Run the IREE compiler on the host to generate a module.</p> <pre><code>../iree-build/install/bin/iree-compile \\\n--iree-hal-target-backends=vmvx \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre> <p>We could test the generated module by running the macOS version of <code>iree-run-module</code> on the host.</p> <pre><code>../iree-build/install/bin/iree-run-module \\\n--module=/tmp/simple_abs_vmvx.vmfb \\\n--device=local-task \\\n--function=abs \\\n--input=\"f32=-5\"\n</code></pre> <p>To run it on the iOS simulator, we need to copy the vmfb file into the <code>iree-run-module</code> iOS app bundle.</p> <pre><code>cp /tmp/simple_abs_vmvx.vmfb \\\n../build-ios-sim/install/bin/iree-run-module.app/\n</code></pre> <p>Open the iOS Simulator Manager on the host.</p> <pre><code>open -a Simulator\n</code></pre> <p>After creating and booting a simulator in this app, you can list it from the command-line.</p> <pre><code>xcrun simctl list devices | grep Booted\n</code></pre> <p>This is what should come out of the command:</p> <pre><code>    iPhone 14 Pro (12341234-ABCD-ABCD-ABCD-123412341234) (Booted)\n</code></pre> <p>where <code>iPhone 14 Pro</code> is the device being simulated and <code>12341234-ABCD-ABCD-ABCD-123412341234</code> is the simulator's unique device ID (UDID).</p> <p>Install the app <code>iree-run-module</code> on the simulator, given its UDID.</p> <pre><code>xcrun simctl install &lt;UDID&gt; ../build-ios-sim/install/bin/iree-run-module.app\n</code></pre> <p>Check the path to the installed bundle, where the <code>simple_abs_vmvx.vmfb</code> module should be found.</p> <pre><code>ls $(xcrun simctl get_app_container &lt;UDID&gt; dev.iree.iree-run-module)\n</code></pre> <p>The string <code>dev.iree.iree-run-module</code> is the bundle identifier of the iOS app.  The CMake building process generates it and saves it in the property list (plist) file <code>../build-ios-sim/install/bin/iree-run-module.app/Info.plist</code>.</p> <p>Launch the <code>iree-run-module</code> app on the simulator to run the IREE module <code>simple_abs_vmvx.vmfb</code>.</p> <pre><code>xcrun simctl launch --console \\\n&lt;UDID&gt; \\\ndev.iree.runmodule \\\n--device=local-task \\\n--function=abs \\\n--input=\"f32=-5\" \\\n--module=$(xcrun simctl get_app_container &lt;UDID&gt; dev.iree.iree-run-module)/simple_abs_vmvx.vmfb\n</code></pre>","tags":["iOS"]},{"location":"building-from-source/riscv/","title":"RISC-V cross-compilation","text":"<p>Running on a platform like RISC-V involves cross-compiling from a host platform (e.g. Linux) to a target platform (a specific RISC-V CPU architecture and operating system):</p> <ul> <li>IREE's compiler is built on the host and is used there to generate modules   for the target</li> <li>IREE's runtime is built on the host for the target. The runtime is then   pushed to the target to run natively.</li> </ul>","tags":["CPU"]},{"location":"building-from-source/riscv/#prerequisites","title":"Prerequisites","text":"","tags":["CPU"]},{"location":"building-from-source/riscv/#host-environment-setup","title":"Host environment setup","text":"<p>You should already be able to build IREE from source on your host platform. Please make sure you have followed the getting started steps.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#install-risc-v-cross-compile-toolchain-and-emulator","title":"Install RISC-V cross-compile toolchain and emulator","text":"<p>You'll need a RISC-V LLVM compilation toolchain and a RISC-V enabled QEMU emulator.</p> <p>See instructions in the following links</p> <ul> <li>Clang getting started</li> <li>RISC-V GNU toolchain</li> <li>QEMU</li> <li>RISC-V Linux QEMU</li> </ul> <p>Note</p> <p>The <code>RISCV_TOOLCHAIN_ROOT</code> environment variable needs to be set to the root directory of the installed GNU toolchain when building the RISC-V compiler target and the runtime library.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#install-prebuilt-risc-v-tools-risc-v-64-bit-linux-toolchain","title":"Install prebuilt RISC-V tools (RISC-V 64-bit Linux toolchain)","text":"<p>Execute the following script to download the prebuilt RISC-V toolchain and QEMU from the IREE root directory:</p> <pre><code>./build_tools/riscv/riscv_bootstrap.sh\n</code></pre> <p>Note</p> <p>The prebuilt toolchain is built with AlmaLinux release 8.8 docker It requires glibc &gt;= 2.28 for your host machine.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#support-vector-extension","title":"Support vector extension","text":"<p>For RISC-V vector extensions support, see additional instructions</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#configure-and-build","title":"Configure and build","text":"","tags":["CPU"]},{"location":"building-from-source/riscv/#host-configuration","title":"Host configuration","text":"<p>Build and install on your host machine:</p> <pre><code>cmake -GNinja -B ../iree-build/ \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DCMAKE_INSTALL_PREFIX=../iree-build/install \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n.\ncmake --build ../iree-build/ --target install\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#target-configuration","title":"Target configuration","text":"<p>The following instruction shows how to build for a RISC-V 64-bit Linux machine. For other RISC-V targets, please refer to riscv.toolchain.cmake as a reference of how to set up the cmake configuration.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#risc-v-64-bit-linux-target","title":"RISC-V 64-bit Linux target","text":"<pre><code>cmake -GNinja -B ../iree-build-riscv/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"./build_tools/cmake/riscv.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=$(realpath ../iree-build/install/bin) \\\n-DRISCV_CPU=linux-riscv_64 \\\n-DIREE_BUILD_COMPILER=OFF \\\n-DRISCV_TOOLCHAIN_ROOT=${RISCV_TOOLCHAIN_ROOT} \\\n-DIREE_ENABLE_CPUINFO=OFF \\\n.\ncmake --build ../iree-build-riscv/\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#running-iree-bytecode-modules-on-the-risc-v-system","title":"Running IREE bytecode modules on the RISC-V system","text":"<p>Note</p> <p>The following instructions are meant for the RISC-V 64-bit Linux target. For the bare-metal target, please refer to simple_embedding to see how to build a ML workload for a bare-metal machine.</p> <p>Set the path to qemu-riscv64 Linux emulator binary in the <code>QEMU_BIN</code> environment variable. If it is installed with <code>riscv_bootstrap.sh</code>, the path is default at ${HOME}/riscv/qemu/linux/RISCV/bin/qemu-riscv64.</p> <pre><code>export QEMU_BIN=&lt;path to qemu-riscv64 binary&gt;\n</code></pre> <p>Invoke the host compiler tools to produce a bytecode module FlatBuffer:</p> <pre><code>../iree-build/install/bin/iree-compile \\\n--iree-hal-target-backends=vmvx \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre> <p>Run the RISC-V emulation:</p> <pre><code>${QEMU_BIN} \\\n-cpu rv64 \\\n-L ${RISCV_TOOLCHAIN_ROOT}/sysroot/ \\\n../iree-build-riscv/tools/iree-run-module \\\n--device=local-task \\\n--module=/tmp/simple_abs_vmvx.vmfb \\\n--function=abs \\\n--input=f32=-5\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#optional-configuration","title":"Optional configuration","text":"<p>RISC-V Vector extensions allows SIMD  code to run more efficiently. To enable the vector extension for the compiler  toolchain and the emulator, build the tools from the following sources:</p> <ul> <li>RISC-V toolchain is built from https://github.com/llvm/llvm-project.<ul> <li>Currently, the LLVM compiler is built on GNU toolchain, including libgcc,   GNU linker, and C libraries. You need to build GNU toolchain first.</li> <li>Clone GNU toolchain from:   https://github.com/riscv/riscv-gnu-toolchain.   Switch the \"riscv-binutils\" submodule to   <code>git://sourceware.org/git/binutils-gdb.git</code> manually.</li> </ul> </li> <li>RISC-V QEMU is built from https://gitlab.com/qemu-project/qemu/tree/v8.1.2.</li> </ul> <p>The SIMD code can be generated following the IREE CPU flow with the additional command-line flags</p> <pre><code>tools/iree-compile \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-llvmcpu-target-triple=riscv64 \\\n--iree-llvmcpu-target-abi=lp64d \\\n--iree-llvmcpu-target-cpu-features=\"+m,+a,+f,+d,+zvl512b,+v\" \\\n--riscv-v-fixed-length-vector-lmul-max=8 \\\niree_input.mlir -o mobilenet_cpu.vmfb\n</code></pre> <p>Then run on the RISC-V QEMU:</p> <pre><code>${QEMU_BIN} \\\n-cpu rv64,Zve64d=true,vlen=512,elen=64,vext_spec=v1.0 \\\n-L ${RISCV_TOOLCHAIN_ROOT}/sysroot/ \\\n../iree-build-riscv/tools/iree-run-module \\\n--device=local-task \\\n--module=mobilenet_cpu.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre>","tags":["CPU"]},{"location":"community/","title":"Community projects","text":"<p>Projects built by community members:</p> <ul> <li> <p>The SHARK project from   nod.ai uses a forked version of IREE   (SHARK-Runtime), offering   highly tuned performance on a large corpus of machine learning programs.</p> </li> <li> <p>The IREE Bare-Metal Arm Sample   shows how to build IREE with the   Arm GNU Toolchain   for bare-metal Arm targets using the open-source firmware libraries   CMSIS and   libopencm3.</p> </li> <li> <p>The IREE C++ Template   shows one way to integrate IREE's runtime into a project with CMake.</p> </li> </ul> <p>Official repositories:</p> <ul> <li> <p>iree-jax is home to   IREE's support for JAX programs.</p> </li> <li> <p>iree-torch contains   IREE's PyTorch frontend, leveraging the   torch-mlir project.</p> </li> <li> <p>iree-samples   includes various samples and prototypes built with IREE.</p> </li> <li> <p>iree-llvm-sandbox   contains experimental work by the IREE team closely related to LLVM and   MLIR, usually with the aim of contributing back to those upstream projects.</p> </li> </ul>"},{"location":"community/tags/","title":"Tags","text":"<p>Website pages sorted by tag:</p>"},{"location":"community/tags/#android","title":"Android","text":"<ul> <li>Android cross-compilation</li> <li>Android LLDB debugging</li> </ul>"},{"location":"community/tags/#cpu","title":"CPU","text":"<ul> <li>RISC-V cross-compilation</li> <li>Matrix Multiplication with MMT4D</li> <li>Profiling CPUs</li> <li>CPU - Bare-Metal</li> <li>CPU</li> </ul>"},{"location":"community/tags/#cuda","title":"CUDA","text":"<ul> <li>CUDA backend</li> <li>CUDA backend design</li> <li>GPU - CUDA</li> </ul>"},{"location":"community/tags/#gpu","title":"GPU","text":"<ul> <li>CUDA backend</li> <li>Vulkan environment setup</li> <li>CUDA backend design</li> <li>Profiling GPUs using Vulkan</li> <li>GPU - CUDA</li> <li>GPU - Metal</li> <li>GPU - ROCm</li> <li>GPU - Vulkan</li> </ul>"},{"location":"community/tags/#jax","title":"JAX","text":"<ul> <li>JAX</li> <li>Extensions</li> <li>Glossary</li> </ul>"},{"location":"community/tags/#pytorch","title":"PyTorch","text":"<ul> <li>PyTorch</li> <li>Extensions</li> <li>Glossary</li> </ul>"},{"location":"community/tags/#python","title":"Python","text":"<ul> <li>JAX</li> <li>PyTorch</li> <li>TensorFlow</li> <li>TensorFlow Lite</li> <li>Python</li> </ul>"},{"location":"community/tags/#tensorflow","title":"TensorFlow","text":"<ul> <li>TFLite support via TOSA</li> <li>TensorFlow</li> <li>TensorFlow Lite</li> <li>Extensions</li> <li>Glossary</li> </ul>"},{"location":"community/tags/#vulkan","title":"Vulkan","text":"<ul> <li>Vulkan environment setup</li> <li>Profiling GPUs using Vulkan</li> <li>GPU - Vulkan</li> </ul>"},{"location":"community/tags/#web","title":"Web","text":"<ul> <li>Building with Emscripten</li> </ul>"},{"location":"community/tags/#ios","title":"iOS","text":"<ul> <li>iOS cross-compilation</li> <li>GPU - Metal</li> </ul>"},{"location":"community/blog/","title":"Blog","text":"<p>Updates from the IREE team</p>"},{"location":"community/blog/2021-10-15-cuda-backend/","title":"CUDA backend","text":"<p>IREE is being designed with re-targetability as a core goal: it should be possible to use IREE to target a broad spectrum of power regimes, from embedded systems to distributed clusters; and it should be possible to extend IREE to target new back-ends without having to reinvent the wheel each time.</p> <p>To explore this, we recently branched out from our initial focus on low-latency mobile deployments with a goal of using IREE to target data center workloads on Nvidia CUDA. This post describes how we quickly brought up a CUDA back-end for IREE and used it to train BERT, then shares some metrics and next steps.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#bring-up","title":"Bring up","text":"","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#hal-support","title":"HAL support","text":"<p>IREE has a HAL API that abstract all the targets behind a common interface. The first step to supporting a CUDA target was to map the HAL API onto CUDA. We use the CUDA driver API to reduce dependencies and be closer to the hardware. The HAL API is based on other GPU APIs like Vulkan and Metal, so it was a natural fit for CUDA. The HAL API exposes memory allocations, basic fill and memset commands, kernel dispatch, and general command buffer handling. The original implementation uses the CUDA graph API as a graph maps naturally to command buffers. There is also an implementation using CUDA streams for comparison.</p> <p>HAL exposes an API that can be tested independently, even if we are not able to create CUDA kernels yet we can test a large portion of the CUDA driver using CTS tests. Those can be run to make sure a system has the required CUDA support.</p> <p></p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#compiler-support","title":"Compiler support","text":"<p>CUDA has an open source backend in LLVM generating PTX that we are leveraging. Therefore IREE can create NVVM (CUDA LLVM variant) and use LLVM's backend to generate PTX. The CUDA driver will do the \"last mile compilation\" at runtime to convert PTX into the GPU's native ISA.</p> <p>IREE compiler pipeline starts from linalg with tensor operands. A large part of the compiler is independent of the target.</p> <p>The linalg on tensor representation of the graph is broken up into dispatch regions that are processed by NVVM Codegen. A simple implementation of the compiler is to run bufferization and convert linalg to standard followed by conversion to NVVM/LLVM. Most of those transformation can re-use upstream MLIR transformations and share it with any other backend targeting LLVM IR. Leveraging MLIR conversion to LLVM will allow us to quickly go from a simple \"hello world\" to supporting full models.</p> <p>IREE code generation is based on MLIR infrastructure so each step can easily be tested independently using the MLIR lit framework.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#flatbuffer-definition","title":"FlatBuffer definition","text":"<p>Kernels are encoded in a FlatBuffer containing the PTX code as well as the workgroup size to use for the dispatch. This allows serialization of the kernels in the IR, it is then de-serialized by the HAL layer.</p> <pre><code>table CUDAExecutableDef {\n  // A map of entry point ordinals to string names as used in the shader\n  // library.\n  entry_points:[string];\n\n  // Block sizes for each entry point.\n  block_sizes:[CUDABlockSizeDef];\n\n  // PTX string of the module.\n  ptx_image:string;\n}\n</code></pre>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#hello-world","title":"Hello world","text":"<p>Together those 3 steps are enough to provide most of the functionality and we can now successfully compile full models.</p> <p></p> <p>The steps to reproduce running a simple op end to end through CUDA backend are described here.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#performance","title":"Performance","text":"<p>Now that we have enabled functionality we need to look at the performance. Once again we can leverage existing MLIR transformations to speed up the developement work.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#tiling-and-distribution","title":"Tiling and distribution","text":"<p>The first obvious step to get efficient code on CUDA is to make sure we distribute the work on enough blocks and threads to fill up the GPU. At the time of bring up not all ops were being tiled and distributed in the common IREE layer. During dispatch region creation we apply tile and fuse which will distribute the work into a set of workgroups that are mapped to CUDA blocks.</p> <p>At the beginning of the code generation we look at the dispatch region and decide on the tile size for a workgroup. For CUDA we also decide the number of threads per block. We will then have a pass tiling the ops in the dispatch region a second time to distribute the work onto threads within the block.</p> <p>At this stage the IR looks like the following:</p> <pre><code>    %8 = \"gpu.thread_id\"() {dimension = \"x\"} : () -&gt; index\n    %9 = affine.apply affine_map&lt;()[s0] -&gt; (s0 * 4)&gt;()[%8]\n    %10 = memref.subview %in0[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %11 = memref.subview %in1[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %12 = memref.subview %out[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    linalg.generic {\n        indexing_maps = [affine_map&lt;(d0) -&gt; (d0)&gt;,\n                         affine_map&lt;(d0) -&gt; (d0)&gt;,\n                         affine_map&lt;(d0) -&gt; (d0)&gt;],\n        iterator_types = [\"parallel\"]}\n      ins(%10, %11 :\n          memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;,\n          memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;)\n      outs(%12 : memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;) {\n    ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors\n      %13 = addf %arg1, %arg2 : f32\n      linalg.yield %13 : f32\n    }\n</code></pre>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#vectorization","title":"Vectorization","text":"<p>Even though GPUs execute most operations as scalar, memory operations are optimized to access 128 bits of data per thread. Therefore it is critical to vectorize load/store operations. After tiling to a size we vectorize the IR to get vector read/write mapping to load4/store4. This significantly improves the memory access pattern of the code generated.</p> <p>This convert the previous IR to:</p> <pre><code>    %8 = \"gpu.thread_id\"() {dimension = \"x\"} : () -&gt; index\n    %9 = affine.apply affine_map&lt;()[s0] -&gt; (s0 * 4)&gt;()[%8]\n    %10 = memref.subview %in0[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %11 = memref.subview %in1[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %12 = memref.subview %out[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %13 = vector.transfer_read %10[%c0], %cst {in_bounds = [true]} : memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;, vector&lt;4xf32&gt;\n    %14 = vector.transfer_read %11[%c0], %cst {in_bounds = [true]} : memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;, vector&lt;4xf32&gt;\n    %15 = addf %13, %14 : vector&lt;4xf32&gt;\n    vector.transfer_write %15, %12[%c0] {in_bounds = [true]} : vector&lt;4xf32&gt;, memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n</code></pre>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#shared-memory-optimization","title":"Shared memory optimization","text":"<p>Nvidia GPUs have a fast shared memory that needs to be leveraged to optimize cases where we may be memory bound and have the potential to re-use memory reads.</p> <p>For operations like GEMM using shared memory gives us a significant speed up. We leverage memory promotion, vector distribution and software pipelining transformations from MLIR to generate efficient copies from global to shared memory that can be interleaved with the compute work.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#optimization-pipeline","title":"Optimization pipeline","text":"<p>Those different transformations compose to this flow:</p> <p></p> <p>The full dump step by step of a linalg.matmul operation can be found here.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#results-and-next-steps","title":"Results and next steps","text":"","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#gemm","title":"GEMM","text":"<p>We compare the performance of a single GEMM operation to highly optimized library cuBLAS using mmperf framework.</p> <p></p> <p>The graph can be re-produced based on instructions on mmperf</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#future-work","title":"Future work","text":"<p>Nod.ai has contributed an experimental HAL module for ROCM that allows us to re-use the compiler parts to support ROCM, more support is going to be added in the future.</p> <p>Several performance improvements are still under progress, including optimizing the runtime allocator to reduce the host-side overhead and tuning tile sizes based profiling.</p> <p>Several models are running and we will publish more detailed benchmark results in the near future.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-13-matrix-multiplication-with-mmt4d/","title":"Matrix Multiplication with MMT4D","text":"","tags":["CPU"]},{"location":"community/blog/2021-10-13-matrix-multiplication-with-mmt4d/#introduction","title":"Introduction","text":"<p>Matrix multiplication (matmul) is an important operation in ML workloads that poses specific challenges to code generation. For example, matmul makes repeated accesses to the same data, which makes locality of reference a top concern.</p> <p>Moreover, modern CPUs instruction set architectures (ISAs) offer specialized SIMD instructions that the matmul implementation needs to use to achieve optimal performance, and these instructions expect data to be in a particular layout.</p> <p>This article is about an in-development MLIR operation, <code>linalg.mmt4d</code>, offering a compilation path for <code>linalg.matmul</code> that is designed from the ground up for these efficiency considerations.</p> <p>We are still in the early implementation phase of this <code>linalg.mmt4d</code> plan, but we feel confident that we know where we are going because what we are really doing here is importing into the compiler what we have learned working on optimized matrix multiplication libraries, particularly Ruy. We know what loop schedule and kernel we want the compiler to generate \u2014 essentially the same as we wrote in Ruy, give or take additional optimizations such as fusions and constant folding that become possible now that we are doing this within a compiler. This allows us to focus on how we get the compiler to generate that schedule and kernel with purely algebraic transformations that compose and enable further compiler optimizations.</p> <p>At the basis of this work is the extensible op system of the Linalg dialect in the MLIR compiler toolkit. In this case, a general purpose, mixed precision mmt4d op is defined via a high level description directly in the compiler and is then available to both users of the compiler (as a <code>linalg.mmt4d</code> op) or for direct emission via Python based IR construction (i.e. for direct integration into high level frameworks without rebuilding the compiler). The ability to define such new special forms cheaply, and without any systemic framework level cost, is part of the extensibility and composition story that we expect will become increasingly important in development and deployment scenarios in the future, and in this case, it let us spring board off of high quality code generation which was already well integrated and composed well with other features of the compiler.</p>","tags":["CPU"]},{"location":"community/blog/2021-10-13-matrix-multiplication-with-mmt4d/#existing-matrix-multplication-code-generation","title":"Existing Matrix Multplication Code Generation","text":"<p>Let us start by discussing IREE\u2019s existing matmul code generation and highlight the issues that <code>mmt4d</code> aims to overcome.</p> <p>The existing approach operates in-place on the source matrices. When we discuss \"tiling\" in this paragraph, we refer exclusively to the traversal \u2014 how these source matrices are traversed by the matmul loop. There is no \"tiled layout\" here, which will be the key difference with <code>mmt4d</code> below.</p> <p>The destination matrix is tiled into workgroups (CPU threads) tiles, then each workgroup tile is tiled to fit some level of CPU cache, and finally each tile is further tiled to fit target architecture registers (e.g. 8x8).</p> <p>That multi-level tiling means that the code works like the following loop nest:</p> <pre><code>def tiled_matmul(A, B, C, tile_m, tile_n, tile_k, tile_m_v, tile_n_v, tile_k_v):\n m = A.shape[0]\n k = A.shape[1]\n n = B.shape[1]\n for m1 in range(0, m, tile_m):\n   for n1 in range(0, n, tile_n):\n     for k1 in range(0, k, tile_k):\n       # First level of tiling views...\n       lhs_tile = A[m1:m1+tile_m, k1:k1+tile_k]\n       rhs_tile = B[k1:k1+tile_k, n1:n1+tile_n]\n       dst_tile = C[m1:m1+tile_m, n1:n1+tile_n]\n       for mv in range(0, tile_m, tile_m_v):\n         for nv in range(0, tile_n, tile_n_v):\n           for kv in range(0, tile_k, tile_k_v):\n             # Register tiling views...\n             lhs_tile_v = lhs_tile[mv:mv+tile_m_v, kv:kv+tile_k_v]\n             rhs_tile_v = rhs_tile[kv:kv+tile_k_v, nv:nv+tile_n_v]\n             # kernel.\n             dst_tile[mv:mv+tile_m_v, nv:nv+tile_n_v] += np.matmul(lhs_tile_v, rhs_tile_v)\n return C\n</code></pre> <p>The two main problems with this approach are:</p> <ul> <li> <p>Overhead to meet SIMD ISA layout requirements: In practice, the kernel     needs to use specific SIMD     instructions to perform the arithmetic. They expect small tiles of the     matrices to be loaded in registers, in a specific layout. If the matrix data     wasn't already stored in memory in such a tiled layout, then the kernel has     to perform such a data rearrangement on the fly, incurring substantial     overhead. For NxN matrix multiplication, the kernel performs     O(N<sup>3</sup>) work on O(N<sup>2</sup>) data, so doing that rearrangement     there means O(N<sup>3</sup>) overhead where O(N<sup>2</sup>) should have     sufficed, as this could have been done as a pre-processing step on     O(N<sup>2</sup>) data.</p> </li> <li> <p>Inefficent memory traversal: For efficiency reasons, we always need     <code>tile_m_v&gt;1</code> and <code>tile_n_v&gt;1</code>. That is because the higher these values, the     fewer memory-load instructions are needed overall; and this is also dictated     by the SIMD instructions that we want to use. But that means that the kernel     is accessing simultaneously multiple rows or columns of the left-hand and     right-hand side matrices. And in this existing approach, they are stored in     linear layout, not in a tiled layout, so these accesses are not contiguous     in memory. This is detrimental to memory access performance, meaning the     CPU caches, in multiple ways. One     is that these multiple non-contiguous accesses may alias each other in the     L1 cache because of low     associativity.</p> </li> </ul>","tags":["CPU"]},{"location":"community/blog/2021-10-13-matrix-multiplication-with-mmt4d/#matrix-multiplication-operation-with-4d-tiled-operands","title":"Matrix Multiplication Operation With 4D Tiled Operands","text":"<p>For the reasons above, an efficient matmul implementation must reorder data into a tiled layout matching the target SIMD ISA and making the memory access patterns as contiguous as possible.</p> <p>IREE/MLIR defaults to bufferizing all tensors into a \"row-major\" order, meaning that the last-enumerated dimension is the one that is contiguous in memory. As we prefer not to write custom bufferization code, we can't specify an alternative layout for a tensor. Fortunately, it is possible to represent a 2D tiled layout as a 4D layout. For example, <code>tensor&lt;2x2x2x2xf32&gt;</code> can represent a 4x4 matrix made of 2x2 tiles, each of which is 2x2. The row-major layout on <code>tensor&lt;2x2x2x2xf32&gt;</code> makes each 2x2 tile contiguous and row-major, and arranges the 2x2 tiles themselves into a row-major 2x2 layout in the overall 4x4 matrix.</p> <p>Such a row-major-tiled layout is exactly what we need for the left-hand side of a matrix multiplication, because matrix multiplication traverses the left-hand side matrix row by row. But for the right-hand side matrix, we want a column-major-tiled layout. To solve this problem, we decide to implement not matrix multiplication, but matrix-multiplication-by-transposed-right-hand-side which is where the <code>t</code> in the <code>linalg.mmt4d</code> came from. Now such an op is happy with both the left and right-hand sides being row-major-tiled.</p> <p>The following example illustrates that. In these diagrams, each matrix element is rendered its memory offset.</p> <p></p> <p>To compute the 2x2 block in the destination matrix, we will have to load two yellow blocks from LHS, RHS matrices respectively compute their matmul results (i.e. call the kernel), then the two blue blocks, and so on. As we can see, each tile loads data that is not contiguous. It would be better if we rearranged the elements in the following layout:</p> <p></p> <p>Now tiles are stored contiguously in memory and the kernel can simply load them from memory into the registers that will be directly consumed by the SIMD instructions performing the multiplications. Moreover, the kernel is now loading from just two contiguous data streams, a simple memory access pattern which is sure to be efficient (regarding caches, etc) on any reasonable target hardware.</p> <p>We introduce a <code>linalg.mmt4d</code> operation that performs such a matrix multiplication on matrices in a tiled layout represented as 4D tensors. That leaves the question of how to represent, within the linalg dialect, the conversions between ordinary matrices represented as 2D tensors, and these tiled matrices represented as 4D tensors. Moreover, these conversions should be tileable and decompose well. Thankfully, the transformation from 2D to 4D can be written as a reshape followed by a transpose as in the following digram:</p> <p></p> <p>So we can think of the outermost two dimensions of the 4D representations as the tile position in the overall matrix, and the innermost two as the element position within one tile. Hopefully the following Python pseudocode makes it more concrete:</p> <pre><code>def pack_2d_4d(operand, parallel_size, reduction_size):\n i1 = operand.shape[0] // parallel_size # M1\n i2 = parallel_size    # M0\n j1 = operand.shape[1] // reduction_size # K1\n j2 = reduction_size   # K0\n operand_4d = np.reshape(operand, [i1, i2, j1, j2])\n return np.transpose(operand_4d, [0, 2, 1, 3]) # [M1, K1, M0, K0]\n</code></pre> <p>Now the mmt4d operation will follow a structure as the multi level tiling, for simplicity we considered the case here where no L1 tiling is required only first level of distribution to workgroups:</p> <pre><code>def mmt4d(A, B, C, M0, N0, K0):\n M = A.shape[0]\n N = B.shape[1]\n Bt = np.transpose(B, [1, 0])\n A4d = pack_2d_4d(A, M0, K0)\n Bt4d = pack_2d_4d(Bt, N0, K0)\n M1 = A4d.shape[0]\n N1 = Bt4d.shape[0]\n K1 = A4d.shape[1]\n for m1 in range(0, M1):\n   for n1 in range(0, N1):\n     for k1 in range(0, K1):\n       # Tile views that are contiguous in memory.\n       lhs_tile = np.reshape(A4d[m1, k1, :, :], [M0, K0])\n       rhs_tile = np.reshape(Bt4d[n1, k1, :, :], [N0, K0])\n       # Inner kernel.\n       C[m1, n1, :, :] += np.matmul(lhs_tile, np.transpose(rhs_tile, [1, 0]))\n # 4d -&gt; 2D\n C2d = unpack_4d_2d(C)\n return C2d\n</code></pre> <p>The resulting 4D tiled matrix still needs be rearranged back to the original layout as 2D tensor:</p> <pre><code>def unpack_4d_2d(operand):\n i1 = operand.shape[0] # M1\n j1 = operand.shape[1] # N1\n i2 = operand.shape[2] # M0\n j2 = operand.shape[3] # N0\n operand_transposed = operand.transpose([0, 2, 1, 3]) # [M1, M0, N1, N0]\n return operand_transposed.reshape([i1 * i2, j1 * j2]) # [M, N]\n</code></pre>","tags":["CPU"]},{"location":"community/blog/2021-10-13-matrix-multiplication-with-mmt4d/#performance-results","title":"Performance Results","text":"<p>We benchmarked various float32 matmul problems of different sizes and the result showed that mmt4d is faster than the existing matmul implementation for bigger matrices as we can see the in the following chart:</p> <p></p> <p>The SIMD instruction being used here is the simplest kind, a <code>vector*scalar</code> multiplication, and the storage orders of the matrices allow the existing implementation to directly load the vectors from the source matrices without any rearrangement overhead. So this case is particularly friendly to the existing code, which is why the mmt4d code is only faster for bigger matrices. To understand why mmt4d is faster in that case, we collected statistics of L1 cache misses:</p> <p></p> <p>This shows that in this case, the better cache-friendliness of mmt4d, thanks to its simple contiguous memory access pattern, accounts for its higher performance.</p> <p>As we proceed with increasingly sophisticated SIMD targets, starting with the dot-product instructions found in current mobile devices for the int8 case and going to become generalized to all data types all the way to float32 over the next few years with upcoming ARM SIMD instructions, the advantage of mmt4d will widen for all sizes, not just the larger ones.</p> <p>Part of why we feel confident about the eventual performance that our approach will achieve is that, as mentioned in the introduction, we are rebuilding within the compiler an existing library's schedule and kernel, and we have benchmark results about it.</p>","tags":["CPU"]},{"location":"community/blog/2021-10-13-matrix-multiplication-with-mmt4d/#conclusion","title":"Conclusion","text":"<p>We introduced a 4d tiled representation for 2d matrix-matrix multiplication with a decomposable algebric transformations that requires only reshape and transpose of input operands, we discussed and empirically showed how that solves major drawbacks in row-major linear matmul by providing a flexible way to match different ISA layout along with better cache locality achieving near peak performance.</p> <p>As was mentioned in the introduction, this work in under active development and the next immediate steps are to prove the rest of the hypothesis by:</p> <ul> <li> <p>Handling dynamic sizes and padding to the next multiple of the target tile   size.</p> </li> <li> <p>Implementing the integer case (<code>int32 += int8 * int8</code>).</p> </li> <li> <p>Implementing the dispatch to different SIMD ISA variants at runtime.</p> </li> <li> <p>Implementing cache-friendly traversal for larger matmuls and multi-threading   by interfacing with IREE's runtime dispatch.</p> </li> <li> <p>Improving the generated code by fusing the 4d tiled layout with the   producers and consumers of the <code>linalg.mmt4d</code>.</p> </li> </ul>","tags":["CPU"]},{"location":"community/blog/2021-07-19-tflite-support-via-tosa/","title":"TFLite support via TOSA","text":"<p>IREE can now execute TensorFlow Lite (TFLite) models through the use of TOSA, an open standard of common tensor operations, and a part of MLIR core. TOSA\u2019s high-level representation of tensor operations provides a common front-end for ingesting models from different frameworks. In this case we ingest a TFLite FlatBuffer and compile it to TOSA IR, which IREE takes as an input format to compile to its various backends.</p> <p></p> <p>Using TFLite as a frontend for IREE provides an alternative ingestion method for already existing models that could benefit from IREE\u2019s design. This enables models already designed for on-device inference to have an alternative path for execution without requiring any additional porting, while benefiting from IREE\u2019s improvements in buffer management, work dispatch system, and compact binary format. With continued improvements to IREE/MLIR\u2019s compilation performance, more optimized versions can be compiled and distributed to target devices without an update to the clientside environment.</p> <p>Today, we have validated floating point support for a variety of models, including mobilenet (v1, v2, and v3) and mobilebert. More work is in progress to support fully quantized models, and TFLite\u2019s hybrid quantization, along with dynamic shape support.</p>","tags":["TensorFlow"]},{"location":"community/blog/2021-07-19-tflite-support-via-tosa/#examples","title":"Examples","text":"<p>TFLite with IREE is available in Python and Java.  We have a colab notebook that shows how to use IREE\u2019s python bindings and TFLite compiler tools to compile a pre-trained TFLite model from a FlatBuffer and run using IREE.  We also have an Android Java app that was forked from an existing TFLite demo app, swapping out the TFLite library for our own AAR.  More information on IREE\u2019s TFLite frontend is available here.</p>","tags":["TensorFlow"]},{"location":"developers/","title":"Developers","text":"<p>These pages cover topics useful for project maintainers and contributors.</p> <p>Caution</p> <p>Some of these pages may be stale. Contributions are always welcome!</p>"},{"location":"developers/usage-best-practices/","title":"Usage best practices","text":"<p>This page contains a list of best practices for getting the most out of IREE, spanning model authoring, ahead-of-time compilation, and runtime use. Treat these as a collection of ideas to consider or areas to start benchmarking when working on your own applications.</p>"},{"location":"developers/usage-best-practices/#introduction","title":"Introduction","text":"<p>Common themes include:</p> <ul> <li>Give the compiler as much information as possible</li> <li>Give the compiler opportunities to batch work together or defer computation</li> <li>Keep compute devices saturated with work through pipelining</li> <li>Use dense math where possible, particularly for inner loop bodies</li> <li>Limit synchronization points between devices like CPUs and GPUs</li> <li>Profile early and often, using the right tools for each level of granularity</li> </ul>"},{"location":"developers/usage-best-practices/#practices-for-model-authoring","title":"Practices for model authoring","text":""},{"location":"developers/usage-best-practices/#track-state-within-your-model-when-possible","title":"Track state within your model when possible","text":"<p>If your model is stateful prefer to store that state directly within your program rather than externalizing it through arguments and return values. By keeping state inside your program the compiler is better able to reason about it and function calls will have lower overhead.</p> <p>If you do externalize state, try to pack that state into a limited number of arguments.</p> <p>See the variables and state sample for further guidance on tracking and using state.</p>"},{"location":"developers/usage-best-practices/#limit-uses-of-dynamic-shapes","title":"Limit uses of dynamic shapes","text":"<p>While IREE aims to support general dynamic shapes use, it is better able to optimize parts of programs where shapes are static. Slow varying dimensions like batch index or timestamp are safer uses of dynamic shapes than faster varying dimensions like the x/y/channel dimensions of images.</p> <p>See the dynamic shapes sample for further guidance on using dynamic shapes.</p>"},{"location":"developers/usage-best-practices/#practices-for-compilation-settings","title":"Practices for compilation settings","text":"<p>TODO: which compiler targets to use (try both CUDA and Vulkan?)</p> <p>TODO: use the most specific LLVM target triple you can?</p>"},{"location":"developers/usage-best-practices/#tuning-compilation-heuristics","title":"Tuning compilation heuristics","text":"<p>IREE runs its own suite of benchmarks continuously using the definitions at https://github.com/openxla/iree/tree/main/benchmarks. The flags set for these benchmarks represent the latest manually tuned values for workloads we track closely and referencing them may help with your own search for peak performance. You can use these flags in your own explorations, but note that as compiler performance matures, the existing flags will gradually be replaced with attributes for autotuning or command line options for experimental features.</p>"},{"location":"developers/usage-best-practices/#practices-for-runtime-use","title":"Practices for runtime use","text":"<p>TODO: sample code, profile numbers</p>"},{"location":"developers/usage-best-practices/#tuning-runtime-settings","title":"Tuning runtime settings","text":"<p>When running on the CPU, the task system flags specified in iree/task/api.c give control over how worker threads will be created. For example, the <code>--task_topology_group_count=3</code> flag can be set to explicitly run on three workers rather than rely on heuristic selection that defaults to one worker per detected physical core.</p> <p>If running on a single thread or system with no threading support the <code>local-sync</code> HAL driver can be used instead of the multithreaded <code>local-task</code> HAL driver to reduce dependencies and code size. When running with the <code>local-sync</code> driver all execution happens inline on the thread invoking the IREE runtime and will block until it has completed.</p>"},{"location":"developers/usage-best-practices/#do-the-minimum-amount-of-work-cache-queries-and-reuse-buffers","title":"Do the minimum amount of work: cache queries and reuse buffers","text":"<p>When using IREE's runtime libraries, try to front-load queries, particularly queries using strings that look up into maps like <code>iree_runtime_session_call_by_name</code>, so that hot sections of code are doing the minimum amount of work: routing inputs through buffers, scheduling runtime calls, and routing outputs through other buffers.</p>"},{"location":"developers/vulkan-environment-setup/","title":"Vulkan environment setup","text":"<p>Vulkan is a new generation graphics and compute API that provides high-efficiency, cross-platform access to modern GPUs used in a wide variety of devices from PCs and consoles to mobile phones and embedded platforms.</p> <p>This page lists steps and tips for setting up and troubleshooting a Vulkan development environment. The information here is meant to be generic.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#vulkan-architecture","title":"Vulkan architecture","text":"<p>Vulkan adopts a layered architecture, which aims to better support extensiblity. There are four components involved in this architecture:</p> <ul> <li>The Vulkan Application</li> <li>The Vulkan Loader</li> <li>Vulkan Layers</li> <li>Installable Client Drivers (ICDs)</li> </ul> <p></p> <p>The Vulkan loader sits between the Vulkan application, which calls Vulkan APIs, and the ICDs, which implements these Vulkan APIs. Vulkan layers agument the Vulkan system to provide optional features like validation and debugging. The Vulkan loader composes a chain of requested layers, which processes the Vulkan application's API calls one by one, and finally redirects the API calls made by the Vulkan application to one or more ICDs.</p> <p>It's highly recommned to read the Architecture of the Vulkan Loader Interfaces Overview to get a general understanding of what these components are and how they interact with one another.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#vulkan-development-environment-setup","title":"Vulkan development environment setup","text":"","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#windows","title":"Windows","text":"<p>You need to install the Vulkan SDK from LunarG to get the Vulkan loader.</p> <p>Typically the Vulkan SDK will be installed at <code>C:\\VulkanSDK\\&lt;version&gt;\\</code> and there will be an environment variable <code>VULKAN_SDK</code> pointing to it. You can run the <code>vulkancube</code> executable under the <code>Bin\\</code> subdirectory of the Vulkan SDK to make sure everything works properly. If not, you probably need to check whether the graphics card is Vulkan capable or update the driver.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#debianubuntu","title":"Debian/Ubuntu","text":"<p>The following packages should be installed for a proper Vulkan runtime to test the runtime functions properly:</p> <ul> <li>libvulkan1 for the Vulkan loader <code>libvulkan.so</code>.</li> <li>[AMD] [mesa-vulkan-drivers]PackageMesaVulkan for Mesa AMD Vulkan ICD.</li> <li>[NVIDIA] [nvidia-vulkan-icd]PackageNvidiaVulkan for NVIDIA Vulkan ICD.</li> </ul> <p>The above packages provide the Vulkan loader and ICDs. With them an Vulkan application should be able to run. You may additionally want to install</p> <ul> <li>vulkan-tools for command-line tools like <code>vulkaninfo</code>     (dumping available ICDs and their capabilities) and GUI application like     <code>vulkancube</code> (rendering a rotating cube).</li> </ul> <p>In order to develop Vulkan applications, you additionally need the following packages:</p> <ul> <li>libvulkan-dev for various Vulkan header files.</li> <li>vulkan-validationlayers for Vulkan validation     layers like <code>VkLayer_standard_validation</code>.</li> </ul>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#linux","title":"Linux","text":"<p>For other Linux distros, please consult the corresponding package management tools for the packages needed. (And please feel free to update this doc regarding them.)</p> <p>You can also download and install the Vulkan SDK from LunarG. It packages the loader with many useful layers and other shader tools. The source code of the SDK component projects are included, allowing you to recompile the artifacts if needed.</p> <p>You can also build the Vulkan SDK component projects like Vulkan-Loader and Vulkan-ValidationLayers from source. But note that building these components separately you need to make sure they are consistent with one another (e.g., using the same version of Vulkan headers) to function together.</p> <p>If you have multiple versions of Vulkan loaders exist, you may also need to set <code>LD_LIBRARY_PATH</code> and <code>LD_PRELOAD</code> to load the desired version of the loader. For example:</p> <pre><code>LD_LIBRARY_PATH={PATH_TO_VULKAN_SDK}/x86_64/lib/\nLD_PRELOAD=libvulkan.so.1\n</code></pre> <p>This can also be done by sourcing the proper <code>setup-env.sh</code> from one of the downloaded Vulkan SDKs.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#android","title":"Android","text":"<p>Please make sure your Android device is Vulkan capable. Vulkan is supported on Android since 7, but we track newer Android versions (10+) closely and haven't set a clear min version yet.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#troubleshooting-vulkan-function-vkcreateinstance-not-available","title":"Troubleshooting Vulkan function <code>vkCreateInstance</code> not available","text":"<p>Since Android 8 Oreo, Android re-architected the OS framework with project Treble. Framework libraries and vendor libraries have a more strict and clear separation. Their dependencies are carefully scrutinized and only selected cases are allowed. This is enforced with linker namespaces.</p> <p><code>/data/local/tmp</code> is the preferred directory for automating native binary tests built using NDK toolchain. They should be allowed to access libraries like <code>libvulkan.so</code> for their functionality. However, there was an issue with fully treblized Android 10 where <code>/data/local/tmp</code> did not have access to the linker namespaces needed by <code>libvulkan.so</code>. This should be fixed now. But as typically in the Android system, it takes a long time to see the fix getting propagated, if ever.</p> <p>A known workaround is to symlink the vendor Vulkan implementation under <code>/vendor/lib[64]</code> as <code>libvulkan.so</code> under <code>/data/local/tmp</code> and use <code>LD_LIBRARY_PATH=/data/local/tmp</code> when invoking IREE executables.</p> <p>For Qualcomm Adreno GPUs, the vendor Vulkan implementation is at <code>/vendor/lib[64]/hw/vulkan.*.so</code>. So for example for Snapdragon 865:</p> <pre><code>adb shell ln -s /vendor/lib64/hw/vulkan.kona.so /data/local/tmp/libvulkan.so\n</code></pre> <p>For ARM Mali GPUs, there is only one monolithic driver (<code>/vendor/lib[64]/libGLES_mali.so</code>) for OpenGL and Vulkan and the Vulkan vendor driver (<code>/vendor/lib[64]/hw/vulkan.*.so</code>) is just a symlink to it. So for example:</p> <pre><code>adb shell ln -s /vendor/lib64/libGLES_mali.so /data/local/tmp/libvulkan.so\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#vulkan-debugging-and-profiling","title":"Vulkan debugging and profiling","text":"","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#renderdoc","title":"RenderDoc","text":"<p>RenderDoc is an awesome tool that one can use to capture and introspect Vulkan applications. It can be downloaded from RenderDoc's website or compiled from source.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#vulkan-development-environment-troubleshooting","title":"Vulkan development environment troubleshooting","text":"","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#useful-environment-variables","title":"Useful environment variables","text":"<p>There are a few environment variables that can alter the default Vulkan loader behavior and print verbose information, notably:</p> <ul> <li><code>VK_LOADER_DEBUG</code>: enable loader debug messages. Setting it to <code>all</code> will     enable the most verbose logging from the loader. This is especially useful     when trying to see what layers/ICDs are searched and used.</li> <li><code>VK_ICD_FILENAMES</code>: force the loader to use a specific ICD. This is     especially useful when you have multiple Vulkan capable devices and want to     select which one to use manually.</li> <li><code>VK_INSTANCE_LAYERS</code>: force the loader to enable the given layers. For     example, You can force enable <code>VK_LAYER_LUNARG_api_dump</code> to have a detailed     dump of all Vulkan API calls made by the application. You can force enable     <code>VK_LAYER_LUNARG_core_validation</code> to validate the API calls made by the     application.</li> <li><code>VK_LAYER_PATH</code>: override the loader's standard layer library search folders.</li> </ul> <p>Please see the Vulkan loader's documentation for detailed explanation for these variables.</p>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#setting-environment-variables-for-bazel-test","title":"Setting environment variables for Bazel test","text":"<p>Bazel runs tests in a sandbox and environment variables must be passed through to the test runner. Consider putting environment setup in a <code>user.bazelrc</code> to save typing. For example:</p> <pre><code>test --test_env=\"LD_LIBRARY_PATH=/absolute/path/to/vulkan/sdk/x86_64/lib/\"\ntest --test_env=\"LD_PRELOAD=libvulkan.so.1\"\ntest --test_env=\"VK_LAYER_PATH=/absolute/path/to/additional/layers/:$VK_LAYER_PATH\"\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"developers/vulkan-environment-setup/#ssh-on-linux-and-x-forwarding","title":"SSH on Linux and X forwarding","text":"<p>Physical devices enumerated on NVIDIA drivers can be affected by the <code>DISPLAY</code> environment variable. If you are running under an SSH session to Linux or using chrome remote desktop and have problems with physical device enumeration, you probably want to check the <code>DISPLAY</code> environment and set it to point to a display at the server side, for example:</p> <pre><code>export DISPLAY=:0\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"developers/building/bazel/","title":"Building with Bazel","text":"<p>This page walks through building IREE from source using the Bazel build system.</p> <p>Warning</p> <p>Bazel build support is primarily for internal project infrastructure. We strongly recommend using CMake instead.</p> <p>Our Bazel configuration is also only tested on Linux. Windows and macOS may be unstable.</p>"},{"location":"developers/building/bazel/#prerequisites","title":"Prerequisites","text":"Linux macOS Windows <ol> <li> <p>Install Bazel, matching IREE's     <code>.bazelversion</code>     by following the     official docs.</p> </li> <li> <p>Install a compiler such as Clang (GCC is not fully supported).</p> <pre><code>sudo apt install clang\n</code></pre> <p>Set environment variables for Bazel:</p> <pre><code>export CC=clang\nexport CXX=clang++\n</code></pre> </li> <li> <p>Install Python build requirements:</p> <pre><code>python -m pip install -r runtime/bindings/python/iree/runtime/build_requirements.txt\n</code></pre> </li> </ol> <ol> <li> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\"\n</code></pre> </li> <li> <p>Install Bazel, matching IREE's     <code>.bazelversion</code>     by following the official docs or     via Homebrew:</p> <pre><code>brew install bazel\n</code></pre> </li> <li> <p>Install Python build requirements:</p> <pre><code>python -m pip install -r runtime/bindings/python/iree/runtime/build_requirements.txt\n</code></pre> </li> </ol> <p>Tip</p> <p>You can simplify installation by using a package manager like Scoop or Chocolatey.</p> <ol> <li> <p>Install Bazel, matching IREE's     <code>.bazelversion</code>     by following the official docs.</p> <p>Also install MSYS2 by following Bazel's documentation.</p> </li> <li> <p>Install Python3 (docs here)     and Python build requirements:</p> <pre><code>python -m pip install -r runtime/bindings/python/iree/runtime/build_requirements.txt\n</code></pre> </li> <li> <p>Install the full Visual Studio or \"Build Tools For Visual Studio\" from the     downloads page then     set the <code>BAZEL_VS</code> environment variable:</p> <pre><code>&gt; $env:BAZEL_VS = \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2022\\BuildTools\"\n</code></pre> </li> </ol>"},{"location":"developers/building/bazel/#quickstart-clone-and-build","title":"Quickstart: clone and build","text":""},{"location":"developers/building/bazel/#clone","title":"Clone","text":"<p>Use Git to clone the IREE repository and initialize its submodules:</p> <pre><code>git clone https://github.com/openxla/iree.git\ncd iree\ngit submodule update --init\n</code></pre> <p>Configure Bazel:</p> <pre><code># This generates a `configured.bazelrc` file by analyzing your environment.\n# Skipping this step will make it difficult to select your platform/compiler.\npython3 configure_bazel.py\n</code></pre>  Linux macOS Windows <p>(No Linux-specific tips for configuring)</p> <p>(No macOS-specific tips for configuring)</p> <p>Tip</p> <p>Clone to a short path like <code>C:\\projects\\</code> to avoid issues with Windows maximum path lengths (260 characters).</p> <p>Tip</p> <p><code>configure_bazel.py</code> only detects that you have Windows and will output the default <code>--config=windows</code> to <code>configured.bazelrc</code>, which assumes the latest version of MSVC. To avoid some warnings, you may want to replace it with (for example) <code>--config=msvc2022</code>.</p>"},{"location":"developers/building/bazel/#build","title":"Build","text":"<p>Run all core tests:</p> <pre><code>bazel test -k //...\n</code></pre> <p>Tip</p> <p>You can add flags like <code>--test_env=IREE_VULKAN_DISABLE=1</code> to your test command to change how/which tests run.</p> <p>In general, build artifacts will be under the <code>bazel-bin</code> directory at the top level.</p>"},{"location":"developers/building/bazel/#recommended-userbazelrc","title":"Recommended <code>user.bazelrc</code>","text":"<p>You can put a user.bazelrc at the root of the repository and it will be ignored by git.</p>  Linux macOS Windows <pre><code>build --disk_cache=/tmp/bazel-cache\n\n# Use --config=debug to compile IREE and LLVM without optimizations\n# and with assertions enabled.\nbuild:debug --config=asserts --compilation_mode=opt '--per_file_copt=iree|llvm@-O0' --strip=never\n\n# Use --config=asserts to enable assertions. This has to be done globally:\n# Code compiled with and without assertions can't be linked together (ODR violation).\nbuild:asserts --compilation_mode=opt '--copt=-UNDEBUG'\n</code></pre> <pre><code>build --disk_cache=/tmp/bazel-cache\n\n# Use --config=debug to compile IREE and LLVM without optimizations\n# and with assertions enabled.\nbuild:debug --config=asserts --compilation_mode=opt '--per_file_copt=iree|llvm@-O0' --strip=never\n\n# Use --config=asserts to enable assertions. This has to be done globally:\n# Code compiled with and without assertions can't be linked together (ODR violation).\nbuild:asserts --compilation_mode=opt '--copt=-UNDEBUG'\n</code></pre> <pre><code>build --disk_cache=c:/bazelcache\nbuild:debug --compilation_mode=dbg --copt=/O2 --per_file_copt=iree@/Od --strip=never\n</code></pre>"},{"location":"developers/building/bazel/#whats-next","title":"What's next?","text":""},{"location":"developers/building/bazel/#take-a-look-around","title":"Take a Look Around","text":"<p>Build all of IREE's 'tools' directory:</p> <pre><code>bazel build tools/...\n</code></pre> <p>Check out what was built:</p> <pre><code>ls bazel-bin/tools/\n./bazel-bin/tools/iree-compile --help\n</code></pre> <p>Translate a MLIR file and execute a function in the compiled module:</p> <pre><code># iree-run-mlir &lt;compiler flags&gt; [input.mlir] &lt;runtime flags&gt;\n$ ./bazel-bin/tools/iree-run-mlir \\\n--iree-hal-target-backends=vmvx --print-mlir \\\n./samples/models/simple_abs.mlir \\\n--input=f32=-2\n</code></pre>"},{"location":"developers/building/cmake-options/","title":"CMake options","text":""},{"location":"developers/building/cmake-options/#frequently-used-cmake-options","title":"Frequently-used CMake options","text":""},{"location":"developers/building/cmake-options/#cmake_build_type","title":"<code>CMAKE_BUILD_TYPE</code>","text":"<ul> <li>type: STRING</li> </ul> <p>Sets the build type. Possible values are <code>Release</code>, <code>Debug</code>, <code>RelWithDebInfo</code> and <code>MinSizeRel</code>. If unset, build type is set to <code>Release</code>.</p>"},{"location":"developers/building/cmake-options/#cmake_lang_compiler","title":"<code>CMAKE_&lt;LANG&gt;_COMPILER</code>","text":"<ul> <li>type: STRING</li> </ul> <p>This is the command that will be used as the <code>&lt;LANG&gt;</code> compiler, which are <code>C</code> and <code>CXX</code> in IREE. These variables are set to compile IREE with <code>clang</code> or rather <code>clang++</code>. Once set, these variables can not be changed.</p>"},{"location":"developers/building/cmake-options/#iree-specific-cmake-options","title":"IREE-specific CMake options","text":"<p>This gives a brief explanation of IREE specific CMake options and variables.</p>"},{"location":"developers/building/cmake-options/#iree_enable_runtime_tracing","title":"<code>IREE_ENABLE_RUNTIME_TRACING</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enables instrumented runtime tracing. Defaults to <code>OFF</code>.</p>"},{"location":"developers/building/cmake-options/#iree_enable_compiler_tracing","title":"<code>IREE_ENABLE_COMPILER_TRACING</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enables instrumented compiler tracing. This requires that <code>IREE_ENABLE_RUNTIME_TRACING</code> also be set. Defaults to <code>OFF</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_compiler","title":"<code>IREE_BUILD_COMPILER</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds the IREE compiler. Defaults to <code>ON</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_tests","title":"<code>IREE_BUILD_TESTS</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds IREE unit tests. Defaults to <code>ON</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_docs","title":"<code>IREE_BUILD_DOCS</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds IREE documentation files. Defaults to <code>OFF</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_samples","title":"<code>IREE_BUILD_SAMPLES</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds IREE sample projects. Defaults to <code>ON</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_python_bindings","title":"<code>IREE_BUILD_PYTHON_BINDINGS</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds the IREE python bindings. Defaults to <code>OFF</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_bindings_tflite","title":"<code>IREE_BUILD_BINDINGS_TFLITE</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds the IREE TFLite C API compatibility shim. Defaults to <code>ON</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_bindings_tflite_java","title":"<code>IREE_BUILD_BINDINGS_TFLITE_JAVA</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds the IREE TFLite Java bindings with the C API compatibility shim. Defaults to <code>ON</code>.</p>"},{"location":"developers/building/cmake-options/#iree_build_experimental_remoting","title":"<code>IREE_BUILD_EXPERIMENTAL_REMOTING</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Builds experimental remoting component. Defaults to <code>OFF</code>.</p>"},{"location":"developers/building/cmake-options/#iree_hal_driver_defaults","title":"<code>IREE_HAL_DRIVER_DEFAULTS</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Default setting for each <code>IREE_HAL_DRIVER_*</code> option.</p>"},{"location":"developers/building/cmake-options/#iree_hal_driver_","title":"<code>IREE_HAL_DRIVER_*</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Individual options enabling the build for each runtime HAL driver.</p>"},{"location":"developers/building/cmake-options/#iree_target_backend_defaults","title":"<code>IREE_TARGET_BACKEND_DEFAULTS</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Default setting for each <code>IREE_TARGET_BACKEND_*</code> option.</p>"},{"location":"developers/building/cmake-options/#iree_target_backend_","title":"<code>IREE_TARGET_BACKEND_*</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Individual options enabling the build for each compiler target backend.</p>"},{"location":"developers/building/cmake-options/#iree_input_","title":"<code>IREE_INPUT_*</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Individual options enabling each set of input dialects.</p>"},{"location":"developers/building/cmake-options/#iree_output_format_c","title":"<code>IREE_OUTPUT_FORMAT_C</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enables the vm-c compiler output format, using MLIR EmitC. Defaults to <code>ON</code>.</p>"},{"location":"developers/building/cmake-options/#iree_dev_mode","title":"<code>IREE_DEV_MODE</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Configure settings to optimize for IREE development (as opposed to CI or release). Defaults to <code>OFF</code>. For example, this will downgrade some compiler diagnostics from errors to warnings.</p>"},{"location":"developers/building/cmake-options/#iree_enable_lld","title":"<code>IREE_ENABLE_LLD</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Use lld when linking. Defaults to <code>OFF</code>. This option is equivalent to <code>-DIREE_USE_LINKER=lld</code>. The option <code>IREE_ENABLE_LLD</code> and <code>IREE_USE_LINKER</code> can not be set at the same time.</p>"},{"location":"developers/building/cmake-options/#iree_enable_asan","title":"<code>IREE_ENABLE_ASAN</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enable address sanitizer if the current build type is Debug and the compiler supports it.</p>"},{"location":"developers/building/cmake-options/#iree_enable_msan","title":"<code>IREE_ENABLE_MSAN</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enable memory sanitizer if the current build type is Debug and the compiler supports it.</p>"},{"location":"developers/building/cmake-options/#iree_enable_tsan","title":"<code>IREE_ENABLE_TSAN</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enable thread sanitizer if the current build type is Debug and the compiler supports it.</p>"},{"location":"developers/building/cmake-options/#iree_enable_ubsan","title":"<code>IREE_ENABLE_UBSAN</code>","text":"<ul> <li>type: BOOL</li> </ul> <p>Enable undefiend behavior sanitizer if the current build type is Debug and the compiler supports it.</p>"},{"location":"developers/building/cmake-options/#cross-compilation","title":"Cross-compilation","text":"<p>When cross compiling (using a toolchain file like <code>android.toolchain.cmake</code>), first build and install IREE's tools for your host configuration, then use the <code>IREE_HOST_BIN_DIR</code> CMake option to point the cross compiled build at the host tools.</p>"},{"location":"developers/building/cmake-with-ccache/","title":"CMake with <code>ccache</code>","text":"<p><code>ccache</code> is a compilation cache. In principle, just prepending compiler invocations with <code>ccache</code> is all one needs to enable it, e.g.</p> <pre><code>ccache clang foo.c -c -o foo.o\n</code></pre> <p>takes care of executing <code>clang</code> with these arguments and caches the output file <code>foo.o</code>. The next invocation then skips executing <code>clang</code> altogether.</p> <p>When the cache is hit, the speedup is such that the \"compilation\" becomes essentially free. However, <code>ccache</code> only caches compilation, not linking.</p> <p>Here a few scenarios where <code>ccache</code> helps:</p> <ul> <li>Incremental rebuilds. While <code>cmake</code> always tries to avoid unnecessary work in   incremental rebuilds, it can only make simple decisions based on file   timestamps. <code>ccache</code> sees deeper: if the raw source code isn't readily   a cache hit, it will then try again after preprocessing and discarding   comments.</li> <li>One pain point with <code>cmake</code> is having to start over from a clean build   directory from time to time, which by default means paying again the full cost   of a cold build. Thankfully <code>ccache</code> keeps its cache outside of any <code>cmake</code>   build directory, so the first build in the new clean build directory may be   very fast.</li> </ul>"},{"location":"developers/building/cmake-with-ccache/#installing-and-setting-up-ccache","title":"Installing and setting up <code>ccache</code>","text":"<p><code>ccache</code> is available on most platforms. On Debian-based Linux distributions, do:</p> <pre><code>sudo apt install ccache\n</code></pre> <p>The one <code>ccache</code> setting that you probably need to configure is the maximum cache size. The default <code>5G</code> is too small for our purposes. To set the cache max size, do this once:</p> <pre><code>ccache --max-size=20G\n</code></pre> <p>Tip: At the moment (late 2020), most of the code we're building is <code>third_party/llvm-project</code> so the fundamental limiting factor to how far we can cache away rebuilds is how often that dependency gets updated. Given how frequently it currently is updated, I'm finding that <code>20G</code> is enough to make the <code>ccache</code> size not be the limiting factor.</p>"},{"location":"developers/building/cmake-with-ccache/#telling-cmake-to-use-ccache","title":"Telling CMake to use <code>ccache</code>","text":"<p>Use the CMake COMPILER_LAUNCHER functionality by setting <code>CMAKE_C_COMPILER_LAUNCHER=ccache</code> and <code>CMAKE_CXX_COMPILER_LAUNCHER=ccache</code> in your</p> <p>Notes:</p> <ul> <li>This approach only works with the <code>Ninja</code> and <code>Makefile</code> generators   (<code>cmake -G</code> flag). When using other generators, another approach is needed,   based on wrapping the compiler in a script that prepends <code>ccache</code>. See this   article.</li> </ul>"},{"location":"developers/building/cmake-with-ccache/#ensuring-that-ccache-is-used-and-monitoring-cache-hits","title":"Ensuring that <code>ccache</code> is used and monitoring cache hits","text":"<p>The <code>ccache -s</code> command dumps statistics, including a cache hit count and ratio. It's convenient to run periodically with <code>watch</code> in a separate terminal:</p> <pre><code>watch -n 0.1 ccache -s  # update the stats readout every 0.1 seconds\n</code></pre>"},{"location":"developers/building/emscripten/","title":"Building with Emscripten","text":"<p>Emscripten is a complete compiler toolchain to WebAssembly, using LLVM, with a special focus on speed, size, and the Web platform. Emscripten can be used to compile parts of IREE to WebAssembly for execution within web browsers or other Wasm runtimes.</p>","tags":["Web"]},{"location":"developers/building/emscripten/#status","title":"Status","text":"<p>IREE's runtime can be compiled through Emscripten in some limited configurations. More of the runtime will be supported over time.</p> <p>IREE's compiler can be compiled through Emscripten with local changes. More work is needed for this to be generally supported.</p>","tags":["Web"]},{"location":"developers/building/emscripten/#prerequisites","title":"Prerequisites","text":"<p>Read https://emscripten.org/docs/getting_started/downloads.html and run</p> <pre><code>./emsdk install latest\n./emsdk activate latest\nsource ./emsdk_env.sh\n</code></pre>","tags":["Web"]},{"location":"developers/building/emscripten/#building-irees-runtime-with-emscripten","title":"Building IREE's runtime with Emscripten","text":"","tags":["Web"]},{"location":"developers/building/emscripten/#host-configuration","title":"Host configuration","text":"<p>Build and install at least the compiler tools on your host machine, or install them from a binary distribution:</p> <pre><code>$ cmake -G Ninja -B ../iree-build-host/ \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DCMAKE_INSTALL_PREFIX=../iree-build-host/install \\\n.\n$ cmake --build ../iree-build-host/ --target install\n</code></pre>","tags":["Web"]},{"location":"developers/building/emscripten/#target-configuration","title":"Target configuration","text":"<pre><code>$ emcmake cmake -G Ninja -B ../iree-build-emscripten/ \\\n-DCMake_BUILD_TYPE=Release \\\n-DIREE_HOST_BIN_DIR=$(realpath ../iree-build-host/install/bin) \\\n-DIREE_BUILD_TESTS=OFF \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\n</code></pre> <p>Build:</p> <pre><code>cmake --build ../iree-build-emscripten/ \\\n--target iree_samples_simple_embedding_simple_embedding_vmvx_sync\n</code></pre>","tags":["Web"]},{"location":"developers/building/emscripten/#load-into-a-webassembly-environment","title":"Load into a WebAssembly environment","text":"<p>Copy the outputs from the build process (e.g. <code>simple_embedding_vmvx_sync.js</code> and <code>simple_embedding_vmvx_sync.wasm</code>) into your application and follow instructions at either https://webassembly.org/getting-started/developers-guide/ or https://developer.mozilla.org/en-US/docs/WebAssembly/Loading_and_running.</p>","tags":["Web"]},{"location":"developers/debugging/android-with-lldb/","title":"Android LLDB debugging","text":"<p>This doc shows how to use LLDB to debug native binaries on Android. For a more complete explanation, see the official LLDB documentation on remote debugging.</p>","tags":["Android"]},{"location":"developers/debugging/android-with-lldb/#prerequisites","title":"Prerequisites","text":"<p>We assume the following setup:</p> <ol> <li>Android NDK is installed and    the <code>ANDROID_NDK</code> environment variable is set to the installation path.</li> <li>Your Android device connected and configured for    <code>adb</code>.</li> <li>The Android binary of interest is already compiled and the command to run it    (in <code>adb shell</code>) is <code>&lt;your-binary&gt; [program args...]</code>. This does not have    to be a proper Android app with a manifest, etc.</li> </ol>","tags":["Android"]},{"location":"developers/debugging/android-with-lldb/#running-manually","title":"Running Manually","text":"<ol> <li> <p>Push the toolchain files, including <code>lldb-server</code>, to your device:</p> <pre><code>adb shell \"mkdir -p /data/local/tmp/tools\"\nadb push \"$ANDROID_NDK\"/toolchains/llvm/prebuilt/linux-x86_64/lib64/clang/14.0.6/lib/linux/aarch64/* /data/local/tmp/tools\n</code></pre> <p>You may need to adjust the clang toolchain version to match the one in your NDK. You can find it with <code>find \"$ANDROID_NDK/toolchains/llvm/prebuilt\" -name lldb-server</code>.</p> </li> <li> <p>Set up port forwarding. We are going to use port 5039 but you are free to    pick a different one:</p> <pre><code>adb forward tcp:5039 tcp:5039\n</code></pre> </li> <li> <p>Start an <code>lldb-server</code> in a new interactive adb shell:</p> <pre><code>adb shell\n/data/local/tmp/tools/lldb-server platform --listen '*:5039' --server\n</code></pre> </li> <li> <p>Launch <code>lldb</code>, connect to the server and run the binary:</p> <pre><code>lldb -o 'platform select remote-android' \\\n-o 'platform connect connect://:5039' \\\n-o 'platform shell cd /data/local/tmp'\ntarget create &lt;your-binary&gt;\nrun [program args...]\n</code></pre> <p>You can either use the system <code>lldb</code> or a prebuilt under <code>\"$ANDROID_NDK\"/toolchains/llvm/prebuilt/linux-x86_64/lib64/clang/14.0.6/lib/linux/&lt;your-host-arch&gt;</code>.</p> <p>Explanation: each <code>-o</code> (short for <code>--one-shot</code>) tells lldb to execute a command on startup. You can run those manually in the lldb shell, if you prefer. Then, we tell lldb which working directory to use, where to find the executable, and what command line arguments to use.</p> </li> </ol>","tags":["Android"]},{"location":"developers/debugging/compile-time-regressions/","title":"Compile time regression debugging","text":"<p>So the IREE compiler used to compile a program quickly, but it is now slower. What do you do?</p>"},{"location":"developers/debugging/compile-time-regressions/#initial-information-gathering","title":"Initial information gathering","text":"<p>Try to answer as many of these questions as you can:</p> <p>When did compilation get slower?</p> <p>A specific git commit is ideal, but \"sometime in the last week\" is a good   starting point. You'll ultimately want to find a culprit release or git   commit that changed the compiler code.</p> <p>How much slower did compilation get?</p> <p>Be specific - did it jump from 1 minute to 2 minutes, or 1 minute to 1 hour?   Identifying the scale of the regression can help set the priority to   investigate it.</p> <p>What is the full compile command?</p> <p>Try to extract the input program and full list of flags passed to the   compiler binary so that others can reproduce what you're seeing. Try to   distill this as much as possible to using just native tools (no Python or   other framework layers).</p> <p>What environment is the compiler running in?</p> <p>Are you using a <code>Debug</code> build, or a release build? What operating system and   size machine is running the compiler (e.g. Linux developer machine, or a   smaller system)?</p>"},{"location":"developers/debugging/compile-time-regressions/#culprit-finding-and-bisecting","title":"Culprit finding and bisecting","text":"<p>If you only have a rough idea of when something changed and want to narrow that down to a specific code change, bisecting can help.</p>"},{"location":"developers/debugging/compile-time-regressions/#running-git-bisect","title":"Running <code>git bisect</code>","text":"<p>Building the compiler from source and using <code>git bisect</code> will let you pinpoint specific commits in IREE, though it typically won't let you step through changes in submodules (e.g. MLIR updates in <code>third_party/llvm-project/</code>).</p> <p>Tip: Configure ccache if you'll be rebuilding the compiler while bisecting</p> <p>A manual workflow with <code>git bisect</code> looks like this:</p> <pre><code>git bisect start --first-parent\ngit bisect good [&lt;rev&gt;]\ngit bisect bad [&lt;rev&gt;]\n\n# Read the prompts from the command as it runs\n# At each step, test the compiler:\n#   git submodule update\n#   cmake --build build/ --target iree-compile\n#   ./build/tools/iree-compile &lt;args&gt;\n#       attach Tracy, observe timing, print IR, etc. to determine if fast or slow\n#       if fast, `git bisect good`\n#       if slow, `git bisect bad`\n#   repeat\n</code></pre> <p>An automated workflow can use <code>git bisect run</code> and a script:</p> <pre><code># run_bisect.sh\ngit submodule update\ncmake --build build/ --target iree-compile\n# Other logic here\n</code></pre> <pre><code>git bisect start --first-parent\ngit bisect good [&lt;rev&gt;]\ngit bisect bad [&lt;rev&gt;]\ngit bisect run run_bisect.sh\n</code></pre>"},{"location":"developers/debugging/compile-time-regressions/#sample-compile-executable-sources-individually-with-a-timeout","title":"Sample: compile executable sources individually with a timeout","text":"<pre><code>#!/bin/bash\n\nset -xeuo pipefail\n\n# --------------------------------------------------------------------------- #\n# Settings                                                                    #\n# --------------------------------------------------------------------------- #\n\nINPUT_FILE_PATH=\"/path/to/program.mlirbc\"\nTMP_DIR=\"../iree-tmp\"\n\ndeclare -a COMPILER_FLAGS=(\n\"--iree-input-type=stablehlo\"\n\"--iree-hal-target-backends=cuda\"\n\"--iree-hal-cuda-llvm-target-arch=sm_80\"\n)\n\nTIMEOUT_SECONDS_FOR_COMPILING_EACH_SOURCE=10\n\n# --------------------------------------------------------------------------- #\n# Utility functions                                                           #\n# --------------------------------------------------------------------------- #\n\n# Call to have `git bisect` skip this commit (don't mark as good _or_ bad)\n# https://git-scm.com/docs/git-bisect#_bisect_run\nskip_on_error() {\n&gt;&amp;2 echo \"** Skipping due to error: $1 **\"\nexit 125  # Special exit code for `git bisect skip`\n}\n\n# --------------------------------------------------------------------------- #\n# Main script                                                                 #\n# --------------------------------------------------------------------------- #\n\n# Store git version hash, so we can dump artifacts to unique directories later.\nGIT_SHA=\"$(git rev-parse --short HEAD)\"\n\necho \"** Building iree-compile at ${GIT_SHA} **\"\n\n# The `git bisect` command only checks out a commit, so update submodules.\ngit submodule update\n\n# Build the compiler. You'll want ccache configured to make this fast!\ncmake --build ../iree-build/ --target iree-compile || skip_on_error \"CMake build failed\"\n\n# Run the compiler, dumping executable sources and stopping.\nSOURCES_DIR=\"${TMP_DIR}/sources-${GIT_SHA}\"\necho \"** Running iree-compile at ${GIT_SHA}, dumping sources to ${SOURCES_DIR} **\"\n../iree-build/tools/iree-compile \\\n${INPUT_FILE_PATH} \\\n${COMPILER_FLAGS[@]} \\\n--iree-hal-dump-executable-sources-to=${SOURCES_DIR} \\\n--compile-to=executable-sources \\\n-o /dev/null\n\n# Run the compiler again on each executable individually.\necho \"** Running iree-compile at ${GIT_SHA} for each executable source **\"\nSOURCES=($(ls -1 ${SOURCES_DIR}))\nfor SOURCE in \"${SOURCES[@]}\"; do\necho \"  * Compiling: ${SOURCE} *\"\ntimeout --verbose ${TIMEOUT_SECONDS_FOR_COMPILING_EACH_SOURCE} \\\n../iree-build/tools/iree-compile ${SOURCES_DIR}/${SOURCE} \\\n${COMPILER_FLAGS[@]} \\\n--compile-mode=hal-executable \\\n-o /dev/null\ndone\n</code></pre>"},{"location":"developers/debugging/compile-time-regressions/#profiling-and-tracing","title":"Profiling and tracing","text":"<p>If you want to understand why the compiler is fast or slow, or if you want to compare performance in detail between two versions, consider these profiling options.</p>"},{"location":"developers/debugging/compile-time-regressions/#mlir-pass-timing","title":"MLIR pass timing","text":"<p>The <code>-mlir-timing</code> flag enables Pass Timing instrumentation. Once the compiler finishes running, this prints a report like</p> <pre><code>===-------------------------------------------------------------------------===\n... Pass execution timing report ...\n===-------------------------------------------------------------------------===\nTotal Execution Time: 0.0203 seconds\n\n   ---Wall Time---  --- Name ---\n   0.0047 ( 55.9%)  Canonicalizer\n   0.0019 ( 22.2%)  VerifierPass\n   0.0016 ( 18.5%)  LLVMLoweringPass\n   0.0003 (  3.4%)  CSE\n   0.0002 (  1.9%)  (A) DominanceInfo\n   0.0084 (100.0%)  Total\n</code></pre> <p>This is easy data to collect, especially remotely over SSH, but it might not paint a complete picture and requires waiting for compilation to finish.</p>"},{"location":"developers/debugging/compile-time-regressions/#using-tracy","title":"Using Tracy","text":"<p>See our documentation on profiling with Tracy. For compile time regressions, pay particular attention to the different compilation phases (Flow/Stream/HAL), how many times <code>TranslateExecutablesPass</code> runs, and if there are outlier passes that take significantly longer to run than others.</p> <p>Here are some previous analyses for inspiration:</p> <ul> <li>https://github.com/openxla/iree/issues/12033</li> <li>https://github.com/openxla/iree/issues/12035</li> <li>https://github.com/openxla/iree/issues/12183</li> <li>https://github.com/openxla/iree/issues/13189</li> </ul> <p>Example slow trace:</p> <p></p> <p>Example fast trace:</p> <p></p> <p>Example sampling statistics showing 10s of minutes in LLVM codegen:</p> <p></p>"},{"location":"developers/debugging/compile-time-regressions/#stepping-through-compiler-ir","title":"Stepping through compiler IR","text":"<p>Debugging an MLIR-based compiler like IREE usually involves reading IR at some point. For compile time regressions, it helps to snapshot the IR at a few key phases and look for differences between fast compilation and slow compilation.</p> <p>Here is one useful flag combination:</p> <pre><code>--mlir-disable-threading \\\n--mlir-elide-elementsattrs-if-larger=8 \\\n--mlir-print-ir-after=iree-hal-materialize-interfaces\n</code></pre>"},{"location":"developers/debugging/integration-tests/","title":"Integration test debugging","text":"<p>This document includes tips for triaging integration test correctness issues. Feel free to reach out to @hanhanW or ask questions on Discord for more help.</p>"},{"location":"developers/debugging/integration-tests/#general-tips","title":"General tips","text":""},{"location":"developers/debugging/integration-tests/#narrow-down-reproducers","title":"Narrow down reproducers","text":"<ul> <li>Models themselves can be large, and IREE breaks models into dispatches/kernels and then launches those individually. Program outputs could diverge starting from any individual launch. To get a smaller reproducer, you can use --iree-flow-trace-dispatch-tensors.</li> <li>You can compare the logs between builds/backends to get an idea about which dispatch results in wrong outputs. The dumped inputs can be reused in a flagfile.</li> </ul> <p>Once a suspicious dispatch is identified, we can create a test case based on the dispatch function. The dispatch function can be derived after the <code>OutlineDispatchRegions</code> pass. The function signatures have to be modified manually. You'll have to put <code>flow.dispatch.tensor.load</code> variables to function arguments, and replace <code>flow.dispatch.tensor.store</code> with <code>return</code> op.</p> <p>Note: This only works when dispatch formation logics are identical between runs.</p>"},{"location":"developers/debugging/integration-tests/#iree-samples-repository-tests","title":"iree-samples repository tests","text":"<p>Follow README to run the model. The MLIR files will be generated. You'll find the saved file from log. E.g.,</p> <pre><code>[ RUN      ] MobilenetV2Int8Test.test_compile_tflite\nI0401 17:27:04.084272 140182373025024 test_util.py:119] Setting up for IREE\nI0401 17:27:04.085064 140182373025024 binaries.py:218] Invoke IREE Pipeline:\n  /tmp/iree-samples/iree-samples.venv/lib/python3.9/site-packages/iree/tools/tflite/iree-import-tflite\n    /tmp/iree-samples/tflitehub/tmp/mobilenet_v2_int8_test.py/model.tflite\n    --mlir-print-debuginfo\n    --save-temp-tfl-input=/tmp/iree-samples/tflitehub/tmp/mobilenet_v2_int8_test.py/tflite.mlir\n    --save-temp-iree-input=/tmp/iree-samples/tflitehub/tmp/mobilenet_v2_int8_test.py/tosa.mlir\n</code></pre> <p>Unfortunately, the artifacts are not dumped in the runs. There is an issue for tracking this. A workaround can be found in the issue.</p>"},{"location":"developers/debugging/integration-tests/#tensorflow-integration-tests","title":"TensorFlow integration tests","text":"<p>These are steps to reproduce/address failures in TF/TFLite integration tests. These instructions are most stable on Linux, though they may work with a few tweaks on Windows and macOS.</p> <p>All steps here assume starting from the IREE root directory.</p> <ol> <li> <p>First create a Python virtual environment to install packages into:</p> <pre><code>python -m venv iree-tf.venv\nsource iree-tf.venv/bin/activate\n\n# Install test requirements\npython -m pip install -r ./integrations/tensorflow/test/requirements.txt\n</code></pre> </li> <li> <p>Install IREE's tools and Python bindings or build them from source</p> <p>Install distributed packages</p> <pre><code># Install packages from nightly releases\n# This should work for most cases, as the importers change infrequently\npython -m pip install \\\niree-compiler iree-runtime iree-tools-tf iree-tools-tflite \\\n--find-links https://iree.dev/pip-release-links.html\n</code></pre> <p>OR build from source</p> <pre><code># Build Python bindings from source\ncmake -G Ninja -B ../iree-build/ -DIREE_BUILD_PYTHON_BINDINGS=ON .\ncmake --build ../iree-build/\n\n# Add IREE built-from-source Python packages to PYTHONPATH\nsource .env\n\n# Install IREE TF/TFLite Python packages\npython -m pip install integrations/tensorflow/python_projects/iree_tf\npython -m pip install integrations/tensorflow/python_projects/iree_tflite\n</code></pre> </li> <li> <p>Run the python test command line</p> <p>The command can be obtained from the run file. For example, if <code>iree_tfl_tests/llvmcpu_posenet_i8.run</code> failed,</p> <pre><code>cd integrations/tensorflow/test/\ncat iree_tfl_tests/llvmcpu_posenet_i8.run\n\n# REQUIRES: llvmcpu\n# RUN: %PYTHON -m iree_tfl_tests.posenet_i8_test --target_backend=llvmcpu --artifacts_dir=%t\n\ncd python/\npython -m iree_tfl_tests.posenet_i8_test --target_backend=llvmcpu --artifacts_dir=/tmp/posenet_i8_failure\n</code></pre> <p>Note that the command can only be run under <code>integrations/tensorflow/test/python</code> directory.</p> </li> <li> <p>Extract intermediate files and use with native tools</p> <p>The test will create an <code>iree_input.mlir</code> in the temp directory specified. Those can then be fed into <code>iree-compile</code> (built locally to reproduce the error)</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-input-type=stablehlo \\\niree_input.mlir\n</code></pre> </li> </ol>"},{"location":"developers/debugging/releases/","title":"Release debugging playbook","text":""},{"location":"developers/debugging/releases/#tools-and-locations","title":"Tools and Locations","text":"<ul> <li><code>.github/workflows/build_package.yml</code>: Release packaging jobs</li> <li><code>build_tools/github_actions/build_dist.py</code>: Main script to build various   release packages (for all platforms). We usually use this when reproing to   approximate exactly what the CI does. Assumes a subdirectory of <code>c</code>   and writes builds to <code>iree-build</code> and <code>iree-install</code> as a peer of it. To use   locally, just symlink your source dir as <code>c</code> in an empty   directory (versus checking out).</li> </ul>"},{"location":"developers/debugging/releases/#mapping-releases-back-to-git-commits","title":"Mapping releases back to git commits","text":"<p>The source IREE commit SHA is embeded into pip releases in a few places. Starting in a python venv, you can find the IREE commit from both the shell:</p> <pre><code>\"$(find . -name 'iree-compile' -executable)\" --version\nIREE (https://iree.dev):\n  IREE compiler version 20231016.553 @ f1cb2692a086738d7f16274b9b3af6d2c15ef133\n  LLVM version 18.0.0git\n  Optimized build\n</code></pre> <p>and the Python API:</p> <pre><code>python -c \"import iree.compiler.version as v; print(v.REVISIONS['IREE'])\"\nf1cb2692a086738d7f16274b9b3af6d2c15ef133\n</code></pre>"},{"location":"developers/debugging/releases/#manylinux-releases","title":"Manylinux releases","text":"<p>The Linux releases are done in a manylinux2014 docker container. At the time of this writing, it has gcc 9.3.1 and Python versions 3.5 - 3.9 under <code>/opt/python</code>. Note that this docker image approximates a 2014 era RHEL distro, patched with backported (newer) dev packages. It builds with gcc and BFD linker unless if you arrange otherwise. <code>yum</code> can be used to get some packages.</p> <p>Get a docker shell (see exact docker image in build_package.yml workflow):</p> <pre><code>docker run --rm -it -v $(pwd):/work/c stellaraccident/manylinux2014_x86_64-bazel-4.2.2:latest /bin/bash\n</code></pre> <p>Remember that docker runs as root unless if you take steps otherwise. Don't touch write files in the <code>/work/c</code> directory to avoid scattering root owned files on your workstation.</p> <p>The default system Python is 2.x, so you must select one of the more modern ones:</p> <pre><code>export PATH=/opt/python/cp39-cp39/bin:$PATH\n</code></pre> <p>Build core installation:</p> <pre><code># (from within docker)\ncd /work\npython ./c/build_tools/github_actions/build_dist.py main-dist\n\n# Also supports:\n#   main-dist\n#   py-runtime-pkg\n#   py-xla-compiler-tools-pkg\n#   py-tflite-compiler-tools-pkg\n#   py-tf-compiler-tools-pkg\n</code></pre> <p>You can <code>git bisect</code> on the host and keep running the above in the docker container. Note that every time you run <code>build_dist.py</code>, it deletes the cmake cache but otherwise leaves the build directory (so it pays the configure cost but is otherwise incremental). You can just <code>cd iree-build</code> and run <code>ninja</code> for faster iteration (after the first build or if changing cmake flags). Example:</p> <p>Extended debugging in the manylinux container:</p> <pre><code>cd /work/iree-build\n# If doing extended debugging in the container, these may make you happier.\nyum install ccache devtoolset-9-libasan-devel gdb\n\n# Get an LLVM symbolizer.\nyum install llvm9.0\nln -s /usr/bin/llvm-symbolizer-9.0 /usr/bin/llvm-symbolizer\n\n# You can manipulate cmake flags. These may get you a better debug experience.\ncmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DIREE_ENABLE_ASAN=ON -DCMAKE_EXE_LINKER_FLAGS=-fuse-ld=gold -DCMAKE_C_COMPILER_LAUNCHER=ccache -DCMAKE_CXX_COMPILER_LAUNCHER=ccache .\n\nninja\n\n# Or you may need this if buggy LLVM tools (like mlir-tblgen) are leaking :(\nASAN_OPTIONS=\"detect_leaks=0\" ninja\n</code></pre> <p>Other tips:</p> <ul> <li>If debugging the runtime, you may have a better time just building the   Release mode <code>main-dist</code> package above once, which will drop binaries in the   <code>iree-install</code> directory. Then build the <code>py-runtime-pkg</code> or equiv and   iterate further in the build directory. Ditto for TF/XLA/etc.</li> </ul>"},{"location":"developers/debugging/releases/#testing-releases-on-your-fork","title":"Testing releases on your fork","text":"<p>To avoid interrupting the regular releases published on the IREE github, you can test any changes to the release process on your own fork.  Some setup is required before these github actions will work on your fork and development branch.</p> <p>You can run <code>schedule_candidate_release.yml</code> with a workflow dispatch from the actions tab. If you want to test using a commit other than the latest green on your <code>main</code> branch, modify the section that identifies the latest green commit to search from another commit or just hardcode one.</p> <p>To speed up <code>build_package.yml</code>, you may want to comment out some of the builds here. The <code>py-pure-pkgs</code> build takes only ~2 minutes and the <code>py-runtime-pkg</code> build takes ~5, while the others can take several hours.</p> <p>From your development branch, you can manually run the Schedule Snapshot Release action, which invokes the Build Release Packages action, which finally invokes the Validate and Publish Release action.  If you already have a draft release and know the release id, package version, and run ID from a previous Build Release Packages run, you can also manually run just the Validate and Publish Release action.</p>"},{"location":"developers/debugging/sanitizers/","title":"Sanitizers (ASan/MSan/TSan)","text":"<p>AddressSanitizer, MemorySanitizer and ThreadSanitizer are tools provided by <code>clang</code> to detect certain classes of errors in C/C++ programs. They consist of compiler instrumentation (so your program's executable code is modified) and runtime libraries (so e.g. the <code>malloc</code> function may get replaced).</p> <p>They are abbreviated as \"ASan\", \"MSan\" and \"TSan\" respectively.</p> <p>They all incur large overhead, so only enable them while debugging.</p> Tool Detects Helps debug what? Slowdown Memory overhead Android support ASan Out-of-bounds accesses, use-after-free, use-after-return, memory leaks Crashes, non-deterministic results, memory leaks 2x 3x Yes MSan Uninitialized memory reads Non-deterministic results 3x ? Yes TSan Data races Many bugs in multi-thread code 5x-15x 5x-10x No <p>Note</p> <p>See this documentation on leak detection. It is only enabled by default on some platforms.</p>"},{"location":"developers/debugging/sanitizers/#support-status-and-how-to-enable-each-sanitizer","title":"Support status and how to enable each sanitizer","text":""},{"location":"developers/debugging/sanitizers/#asan-addresssanitizer","title":"ASan (AddressSanitizer)","text":"<p>Enabling ASan in the IREE build is a simple matter of setting the <code>IREE_ENABLE_ASAN</code> CMake option:</p> <pre><code>cmake -DIREE_ENABLE_ASAN=ON ...\n</code></pre>"},{"location":"developers/debugging/sanitizers/#tsan-threadsanitizer","title":"TSan (ThreadSanitizer)","text":"<p>To enable TSan, at the moment, the following 3 CMake options must be set:</p> <pre><code>cmake \\\n-DIREE_ENABLE_TSAN=ON \\\n-DIREE_BYTECODE_MODULE_ENABLE_TSAN=ON \\\n-DIREE_BYTECODE_MODULE_FORCE_LLVM_SYSTEM_LINKER=ON \\\n-DIREE_BUILD_SAMPLES=OFF \\\n...\n</code></pre> <p>In practice, <code>IREE_ENABLE_TSAN</code> alone would be enough for many targets, but not all. The problem is that a IREE runtime built with <code>IREE_ENABLE_TSAN</code> cannot load a IREE compiled LLVM/CPU module unless the following flags were passed to the IREE compiler: <code>--iree-llvmcpu-sanitize=thread</code> and <code>--iree-llvmcpu-link-embedded=false</code>.</p> <p>The CMake options <code>IREE_BYTECODE_MODULE_ENABLE_TSAN</code> and <code>IREE_BYTECODE_MODULE_FORCE_LLVM_SYSTEM_LINKER</code> ensure that the above flags are passed to the IREE compiler when building modules used in tests, benchmarks, etc. (anything that internally uses the CMake <code>iree_bytecode_module</code> macro).</p> <p>The CMake option <code>IREE_BUILD_SAMPLES=OFF</code> is needed because samples currently assume that the embedded linker is used, so they are incompatible with <code>IREE_BYTECODE_MODULE_FORCE_LLVM_SYSTEM_LINKER=ON</code>.</p> <p>At the moment, CMake logic heavy-handedly enforces that whenever <code>IREE_ENABLE_TSAN</code> is set, these other two CMake variables are also set. That ensures that all tests succeed: no test is expected to fail with TSan.</p> <p>If you know what you're doing (i.e. if you are not building targets that internally involve a LLVM/CPU <code>iree_bytecode_module</code>), feel free to locally comment out the CMake error and only set <code>IREE_ENABLE_TSAN</code>. Also see a past attempt to relax that CMake validation.</p>"},{"location":"developers/debugging/sanitizers/#msan-memorysanitizer","title":"MSan (MemorySanitizer)","text":"<p>In theory that should be a simple matter of</p> <pre><code>-DIREE_ENABLE_MSAN=ON\n</code></pre> <p>However, that requires making and using a custom build of libc++ with MSan as explained in this documentation.</p> <p>As of April 2022, all of IREE's tests succeeded with MSan on Linux/x86-64, provided that the <code>vulkan</code> driver was disabled (due to lack of MSan instrumentation in the NVIDIA Vulkan driver).</p>"},{"location":"developers/debugging/sanitizers/#ubsan-undefinedbehaviorsanitizer","title":"UBSan (UndefinedBehaviorSanitizer)","text":"<p>Enabling UBSan in the IREE build is a simple matter of setting the <code>IREE_ENABLE_UBSAN</code> CMake option:</p> <pre><code>cmake -DIREE_ENABLE_UBSAN=ON ...\n</code></pre> <p>Note that both ASan and UBSan can be enabled in the same build.</p>"},{"location":"developers/debugging/sanitizers/#symbolizing-the-reports","title":"Symbolizing the reports","text":""},{"location":"developers/debugging/sanitizers/#desktop-platforms","title":"Desktop platforms","text":"<p>On desktop platforms, getting nicely symbolized reports is covered in this documentation. The gist of it is make sure that <code>llvm-symbolizer</code> is in your <code>PATH</code>, or make the <code>ASAN_SYMBOLIZER_PATH</code> environment variable point to it.</p>"},{"location":"developers/debugging/sanitizers/#android","title":"Android","text":"<p>On Android it's more complicated due to this Android NDK issue. Fortunately, we have a script to perform the symbolization. Copy the raw output from the sanitizer and feed it into the <code>stdin</code> of the <code>build_tools/scripts/android_symbolize.sh</code> script, with the <code>ANDROID_NDK</code> environment variable pointing to the NDK root directory, like this:</p> <pre><code>ANDROID_NDK=~/android-ndk-r21d ./build_tools/scripts/android_symbolize.sh &lt; /tmp/asan.txt\n</code></pre> <p>Where <code>/tmp/asan.txt</code> is where you've pasted the raw sanitizer report.</p> <p>Tip</p> <p>This script will happily just echo any line that isn't a stack frame. That means you can feed it the whole <code>ASan</code> report at once, and it will output a symbolized version of it. DO NOT run it on a single stack at a time! That is unlike the symbolizer tool that's being added in NDK r22, and one of the reasons why we prefer to keep our own script. For more details see this comment.</p>"},{"location":"developers/design-docs/cuda-backend/","title":"CUDA backend design","text":"<p>Authored March, 2021</p> <p>This document is intended to provide an overview of the design choices made to support CUDA within IREE. It describes both the HAL runtime and the NVVM codegen side.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#cuda-hal-driver","title":"CUDA HAL Driver","text":"<p>The CUDA HAL driver is in <code>iree/hal/drivers/cuda/</code> directory. It is written in C following the standards of the rest of the HAL module.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#cuda-library-dependency","title":"CUDA library dependency","text":"<p>IREE calls directly into <code>CUDA driver API</code>. CUDA library is loaded dynamically and cuda.h header from CUDA SDK is part of IREE third_party project. Therefore IREE doesn't require CUDA SDK to be installed when building iree tools.</p> <p>At runtime HAL CUDA driver will load libcuda.so/nvcuda.dll library and load a subset of the cuda driver API used in HAL. The list of functions being used are in the file <code>iree/hal/drivers/cuda/dynamic_symbols_tables.h</code></p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#driver","title":"Driver","text":"<p>There is no direct equivalent in CUDA to the HAL driver abstraction. We use it to hold the symbols loaded for all the devices.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#device","title":"Device","text":"<p>The equivalent to HAL device in CUDA is the <code>CUcontext</code>, it holds all the state related to memory allocations.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#command-buffer","title":"Command buffer","text":"<p>We implement command buffers using <code>CUDA Graph API</code>. Using the Graph API allows to easily encode fine grain dependencies between dispatch without having to create multiple streams.</p> <p>Note that Graph API is meant to be used for command buffers that can be recorded once and used several times and there may be a performance penalty to using Graph API for direct command buffer. It is likely that we will also have a pure stream implementation in the future if we see performance problems with direct command buffer usages.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#event-and-barrier","title":"Event and Barrier","text":"<p>In HAL Event and Barrier are used for GPU&lt;-&gt;GPU synchronization either within a command buffer (Event and Barrier) or between command buffers.</p> <p>The current implementation ignores events and barriers and serializes all the nodes of the graph in order to have a conservative but correct solution.</p> <p>The design we plan for the future is to map dependencies within a command buffer to graph dependencies in the CUDA Graph API. When an event is signaled all the leaf nodes of the graph will be saved in HAL data structure and when the same command buffer waits on the signal we will add all the nodes as dependency to the future nodes added to the graph.</p> <p>For simplicity we always serialize command buffers sent to the same command queue.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#allocator","title":"Allocator","text":"<p>The allocator will forward allocation requests to <code>cuMemHostAlloc</code> for host accessible memory and <code>cuMemAlloc</code> for device only memory.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#buffer","title":"Buffer","text":"<p>CUDA buffers are represented either as a host pointer or a device pointer of type <code>CUdeviceptr</code>.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#executable","title":"Executable","text":"<p>HAL executable maps naturally to a PTX module. The compiler will generate a flat buffer containing a PTX text module as well as a list of entry point function names and the workgroup size associated with those entry points.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#semaphore","title":"Semaphore","text":"<p>Timeline semaphore is used in IREE to handle coarse grain synchronization for CPU&lt;-&gt;GPU, GPU&lt;-&gt;GPU and CPU&lt;-&gt;CPU. The interface follows closely <code>Vulkan timeline semaphore spec</code>.</p> <p>There is currently no simple way to implement this on CUDA. There are several solutions discussed on this <code>IREE issue</code> but no obvious solution. For now we force CPU and GPU to be synchronized after every submit to ensure correctness and ignore the semaphore.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#nvvm-codegen","title":"NVVM Codegen","text":"","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#nvvm-and-ptx","title":"NVVM and PTX","text":"<p>NVVM is a CUDA specific IR composed of LLVM IR and NVVM specific intrinsics. It can be compiled to PTX text using LLVM PTX backend. NVVM has an associated dialect in MLIR that translates 1:1 to NVVM intrinsics. This is what we are using to generate the PTX kernel code.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#iree-flow","title":"IREE flow","text":"<p>IREE's target independent codegen converts the compiler input to Linalg on Tensors. Afterward IREE will call the LinalgToLLVMGPU codegen passes.</p> <p>Once we get into LinalgToLLVMGPU passes we first do bufferize to generate Linalg on Buffers. Then we apply MLIR generic passes to  convert linalg to SCF dialect and then SCF to Standard dialect. After that we convert Standard dialect to LLVM+NVVM dialect.</p>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/cuda-backend/#example","title":"Example","text":"<p>Save the following mlir in /tmp/add.mlir</p> <pre><code>func.func @add(%arg0: tensor&lt;4xf32&gt;, %arg1: tensor&lt;4xf32&gt;) -&gt; tensor&lt;4xf32&gt; {\n  %0 = tensor.empty() : tensor&lt;4xf32&gt;\n  %1 = linalg.generic {\n    indexing_maps = [\n      affine_map&lt;(d0) -&gt; (d0)&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;, affine_map&lt;(d0) -&gt; (d0)&gt;], iterator_types = [\"parallel\"]}\n      ins(%arg0, %arg1 : tensor&lt;4xf32&gt;, tensor&lt;4xf32&gt;)\n      outs(%0 : tensor&lt;4xf32&gt;) {\n  ^bb0(%in: f32, %in_0: f32, %out: f32):\n    %2 = arith.addf %in, %in_0 : f32\n    linalg.yield %2 : f32\n  } -&gt; tensor&lt;4xf32&gt;\n  return %1 : tensor&lt;4xf32&gt;\n}\n</code></pre> <pre><code># First compile into a VM bytecode module.\n$ ../iree-build/tools/iree-compile \\\n--iree-hal-target-backends=cuda \\\n/tmp/add.mlir \\\n-o /tmp/add.vmfb\n\n# Run the module through CUDA HAL backend.\n$ ../iree-build/tools/iree-run-module \\\n--device=cuda \\\n--module=/tmp/add.vmfb \\\n--function=add \\\n--input=\"4xf32=[1 2 3 4]\" \\\n--input=\"4xf32=[2 2 2 2]\"\n\nEXEC @add\n4xf32=3 4 5 6\n</code></pre>","tags":["GPU","CUDA"]},{"location":"developers/design-docs/design-roadmap/","title":"Design roadmap","text":"<p>A not-so-concise walkthrough of various IREE features that are in the design process and planned for future versions. A lot of the questions around how the IREE IR is designed and why certain components exist (such as the VM) hopefully become much clearer when seeing where we want to go with the infrastructure we are building (as opposed to where we currently are with our MVP slice). This document is not meant to encompass the entire design of any individual feature and if there's interest please say hi on the iree-discuss mailing list.</p> <ul> <li>Design roadmap<ul> <li>Input Dialects<ul> <li>Quantization</li> </ul> </li> <li>flow: Data- and Execution-Flow Modeling<ul> <li>Avoiding Readbacks with flow.stream</li> <li>Threading flow.stream through the CFG</li> <li>Predication of flow.dispatch</li> <li>Deduping flow.executables</li> <li>Rematerializing CSE'd Expressions</li> <li>Device Placement</li> </ul> </li> <li>hal: Hardware Abstraction Layer and Multi-Architecture Executables<ul> <li>Allow Targets to Specify hal.interfaces</li> <li>Target-specific Scheduling Specialization</li> <li>Buffer Usage Tracking</li> <li>Batched Executable Caching and Precompilation</li> <li>Target-aware Executable Compression</li> <li>Target-aware Constant Compression</li> <li>Command Buffer Stateful Deduplication</li> <li>Resource Timeline</li> <li>Transient Tensor Ringbuffer</li> <li>Timeline Semaphores on the Module ABI</li> <li>GPU-like CPU Scheduling</li> </ul> </li> <li>vm: Lightweight Virtual Machine<ul> <li>Coroutines for Batching and Cooperative Scheduling<ul> <li>Cellular Batching</li> </ul> </li> <li>Lowering to LLVM IR</li> <li>Improved Type Support</li> <li>Indirect Command Buffer/On-Accelerator Execution</li> </ul> </li> </ul> </li> </ul>"},{"location":"developers/design-docs/design-roadmap/#input-dialects","title":"Input Dialects","text":""},{"location":"developers/design-docs/design-roadmap/#quantization","title":"Quantization","text":"<p>It's assumed that any work related to quantization/compression has happened prior to lowering into IREE dialects. Our plan is to use the proposed Quantization Transforms to achieve both training and inference-time quantization of types in a way that preserves maximum accuracy. IREE will support running with original unquantized floats in all cases, allowing for a smooth on-ramp to quantization and the gains in performance and reduction in model size that come from it.</p> <p>As future work IREE would like to move beyond these transformation-directed approaches to quantization and interface directly to frontends which have a defined enough type system to represent accurate quantized (and otherwise compressed) computations directly, not relying exclusively on compiler-side type inference transforms.</p>"},{"location":"developers/design-docs/design-roadmap/#flow-data-and-execution-flow-modeling","title":"<code>flow</code>: Data- and Execution-Flow Modeling","text":"<p>The <code>flow</code> dialect is designed to allow us to extract as much concurrency as possible from a program and partition IR into the scheduling and execution domains. Today we have the IR structure and transformation flow in place but have not yet got to the most interesting things such an infrastructure enables. A majority of the largest performance, latency, and memory usage improvements IREE can offer are determined first here and all following lowerings benefit. The fastest code is the code you don't execute and the smallest allocation is the allocation you don't make ;)</p>"},{"location":"developers/design-docs/design-roadmap/#avoiding-readbacks-with-flowstream","title":"Avoiding Readbacks with <code>flow.stream</code>","text":"<p>A majority of the readbacks we have today (manifested as <code>flow.tensor.load.*</code> ops) will be removed when we have an HLO tensor-&gt;primitive conversion. There will still be cases when readbacks are required for correctness but they usually fall into a small set of usage patterns. For those that don't this is one place where IREE will warn about performance issues, allowing programs that perform suboptimally but encouraging authors to adjust their input model to enable better behavior. The IREE VM also has specific support for hiding readback latency in an efficient way via coroutines.</p> <p>The most common case we are currently seeing in the IR is that of dynamic copies where the offsets are dependent on the result of previous computations. Source models may have top-k + gather operations, for example. These appear as a <code>flow.stream</code>, a <code>flow.tensor.load</code>, and then another <code>flow.stream</code> that uses the loaded value for a <code>flow.tensor.update</code> (or other operation):</p> <pre><code>%index_tensor = flow.ex.stream.fragment(...) -&gt; tensor&lt;i32&gt; { ... }\n%index = flow.tensor.load %index_tensor : tensor&lt;i32&gt;\n%result = flow.ex.stream.fragment(%arg0 = %index : i32, ...) -&gt; ... {\n  %0 = flow.dispatch ...\n  %1 = flow.tensor.update %0, %arg2[%index] : tensor&lt;10xf32&gt; -&gt; tensor&lt;1x10xf32&gt;\n  ...\n}\n</code></pre> <p>Today the <code>flow.tensor.update</code> turns into HAL command buffer transfer operations that must have their offsets known at recording time. This is a limitation of <code>vkCmdCopyBuffer</code> but not a fundamental limitation of any hardware. In fact several drivers implement copies as small built-in shader programs meaning that we could perform the same expansion here with the right primitives. This would allow, in the above example, both the index to be computed and the tensor to be updated within the same stream to entirely remove the host round-trip.</p>"},{"location":"developers/design-docs/design-roadmap/#threading-flowstream-through-the-cfg","title":"Threading <code>flow.stream</code> through the CFG","text":"<p>The current <code>flow.ex.stream.fragment</code>, as denoted by the <code>ex</code>perimental tag, is a temporary implementation designed to get the concept of streams lowered to the HAL dialect. For streams to be effective at modeling larger concurrency scopes they need to be able to move across branches in the CFG. This intuitively follows exactly what one would do if recording commands in C:</p> <pre><code>vkCmdCopyBuffer(cmd, ...);\nif (some_flag) {\nvkCmdBindPipeline(cmd, ..., pipeline_a);\n} else {\nvkCmdBindPipeline(cmd, ..., pipeline_b);\n}\nvkCmdDispatch(cmd, ...);\n</code></pre> <p>The corresponding <code>flow</code> IR:</p> <pre><code>  flow.stream.append[%s0](...) {\n    flow.tensor.update ...\n  }\n  %b = arith.cmpi ne %some_flag, ...\n  cond_br %b, ^a(%s0), ^b(%s0)\n^a(%s1):\n  flow.stream.append[%s1](...) {\n    flow.dispatch @pipeline_a, ...\n  }\n  br ^end(%s1)\n^b(%s2):\n  flow.stream.append[%s2](...) {\n    flow.dispatch @pipeline_b, ...\n  }\n  br ^end(%s2)\n^end(%s3):\n  ...\n</code></pre> <p>This allows the entire stream to be lowered into one command buffer without the need for any host round-trips. The conversion into the <code>flow</code> dialect will walk the CFG and attempt to thread the <code>flow.stream</code> values through so long as there are no external dependencies.</p>"},{"location":"developers/design-docs/design-roadmap/#predication-of-flowdispatch","title":"Predication of <code>flow.dispatch</code>","text":"<p>While the <code>flow.stream</code> threading through the CFG can remove many of the simpler conditional dispatches there will always be some that will have their execution dependent on the result of prior dispatches. For these a <code>flow.cond_dispatch</code> will allow a condition to be provided that must be true for the dispatch to actually be performed.</p> <p>For targets that natively support predication in their command buffers (such as D3D12's ID3D12GraphicsCommandList::SetPredication) this provides a host round-trip-free way of conditionally executing dispatches and transfers. Unfortunately Vulkan support is still lacking, though Nvidia supports the VK_EXT_conditional_rendering extension that exposes the same behavior.</p> <p>For targets that do not support predication natively it's still possible to emulate predication with indirect dispatches. In this model the workgroup counts normally used to dispatch execution are sourced from another device buffer at the time the dispatch is made instead of sourced from the command buffer at the time the dispatch is recorded. Degenerate dispatches with counts of <code>0, 0, 0</code> allow for effective neutering of the dispatch with minimal overhead (vs. the significant penalty of a host round-trip!).</p> <p>By modeling such predication at the <code>flow</code> level we are able to lower into the HAL with target-aware predication semantics and fuse indirect dispatch workgroup count calculations into existing dispatches already being performed such that overhead is reduced.</p>"},{"location":"developers/design-docs/design-roadmap/#deduping-flowexecutables","title":"Deduping <code>flow.executable</code>s","text":"<p>While still in the <code>flow</code> dialect, the executables are target-agnostic. This makes simple IR tree diffing a potential solution to deduplication. Since most of the dispatches originate from the same source-language library calls in input frameworks there's a high likelihood of duplication, and depending on when inlining is performed we may have stronger or weaker ability to perform the deduplication. Thanks to the MLIR canonicalization pass (that ensures ops are rearranged into consistent canonical representations) the IR comparisons can be done rather trivially.</p>"},{"location":"developers/design-docs/design-roadmap/#rematerializing-csed-expressions","title":"Rematerializing CSE'd Expressions","text":"<p>Common subexpression elimination is performed many times during lowering, however there comes a point where the CSE can introduce false dependencies and additional allocations that are otherwise avoidable. For example if a broadcasting operation is CSE'd and then the result is used by two or more operations that are scheduled independently what would have been a relatively cheap lowering of the broadcast to a simple index remapping now becomes an additional dispatch, materialization of an intermediate tensor, and a barrier:</p> <pre><code>%bcast = \"mhlo.broadcast_in_dim\"(%cst) : (tensor&lt;f32&gt;) -&gt; tensor&lt;1024x10xf32&gt;\n%mul1 = mhlo.multiply %arg0, %bcast : tensor&lt;1024x10xf32&gt;\n// (pretend something here that prevents fusion)\n%mul2 = mhlo.multiply %arg1, %bcast : tensor&lt;1024x10xf32&gt;\n</code></pre> <pre><code>%bcast = flow.dispatch.region(%cst : tensor&lt;f32&gt;) -&gt; tensor&lt;1024x10xf32&gt; {\n  %0 = \"mhlo.broadcast_in_dim\"(%cst) : (tensor&lt;f32&gt;) -&gt; tensor&lt;1024x10xf32&gt;\n  return %0 : tensor&lt;1024x10xf32&gt;\n}\n// a barrier will be required here\n%mul1 = flow.dispatch.region(%arg0 : tensor&lt;1024x10xf32&gt;, %bcast : tensor&lt;1024x10xf32&gt;) -&gt; tensor&lt;1024x10xf32&gt; {\n  %1 = mhlo.multiply %arg0, %bcast : tensor&lt;1024x10xf32&gt;\n  return %1 : tensor&lt;1024x10xf32&gt;\n}\n%mul2 = flow.dispatch.region(%arg1 : tensor&lt;1024x10xf32&gt;, %bcast : tensor&lt;1024x10xf32&gt;) -&gt; tensor&lt;1024x10xf32&gt; {\n  %2 = mhlo.multiply %arg1, %bcast : tensor&lt;1024x10xf32&gt;\n  return %2 : tensor&lt;1024x10xf32&gt;\n}\n</code></pre> <p>Instead the broadcast should be rematerialized inside of both dispatch regions as the cost of doing so is significantly less in compute resources and then the intermediate tensor will not be required at all. Though at first it may seem counter-intuitive to undo such a critical optimization as CSE (both to code size and often to compute) but here it's something we must carefully balance while looking at the whole system. It gets even more important when considering multi-device execution as the cost of sharing memory and synchronizing may be extremely non-trivial.</p>"},{"location":"developers/design-docs/design-roadmap/#device-placement","title":"Device Placement","text":"<p>While still within the <code>flow</code> dialect we have the ability to easily split streams and safely shuffle around operations. Target execution backends can opt into such behavior to ensure that device restrictions such as maximum in-flight memory, maximum scheduling depth, and capabilities are observed. For heterogeneous configurations the intent is that certain operations, dispatches, and streams can be attributed to specify which device categories they should be lowered. The constraint solving that takes place can be provided with generic heuristics (\"big GEMMs go on the accelerator\"), profile-guided databases based on benchmarks, learned traits via ML, etc.</p>"},{"location":"developers/design-docs/design-roadmap/#hal-hardware-abstraction-layer-and-multi-architecture-executables","title":"<code>hal</code>: Hardware Abstraction Layer and Multi-Architecture Executables","text":"<p>As the IREE HAL is designed almost 1:1 with a compute-only Vulkan API many of the techniques classically used in real-time graphics apply. The benefit we have by modeling our usage of such a low-level API in IR is that the normal work - some of which is very non-trivial - for managing allocations, tracking resource lifetime, and ensuring proper synchronization/barriers is something we can apply the full force of an offline compiler against.</p>"},{"location":"developers/design-docs/design-roadmap/#allow-targets-to-specify-halinterfaces","title":"Allow Targets to Specify <code>hal.interface</code>s","text":"<p>The <code>hal.interface</code> op specifies the ABI between the scheduler and the device containing the buffer bindings and additional non-buffer data (parameters, shapes, specialization flags, etc). Today a na\u00efve ordering is used uniformly for all targets however it is possible for target backends to opt into providing their own interfaces based on target configuration. The same <code>hal.executable</code> may have multiple interfaces and the same backend may use one or more. This is useful for when target capabilities may vary at runtime, such as the number of available storage buffer bindings in Vulkan. By exposing a few <code>hal.interface</code> variants with different binding amounts the Vulkan backend could make better use of the larger number of bindings available at runtime while still providing support for smaller configurations.</p> <p>Once we have multiple <code>hal.interface</code>s defined for executables the scheduler needs to emit HAL ops that properly switch between them. By having a canonical form for bindings we can ensure that only the differences between the interfaces will need additional code.</p>"},{"location":"developers/design-docs/design-roadmap/#target-specific-scheduling-specialization","title":"Target-specific Scheduling Specialization","text":"<p>Though the <code>flow</code> dialect attempts to fuse as many ops as possible into dispatch regions, it's not always possible for all target backends to schedule a region as a single dispatch. A classic example is algorithms like parallel reduction commonly used on GPUs that may require many dispatches to identical executables, while other algorithms may vary the executables they use based on the input parameters such as shape or the target runtime device support.</p> <p>By default the <code>flow.dispatch</code> executable translation to <code>hal.executable</code>s is performed 1:1 and it is assumed that a single dispatch is required. Extending target backends with scheduling interfaces (enabling them to opt into different scheduling behavior) will allow the backends to emit any number of <code>hal.executable</code>s and any stream commands (such as additional dispatches or transfers) they may need. This is effectively equivalent to what would be done at runtime only because we are still operating on IR prior to buffer allocation and can use the <code>hal</code> ringbuffer primitive. Through this we can elide many of the allocations that would otherwise be required at runtime (and the concurrency-limiting false dependencies that usually come along with scratch memory).</p> <p>Since the algorithm used may vary based on the parameters of the dispatch (such as the shape of the reduction which may be dynamically determined) scheduling specialization may occur even when targeting a single backend. In many cases folding and canonicalization can eliminate the overhead as whether one dynamically computed workgroup size is used instead of another the same IR is present.</p>"},{"location":"developers/design-docs/design-roadmap/#buffer-usage-tracking","title":"Buffer Usage Tracking","text":"<p>Many explicit hardware APIs require knowing how buffers are used alongside with where they should be located. For example this additional information determines caching policy on buffer accesses (write-through, write-back, etc), visibility of writes across compute units, and the possible MMU properties that may need to be maintained/matched for the buffer. By using the SSA-form value-semantics of the MLIR <code>tensor</code> as used in the <code>flow</code> dialect we have complete information of where buffers may be used or at least where they enter or leave regions where we can derive such information.</p> <p>Analysis passes can run over IR to attribute tensors such that when allocation is performed when lowering to the <code>hal</code> dialect we do so from an allocator compatible with where the buffer will be used, with memory types chosen based on the potential cost and location of operations performed (write-only on host vs. read-write on host and device, etc), and with usage bits indicating what kind of operations may be performed on the buffer. Many of these are local transformations as most buffers are only live within very small regions such as the <code>flow.stream</code> encompassing their usage.</p> <p>Traditional systems need to either use very permissive buffer properties or heuristics that can introduce additional non-trivial overhead when such heuristics are incorrect. For example, OpenGL had several such usage hints that drivers were then able to use but almost no drivers behaved as desired in all cases and it lead to additional memory ghosting, copies, readbacks, and unpredictable performance. For almost all uses of the buffers within an IREE invocation we instead can know precisely where and how buffers may need to be moved and do it a minimum number of times if it is required.</p>"},{"location":"developers/design-docs/design-roadmap/#batched-executable-caching-and-precompilation","title":"Batched Executable Caching and Precompilation","text":"<p>For targets that may require runtime preprocessing of their executables prior to dispatch, such as SPIR-V or MSL, the IREE HAL provides a caching and batch compilation mechanism based on Vulkan's Pipeline Cache.</p> <p>Today each executable is compiled on-demand and cached only for the process lifetime. Though some drivers may provide their own caching we can make better use of the explicit caching and compilation behavior with the additional information we have in the compiler.</p> <p>For any given entry point (or group of entry points) into an IREE module we can perform reachability analysis to know which executables may be executed when that entry point is invoked. In this way we can emit pre-invocation compilation checks (similar to an <code>std::call_once</code> block) that provides all required executables for compilation and allows more efficient compilation through multithreading the compiler invocations. These same compilation caching function can be exposed and invoked manually by an application to force pre-compilation when it is least likely to impact the user, such as a post-install/first-run step or concurrently while other application features are loading.</p> <p>We can use zero or more scoped caches for executables within a module. Completely dynamic modules (such as those emitted in eager-mode usage) may avoid the caching overhead entirely, while modules that have several primary usage modes (such as training and inference) may choose to use independent caches for each such mode.</p> <p>The caches generated can then be retrieved and saved by the hosting application. Upon the next execution the application can provide the caches and if still valid they will be used to avoid compilation.</p>"},{"location":"developers/design-docs/design-roadmap/#target-aware-executable-compression","title":"Target-aware Executable Compression","text":"<p>An advantage of representing executable binaries in IR after translation is that we can apply various post-compilation compression and minification techniques while still know precisely where the executable will be used. This is extremely important for SPIR-V as it is not designed to be a small at-rest format. Though the biggest lever we have to control generated code size is higher-level deduplication and specialization there will still be a sufficiently large number of executable binaries we will need to embed within the final modules and having targeted approaches for reducing their size beyond just \"gzip everything\" is very powerful.</p> <p>For example, SMOL-V is a fantastic lossless SPIR-V compression technique that, when coupled with modern dictionary-based compression algorithms, can save significant binary size. As a data point, the SPIR-V corpus SMOL-V uses for testing goes from 4.8MiB of raw SPIR-V to 348KiB of compressed SMOL-V.</p> <p>Combined with Batched Executable Caching and Precompilation we can easily use shared dictionaries and other cross-artifact compression in a relatively plug-in way.</p>"},{"location":"developers/design-docs/design-roadmap/#target-aware-constant-compression","title":"Target-aware Constant Compression","text":"<p>It's still an area that needs more research but one goal of the IREE design was to enable efficient target- and context-aware compression of large constants (typically model weights/parameters/embeddings). This may mean reusing existing hardware compression formats on GPUs, ML accelerator-specific formats, or very-low-bit-depth (1-4 bit per value) quantization techniques that cannot be directly used without first decompressing. The inspiration here is formats like Crunch and Basis Universal that perform \"supercompression\", and we may even be able to use these directly as then we can make use of GPU hardware samplers to do the 4-bit to 32-bit decompression, etc.</p>"},{"location":"developers/design-docs/design-roadmap/#command-buffer-stateful-deduplication","title":"Command Buffer Stateful Deduplication","text":"<p>The IREE HAL - much like Vulkan it is based on - eschews much of the state that traditional APIs have in favor of (mostly) immutable state objects (pipeline layouts, pipeline states, descriptor sets, etc). There are still a few stateful entry points in the API, though, and deduplicating or reordering redundant calls can reduce both IR, API, and execution overhead.</p> <p>The key place this will have the largest impact is around descriptor set bindings and push descriptors, both of which are state and can have non-trivial setup overhead. A canonicalization for such commands that inspects the target <code>hal.command_buffer</code> to see if the same state was set prior and code motion to move such commands out of loop bodies when possible would be helpful.</p>"},{"location":"developers/design-docs/design-roadmap/#resource-timeline","title":"Resource Timeline","text":"<p>A core concept of the IREE scheduler that allows for overlapping in-flight invocations is that of the resource timeline. This identifies module state that can be in use by multiple invocations and assigns timeline milestones denoting when the resource will be in the appropriate state for the current invocation to proceed. Conceptually it is like a epoch-based synchronization mechanism as commonly found in garbage collectors to allow for lock-free asynchronous memory reclamation.</p> <p>The advantage we have in the IR is that we know both the usage of all resources thanks to buffer usage tracking and the synchronization domains of all resources (in most cases). This allows us to effectively assign one timeline semaphore per writeable resource while in practice having far fewer than 1:1, as for example if two resources are only ever written in the same command buffer only one semaphore is needed to signal the completion of both writes.</p> <p>By transforming IR to sink all resource reads and writes closest to where the value is used we can enlarge the time windows that can overlap across invocations that may share those resources. This is similar to what out-of-order CPUs do with register renaming/reorder buffers/etc and something we can apply some traditional instruction scheduling techniques to (only here our 'instructions' are entire command buffer dispatches/transfers).</p> <p>Two degenerate cases of this approach are that of resource indirection (<code>util.ptr&lt;tensor&lt;T&gt;&gt;</code>) and dynamic resource shapes. In these two cases it may not be possible to continue recording commands even if we are able to ensure execution is appropriately synchronized. This is where indirect dispatch, predication, indirect command buffers, and VM coroutines can all help cover for the times where we are unable to transform away the indirection or emit shape logic without data dependencies.</p>"},{"location":"developers/design-docs/design-roadmap/#transient-tensor-ringbuffer","title":"Transient Tensor Ringbuffer","text":"<p>(When properly implemented) almost all buffers required during execution never escape the command buffers they are used in or a single VM invocation. We can trivially identify this from the explicit captures of <code>flow.stream</code> and <code>flow.dispatch</code> ops and the fact that all tensor types have value-semantics. Only those tensor values loaded-from/stored-to module state or that cross the exported module function boundary need special consideration while almost everything else can live transiently only so long as it is required during execution.</p> <p>Thanks to this information about buffer usage and lifetime we can use a ringbuffer to store the transient tensor data and other required data reservations such as uniform buffers used to pass dynamic parameters (shapes, flags, etc) into dispatches. This gives the compiler and the application a knob that allows them to control maximum concurrency (by having a very large ringbuffer) or maximum memory usage (by having a minimally small ringbuffer).</p> <p>Allocating tensors from the ringbuffer does not require sophisticated runtime packing as we can emit IR to calculate required sizes for dynamically shaped tensors. Whether a basic block reserves <code>%sz = arith.constant 42 : index</code> bytes or <code>%sz = std.muli %cst, %dyn_dim : index</code> bytes doesn't materially change how the allocations are performed. Since almost all usage involves simple write head bumps there is no need for ahead-of-time memory planning or large fixed allocations, and since no buffer within the ringbuffer can alias we can have coarse (read: low overhead) guarantees about the availability of certain regions of the ringbuffer (\"when this event is signaled all prior ringbuffer writes have completed\").</p> <p>Usually any planning we may want to perform can be done in IR via code motion. For example applying traditional algorithms used to reduce register pressure will help us attain narrower live windows within the ringbuffer leading to a larger number of in-flight operations for the same ringbuffer memory usage.</p> <p>We may end up using both a classical ringbuffer and a variant known as the bip buffer because it is better for descriptor set utilization (as we can provide many dispatch parameters with a single base offset bound once at the beginning of a region).</p>"},{"location":"developers/design-docs/design-roadmap/#timeline-semaphores-on-the-module-abi","title":"Timeline Semaphores on the Module ABI","text":"<p>Functions calls made across modules (either from C++ into the VM, VM-&gt;VM, or VM-&gt;C++) should be able to define timeline semaphores used to wait and signal on the call. We can do this by making all exports automatically have the semaphores and then make invocations populate them if they were not provided by the caller. In this way we can allow multiple invocations of exported functions to chain naturally with internal asynchronous workloads, turning most IREE invocations into just recording of command buffers that can never block.</p> <p>When combined with VM coroutine support we even have the ability to interleave any required host execution between the wait and signal semaphores provided such that the caller never knows on which device execution is taking place. It's still possible to provide synchronous wrappers that emulate blocking behavior but by having the core system designed around a single system-supported primitive we avoid the need for additional things like interrupt watchdog threads, implicit blocking, and other pitfalls.</p>"},{"location":"developers/design-docs/design-roadmap/#gpu-like-cpu-scheduling","title":"GPU-like CPU Scheduling","text":"<p>One approach to using multiple cores on a CPU is to perform interior parallelization of operations such as OpenMP or library-call-based custom thread pools (gemmlowp). This works when each individual operation is relatively costly vs. potential pipeline bubbles caused by work spinning down near the end of an operation and spinning up at the beginning of the next.</p> <p>IREE is designed to handle many more workloads - some of which have very narrow shapes but very deep pipelines (like search algorithms) - such that the above approach of multithreading within ops becomes a bottleneck. These workloads are traditionally very poorly handled by frameworks and issues with oversubscription, pipeline stalls, and suboptimal system schedulers (such as on Android) can lead to more time being spent thrashing about than actually executing real work.</p> <p>The approach we take here is to treat the cores of a CPU as if they were computation units on a GPU, each able to perform some set of heterogeneous work independent of others units. This means that the concurrency we are trying to model at the <code>flow</code> level and communicate to the runtime via the <code>hal</code> that explicitly states which dispatches can overlap and the size of the workgroups can trivially be used to distribute this work over many cores exactly as a GPU would do it. Integration with library calls that may require their own threading (such as Ruy) requires that they be able to use the IREE thread pool instead of their own.</p> <p>In this way we can avoid pipeline bubbles and other latency-inducing unpredictable scheduling. This does not mean that we treat individual units of work at the same scale as we would for GPUs, but instead that we tile and have one or more processing units that allows us to work on those tiles. Whether the tile size is defined by a library call contract, heuristics, or empirically is TBD, but expect workgroup sizes in the thousands to millions of invocations vs. normal GPU workgroup sizes in the dozens to hundreds of invocations.</p> <p>To achieve this style of scheduling efficiently we'll likely use something like marl as the scheduler. Marl provides cross-platform low-overhead fibers and is compatible with this style of scheduling as it was built for the Swiftshader software rasterizer.</p> <p>Even if IREE was only targeting CPUs the assertion is that we would still want to schedule this way and it's only an incidental benefit that if building for heterogeneous targets the scheduling code may be shared (just with a different divisor for workgroup count calculations).</p>"},{"location":"developers/design-docs/design-roadmap/#vm-lightweight-virtual-machine","title":"<code>vm</code>: Lightweight Virtual Machine","text":"<p>The VM is designed as a dynamic linkage ABI, stable bytecode representation, and intermediate lowering IR. Many of the optimizations we can perform on it will benefit all use cases (such as when lowering to LLVM IR) by allowing higher-level program transformations around synchronization that are difficult to perform on arbitrary LLVM IR.</p>"},{"location":"developers/design-docs/design-roadmap/#coroutines-for-batching-and-cooperative-scheduling","title":"Coroutines for Batching and Cooperative Scheduling","text":"<p>One of the largest features currently missing from the VM is coroutines (aka user-mode fiber scheduling). Coroutines are what will allow us to have multiple in-flight invocations into a module - some of which may be waiting on external events - without the need for complex multithreading logic or state machine machinations.</p> <p>In many cases once semaphores are exposed to callers we will not need to yield in the VM. The user will call into the module with provided semaphores, the work to perform will be recorded to one or more command buffers and submitted to the device, and then control return will return to the caller immediately.</p> <p>In cases requiring host readbacks that we were not able to remove, however, additional VM code may need to run prior to when the final semaphore is signaled. To preserve the asynchronous interface and immediate execution guarantees the compiler can emit explicit yield points (<code>vm.yield</code>) that are known-good locations for yielding (such as most resources not required after the yield having been flushed/discarded, partial synchronization scope availability if other work may be able to execute concurrently irrespective of the yielded coroutine, etc).</p> <p>When the VM encounters the yield at runtime it will suspend the coroutine until a defined condition is met. Many coroutines can be in various states at any given time and - thanks to the resource timeline - can still be memory safe. For example if two stateless invocations are made with a common wait semaphore both can be recorded and submitted without waiting on each other. If there is internal module state accessed the invocations are implicitly ordered by invocation order (similar to what Vulkan calls API order) based on internal resource timeline semaphores.</p> <p>Waking the coroutines can be performed by either an application-provided callback in the case of the application already having a periodic event which is doing bookkeeping (such as frame end callbacks when rendering or Looper idle events on Android), giving direct control over the frequency and location which IREE utilizes to perform additional work. A helper will be provided as well that runs a dedicated IREE thread to do this, but the expectation is that applications can often do a better (and importantly more predictable) job.</p> <p>By utilizing coroutines IREE will have a way to fill traditional pipeline bubbles even with execution from the same module (let alone across modules) in the situation where host readbacks or other logic is required. This increases overall throughput and utilization while reducing host wakeups as many coroutines can be processed at once to submit new work to the device queues, though it does not help reduce per-invocation latency.</p> <p>External code such as the HAL implementation or user ops may provide the wait handles used for continuation. For example, the HAL can expose a function that yields and wakes only when one or more timeline semaphores reach their target values:</p> <pre><code>// submit work\nhal.device.yield %semaphore4 &gt;= %sem4_target, %semaphore5 &gt;= %sem5_target\n// continue here, possibly much later in time\n</code></pre>"},{"location":"developers/design-docs/design-roadmap/#cellular-batching","title":"Cellular Batching","text":"<p>Though coroutines help throughput there is a way we've found to reduce latency that's been documented as cellular batching. This same technique has been implemented in prior internal systems and is one of the motivating design goals for IREE's creation. The core idea is to identify small uniform work that can be partitioned and scheduled greedily such as to enable batching or reduce associated invocation costs (such as refreshing accelerator SRAM/caches with new parameters). This usually manifests as finding large GEMM/GEMV operations using the same fixed parameters and either dynamically increasing the batch size by adding the waiting work (without deferring the actual execution time) or sequencing them back to back to ensure better cache utilization. Which approach is taken depends on any data dependencies that may be present (such as LSTM state feedback edges).</p> <p>With the foundation of coroutines in IREE it's possible to yield execution at any given point - including during command buffer recording - and wake on specific conditions. A majority of the logic can be built into the module itself with very little need for runtime machinery, as shared VM variables can be used to track pending work across invocations (even from different parts of the program) and flush based on logic wholly controlled by the user or compiler (such as count/max time latency/etc limits). This allows for the large variety of scheduling behavior various applications may want to use, such as a zero-latency batch-only-within-this-invocation to a Nagle's Algorithm-esque time or limit based behavior or even some learned model-specific windowing.</p> <p>Design work is still required on how to represent this in IR but the current thought is to model the regions in which deferred execution is possible and beneficial and allow during lowering to the VM additional transformations. This is similar to how the async-await behavior works in C# where the async keyword is just sugar that expands to additional generated helper utilities.</p> <p>A simple strawman representation for sequential dispatch may look like:</p> <pre><code>hal.scheduling_policy @defer_policy {\n  // max time, max count, max live memory, etc\n}\n...\nhal.command_buffer.dispatch.deferred @defer_policy, @dispatch, ...\n// vm.yield added here during lowering\n</code></pre> <p>There are many cases to explore and as cellular batching can have performance benefits of several orders of magnitudes it'll be one of the primary areas of research in the long-term.</p>"},{"location":"developers/design-docs/design-roadmap/#lowering-to-llvm-ir","title":"Lowering to LLVM IR","text":"<p>For scenarios where dynamic module loading is not required and entire modules can be compiled into applications we can lower the VM IR to LLVM IR within MLIR's transformation pipeline. Instead of embedding <code>vm.call</code> ops that are dispatched at runtime to things like the HAL we can instead lower to <code>llvm::CallInst</code> to runtime-resolved function pointers. This still enables all of the flexibility of heterogeneous/runtime-determined devices, pluggable diagnostics, and backend composition without any need for FlatBuffers or the VM bytecode interpreter.</p> <p>The VM was designed to make such a lowering easy and the C-style struct-based function pointer registration for runtime modules was designed to make emitting code that used it fairly robust even when linked in dynamically such as when embedded in shared objects.</p> <p>An extension of this is what we've been calling 'runtimeless mode', where the IREE VM linkage code is statically linked into the binary alongside the generated module LLVM IR. If only a single HAL backend is linked in then (with some build-fu) we should be able to get call devirtualization to reduce code size to precisely the functionality used by the module.</p>"},{"location":"developers/design-docs/design-roadmap/#improved-type-support","title":"Improved Type Support","text":"<p>Currently the VM only supports two types: <code>i32</code> and <code>vm.ref&lt;T&gt;</code>. This is an intentional limitation such that we can determine what is really needed to express the scheduling we perform, with the idea being that such a limited model will make it easier to use techniques like indirect command buffers to compile the VM itself to an accelerator executable that dispatches work without host involvement.</p> <p>As we port more models we may find a few primitives that are worth bringing into the VM design such that it's worth potential complications to future porting. These includes types like <code>f32</code> (for simple float calculations/comparisons), <code>list</code>/<code>dict</code> (easier python compatibility), and <code>vector&lt;4xf32&gt;</code> (for simple inline calculations that are not worth dispatch overhead/synchronization).</p>"},{"location":"developers/design-docs/design-roadmap/#indirect-command-bufferon-accelerator-execution","title":"Indirect Command Buffer/On-Accelerator Execution","text":"<p>Though IREE will use many different tricks such as predication to build deep pipelines there is still the requirement that the command recording and submission happens on the host CPU. Though the cost of this in terms of latency and power use can be minimized by coalescing and timelines there is still the possibility of non-trivial roundtrips being introduced that limit performance. For particular applications like low-power always-on compute or where there is significantly branchy behavior (such as search algorithms) it is important that the decision making logic as to what is dispatched runs as close to real-time as possible within the execution pipeline.</p> <p>The IREE VM is designed to be runnable on-device in a secure and cooperative way (no pointers, indirect buffer handles to allow for memory space rearrangement op-to-op, deterministic execution and explicit yield points, etc).</p> <p>The recent efforts to bring indirect command buffers to Vulkan and Metal's Indirect Command Buffers (that both derive inspiration from NV_command_list) are one such target for this. Either by lowering the VM IR to LLVM IR or SPIR-V, by a special conversion to target-specific forms, or by actually executing the VM bytecode directly on-device (it's ~1000 LoC) we should be able to prototype what full on-device usage is like. Even if only some VM functions the compiler deems useful to schedule on the device are used and the rest run on the host (particularly those functions calling imported functions) some of the most costly logic that creates tight coupling of the host and device scheduling can be limited.</p>"},{"location":"developers/design-docs/function-abi/","title":"Function ABI","text":"<p>Note</p> <p>Authored December, 2019</p> <p>Updated August, 2021</p> <p>A key job of the IREE compiler and runtime is capturing function call semantics from the originating system and providing mechanisms so that invocations can be performed in as similar way as possible in various target languages. In general, this requires additional metadata on top of the raw characteristics of a function. Where possible, this is done by attaching attributes to a function.</p> <ul> <li><code>iree.abi</code> : JSON encoded description of the function's calling convention.</li> </ul>"},{"location":"developers/design-docs/function-abi/#v1-abi","title":"V1 ABI","text":"<p>This is the default ABI supported by the IREE VM invocations. It attempts to provide a default calling convention that can be used without further reflection metadata but which may be enhanced with it.</p> <p>It natively allows monomorphic functions to be exported where arguments and results are composed of the following types:</p>"},{"location":"developers/design-docs/function-abi/#value-types","title":"Value Types:","text":"<ul> <li>Byte aligned integer type (i8, i16, i32, i64)</li> <li>Floating point value (f16, f32, f64)</li> </ul>"},{"location":"developers/design-docs/function-abi/#reference-types","title":"Reference Types:","text":"<ul> <li> <p>ND-Array buffers of Value Types:</p> <ul> <li>Simple: Packed, C-layout</li> <li>Strided: Arbitrary layout with strides (future)</li> </ul> </li> <li> <p>String (byte arrays)</p> </li> <li> <p>Opaque reference object</p> </li> </ul>"},{"location":"developers/design-docs/function-abi/#sequence-types","title":"Sequence Types:","text":"<ul> <li>Tuples: fixed length lists where each position has its own type bound</li> <li>Homogenous list: lists of arbitrary size where a single type bound applies     to all elements</li> </ul> <p>The intent with these low level types is that calling conventions can be synthesized to bind arbitrary high level, domain/language specific signatures to these types, possibly by way of additional reflection metadata.</p>"},{"location":"developers/design-docs/function-abi/#representations","title":"Representations:","text":"<p>The above are all representable with native constructs in the VM:</p> <ul> <li> <p>ValueType:</p> <ul> <li>Runtime:     <code>iree_vm_value</code></li> <li>Compile Time: primitive MLIR integer/floating point types</li> </ul> </li> <li> <p>Simple ND-Array Buffer:</p> <ul> <li>Runtime:     <code>iree_hal_buffer_view</code></li> <li>Compile Time: <code>tensor&lt;&gt;</code></li> </ul> </li> <li> <p>String:</p> <ul> <li>Runtime:     <code>iree_vm_list</code>     containing <code>i8</code></li> <li>Compile Time: <code>!util.list&lt;i8&gt;</code></li> </ul> </li> <li> <p>Tuple:</p> <ul> <li>Runtime:     <code>iree_vm_list</code>     of variant</li> <li>Compile Time: <code>!util.list&lt;?&gt;</code></li> <li>Note that these are statically type erased at the boundary.</li> </ul> </li> <li> <p>TypedList (homogenous):</p> <ul> <li>Runtime:     <code>iree_vm_list</code>     of <code>T</code></li> <li>Compile Time: <code>!util.list&lt;T&gt;</code></li> </ul> </li> </ul>"},{"location":"developers/design-docs/function-abi/#extended-type-calling-conventions","title":"Extended Type Calling Conventions","text":"<p>While the above features of the native ABI may be sufficient for direct use by various programs, many programs and callers will need to represent various higher level types, consistently mapping them to the above facilities. This section describes calling conventions for various higher level types which do not map 1:1 to the above. Not all source language types are representable, and extending these calling conventions (and the fundamental types above) is demand driven.</p> <p>All of these calling conventions presume that the arity of the arguments/results of the raw function matches the user-level function, meaning that the calling convention is specified per argument/result. Higher-level whole function transformations may also exist for some domains but are outside of the scope of this specification.</p>"},{"location":"developers/design-docs/function-abi/#structure","title":"Structure","text":"<p>A <code>Structure</code> is a common enough entity to have a dedicated calling convention. In C-like languages, this may just be a <code>struct</code>. In Python, it is typically a <code>dict</code> with an associated schema providing a name and type bound for each of its slots. In both, its slots are of fixed arity.</p> <p>In this convention, such a structure is represented as a <code>Tuple</code> in the native calling convention (i.e. <code>!util.list</code> of variant type). The order of the elements of the tuple are the natural order of the structure, where that is either:</p> <ul> <li>For a C-like system where order is determinate, it is the order of     declaration.</li> <li>For a name-based system (i.e. bind to <code>dict</code>) where no order is defined, the     natural order will be the lexically sorted order of the keys.</li> </ul>"},{"location":"developers/design-docs/function-abi/#string","title":"String","text":"<p>Most languages interop between byte arrays (i.e. the native ABI <code>String</code> type) by way of applying an encoding. Such strings are just a sequence of bytes (i.e. <code>!util.list&lt;i8&gt;</code>).</p>"},{"location":"developers/design-docs/function-abi/#typed-list","title":"Typed List","text":"<p>High level lists which all share the same type bound are represented as a <code>TypedList</code> in the native ABI.</p>"},{"location":"developers/design-docs/function-abi/#ndarray-of-reference-types","title":"NDArray of Reference Types","text":"<p>NDArrays of reference types are considered separately from those of value types. Internally, the code generated for them is completely different from what gets generated for numeric based arrays (i.e. has ref-counting, ownership semantics, non-POD, etc). These types are permitted for completeness, not necessarily performance: by nature they are already indirected and have overheads.</p> <p>In the native ABI, these are represented as a composite tuple type (i.e. today a list since sugar for tuple is not yet defined): <code>!iree.tuple&lt;!util.list&lt;T&gt;, !util.list&lt;index&gt;&gt;</code>. The first element of the tuple is the list of values, packed with a C-Layout and the second element is the list of dimension sizes.</p>"},{"location":"developers/design-docs/function-abi/#reflection","title":"Reflection","text":"<p>Additional reflection metadata may be encoded in a custom JSON form, providing additional typing hints for arguments and results. If present, this will be a reflection attribute with key <code>d</code>, containing a serialized JSON object.</p> <p>The JSON object contains:</p> <ul> <li><code>a</code> (array): List of type records for each argument.</li> <li><code>r</code> (array): List of type records for each argument.</li> </ul> <p>Type records are one of:</p> <ul> <li> <p>A string naming a primitive type:</p> <ul> <li><code>i[0-9]+</code>: Integer type with given bit width</li> <li><code>f[0-9]+</code>: IEEE floating point type with given bit width</li> <li><code>bf16</code>: BFloat16</li> </ul> </li> <li> <p>JSON <code>null</code>: A null reference value</p> </li> <li> <p><code>\"unknown\"</code>: An unknown/unmapped type</p> </li> <li> <p>An array, interpreted as a tuple describing a compound type.</p> </li> </ul>"},{"location":"developers/design-docs/function-abi/#compound-type-tuples","title":"Compound type tuples","text":"<p>A compound type tuple has a type identifier as its first element, followed with type specific fields:</p> <ul> <li><code>[\"named\", \"key\", {slot_type}]</code>: Associates a name with a slot. This is     used with the root argument list to denote named arguments that can be     passed positionally or by keyword.</li> <li><code>[\"ndarray\", {element_type}, {rank}, {dim...}]</code>: For unknown rank, the     <code>rank</code> will be <code>null</code> and there will be no dims. Any unknown dim will be     <code>null</code>.</li> <li><code>[\"slist\", {slot_type...}]</code>: An anonymous structured list of fixed arity and     slot specific types. If there are gaps in the list, empty slots will have a     <code>null</code> type.</li> <li><code>[\"stuple\", {slot_type...}]</code>: Same as <code>slist</code> but some languages     differentiate between sequences represented as lists and those represented     as tuples (read-only lists).</li> <li><code>[\"sdict\", [\"key\", {slot_type}]...]</code>: An anonymous structure with named     slots. Note that when passing these types, the keys are not passed to the     function (only the slot values).</li> <li><code>[\"py_homogeneous_list\", {element_type}]</code>: A Python list of unknown size     with elements sharing a common type bound given by <code>element_type</code>.</li> </ul>"},{"location":"developers/design-docs/invocation-execution-model/","title":"Invocation execution model","text":"<p>Authored June, 2022</p> <p>This documents the behavior of the user-visible invocation mechanism IREE uses to schedule program execution. Internally IREE uses a very similar modeling for tracking its internal workloads and in kind carries that down to target APIs and devices that themselves use a very similar model. The intent is to expose the device model in an abstracted way that allows for the full capture and communication of the execution intent to be propagated to the hardware that executes it. Though here we focus on the user-visible portion of execution there is really only one \"IREE execution model\" and the entire stack follows the same design. At its core this design is just an instantiation of an out-of-order execution algorithm such as those originating from the 1960's.</p>"},{"location":"developers/design-docs/invocation-execution-model/#glossary","title":"Glossary","text":"<pre><code>stateDiagram\n    state UserApplication {\n      direction BT\n      state Context0 {\n        ModuleA--&gt;ModuleAState0\n        ModuleB--&gt;ModuleBState0\n      }\n      state Context1 {\n        ModuleA--&gt;ModuleAState1\n        ModuleB--&gt;ModuleBState1\n        ModuleC--&gt;ModuleCState1\n      }\n      state ModuleA {\n        @func1\n        @func2\n      }\n      state ModuleB {\n        @func3\n        @func4\n      }\n      state ModuleC {\n        @func5\n      }\n    }</code></pre>"},{"location":"developers/design-docs/invocation-execution-model/#program","title":"Program","text":"<p>An IREE program is a collection of modules instantiated in a context from which invocations can be made. Invocations are ordered on a user-controlled timeline that uses fences to define the execution order requirements to enable out-of-order execution. A hosting user application may have multiple programs or multiple instances of the same program available and running invocations at a time across multiple timelines.</p>"},{"location":"developers/design-docs/invocation-execution-model/#module","title":"Module","text":"<p>Modules define executable code and data that can be loaded, linked, and run \u00e0 la ELF shared libraries. Modules may be implemented as C/C++, generated bytecode or C sources from the IREE compiler, or any other mechanism that can run code and implement the <code>iree_vm_module_t</code> interface. Modules on their own are read-only and can be reused across many contexts.</p> <p>Traditional ML runtimes would use a model (graph, etc) as their module representation. In IREE everything is a module including runtime subsystems like the HAL and user-provided custom code. This ensures that anything IREE can do can be externalized and replaced by users without needing to modify the core IREE code.</p>"},{"location":"developers/design-docs/invocation-execution-model/#context","title":"Context","text":"<p>A collection of modules are linked and instantiated in a context. Each context operates independently and carries its own copies of mutable module state. Invocations execute within a context scope and hosting applications coordinate across contexts as required. Contexts are cheap to create (microseconds) and retain (~100B + program state) such that users can decide how to manage them based on their scenario.</p> <p>Traditional ML runtimes would call these \"sessions\" but in IREE everything is a program. Whether the program is stateful or stateless and how the program is invoked is up to the program author.</p>"},{"location":"developers/design-docs/invocation-execution-model/#invocation","title":"Invocation","text":"<p>An invocation represents a single call into a module exported function using the program state stored in a context. Users can decide whether to perform synchronous blocking invocations or asynchronous non-blocking invocations per-call; the behavior of the invocation is independent from the target function and a user program may contain a mix of both.</p> <p>As an example a user program may synchronously invoke a <code>@query_output_shapes</code> function to preallocate storage for an asynchronous <code>@execute_in_place</code> function to write into.</p>"},{"location":"developers/design-docs/invocation-execution-model/#timeline","title":"Timeline","text":"<p>A timeline represents the observable order of execution. Users define their own timelines and communicate them to IREE via fences. Timelines do not match up with the order of invocations unless the user dictates they must by way of fences. In the absence of fences all invocations execute in an arbitrary order and they may execute concurrently just as threads in C with no barriers.</p> <p>Each timeline can be thought of as an independent clock domain that may operate asynchronously at its own frequency with only fences acting to tie separate timelines together. This directly mirrors real hardware constraints like clock domain crossing as each execution scope (thread on core, driver calls to queues, kernel queues to device queues, device queues to compute unit queues, etc) is naturally operating at different rates and well-designed systems must tolerate that variability.</p>"},{"location":"developers/design-docs/invocation-execution-model/#fence","title":"Fence","text":"<p>A fence is a specific point of progress in one or more timelines acting as a barrier, fork, or join point. Fences only guard execution ordering and not any particular resources though users can use them to guard resources by defining when in time the resources are available for use.</p> <p>Waits on fences are wait-until operations specifying that the timeline must reach  at least a specific point. This allows for flexible reordering and deferral of execution as executors can pull forward scheduled work based on policy (run similar work together, etc).</p>"},{"location":"developers/design-docs/invocation-execution-model/#hardware-abstraction-layer-hal","title":"Hardware Abstraction Layer (HAL)","text":"<p>The HAL is an optional feature of IREE that is used to provide a consistent interface across execution resources. It is used internally by IREE programs to define and submit work to devices and signal across them but may also be used by users to directly interface with hardware in a compatible way. Exposing the HAL API allows for users to efficiently manage their data and custom execution without expensive marshaling. Most users will only interact with HAL buffers as they work with their data but more advanced integrations can directly insert IREE into existing device contexts to transparently share scheduling and resources or insert their own code into IREE to pipeline custom execution.</p>"},{"location":"developers/design-docs/invocation-execution-model/#execution-by-timelines","title":"Execution by Timelines","text":"<p>NOTE: this defines an execution scheme that IREE supports but a user may use one or more such schemes in a single program - just as a C application may mix single- and multi-threaded code within itself for different components.</p> <p>The combination of invocations, timelines, and fences allows users to provide future knowledge to lower layers of the system by declaring their availability requirements and the lower layers are then able to execute the work out-of-order so long as the specified requirements are met. The primary goal when designing for such a system is to specify as few requirements as possible in order to provide the maximum amount of scheduling freedom to the implementation.</p> <p>This makes timelines one of the most critical components of the interface. The purpose of invocations is to schedule work against one or more timelines and what happens within the invocations is an implementation detail of the program.</p>"},{"location":"developers/design-docs/invocation-execution-model/#sequential-execution","title":"Sequential Execution","text":"<p>Here we say \"a user invokes a function to schedule execution on a timeline\" vs. a more traditional \"a user invokes a function to execute work\" and this manifests in the IREE ABI as invocations taking fences defining specific points on timelines of which the user may observe:</p> <pre><code># Fences are effectively just timeline + integer tuples and are cheap to hold.\nwait_fence = my_timeline.at(t)\nsignal_fence = my_timeline.at(t+1)\n# Schedule work against the timeline.\n# All work prior to t must complete before execution can occur and after\n# execution the timeline will advance to t+1.\nasync_invoke(@some_fn, wait_fence, signal_fence)\n# The invocation may have returned immediately after the work was scheduled;\n# until the fence is reached no actual execution may have occurred. To\n# synchronize the user code with the timeline the user can block until the fence\n# is reached.\nsignal_fence.wait()\n</code></pre> <p>To the user this would appear as:</p> <pre><code>sequenceDiagram\n    User-&gt;&gt;@some_func: invoke\n    activate @some_func\n    @some_func-&gt;&gt;User: ;\n    @some_func--&gt;&gt;@some_func: wait t\n    @some_func--&gt;&gt;User: signal t+1\n    deactivate @some_func</code></pre> <p>This means from the user's perspective the actual operations performed by the invocation are not important: the only thing the user can observe in this situation is when the timeline reaches <code>t+1</code> as they specified. Whether internally the invocation needs many steps to complete as there are timelines internal to the program is an implementation detail. Actual execution may look like this:</p> <pre><code>sequenceDiagram\n    User-&gt;&gt;@some_func: invoke\n    activate @some_func\n    @some_func-&gt;&gt;User:  ;\n    @some_func-&gt;&gt;@some_func: ;\n    @some_func--&gt;&gt;Device A: ;\n    Device A--&gt;&gt;Device A: wait t\n    activate Device A\n    @some_func-&gt;&gt;@some_func: ;\n    @some_func--&gt;&gt;Device B: ;\n    activate Device B\n    @some_func-&gt;&gt;@some_func: ;\n    Device A--&gt;&gt;@some_func: ;\n    deactivate Device A\n    @some_func-&gt;&gt;@some_func: ;\n    @some_func--&gt;&gt;Device B: ;\n    activate Device B\n    deactivate @some_func\n    Device B--&gt;&gt;User: signal t+1\n    deactivate Device B\n    deactivate Device B</code></pre> <p>Even in this simple user-synchronous example the system is able to internally run several concurrent timelines with a minimal number of synchronization points and the lowest possible latency as the user is immediately notified without any intermediate layers needing to be woken, scheduled, executed, and passed on.</p>"},{"location":"developers/design-docs/invocation-execution-model/#pipelined-execution","title":"Pipelined Execution","text":"<p>The true power of timelines comes from the ability to pipeline execution. Users define DAGs with fences and can construct arbitrarily complex execution topologies whether from the same program or across multiple programs:</p> <pre><code>stateDiagram\n    direction LR\n    state fence0 &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fence0\n    fence0 --&gt; @fn0\n    state fence1 &lt;&lt;fork&gt;&gt;\n    @fn0 --&gt; fence1\n    fence1 --&gt; @fn1\n    fence1 --&gt; @fn2\n    state fence2 &lt;&lt;join&gt;&gt;\n    @fn1 --&gt; fence2\n    @fn2 --&gt; fence2\n    @fn3 --&gt; fence2\n    fence0 --&gt; @fn4\n    @fn4 --&gt; fence2\n    fence2 --&gt; [*]</code></pre> <p>This is a simple extension to the synchronous example using the same primitives:</p> <pre><code># Timeline is defined by the user.\nfence_a = my_timeline.at(t)\nfence_b = my_timeline.at(t+1)\nfence_c = my_timeline.at(t+2)\n# Invocations are launched using the fences and may not complete immediately.\nasync_invoke(@fn0, fence_a, fence_b)\nasync_invoke(@fn1, fence_b, fence_c)\nasync_invoke(@fn2, fence_b, fence_c)\nasync_invoke(@fn3, None, fence_c)\nasync_invoke(@fn4, fence_a, fence_c)\n# Blocking here but no need to; could pass fence_c on to other invocations.\nfence_c.wait()\n</code></pre> <p>The critical point of this being that the user never had to wait for any particular invocation to complete before being able to schedule more work against the timeline, even if those invocations could themselves not complete synchronously. The lower layers of the system are able to fully model the execution as early as possible without needing to communicate (and importantly synchronize) with the user.</p>"},{"location":"developers/design-docs/invocation-execution-model/#io","title":"I/O","text":"<p>Users define the semantics of their programs themselves. For example if the user knows the precise shape of an output buffer they can preallocate the buffer and pass it in. If they don't know they can decide to factor out the shape calculation and invoke that synchronously in order to compute the shape, allocate the appropriately sized buffer, and pass that in. Or they could decide to only deal with synchronous invocations and return a program-allocated buffer view with the appropriate shape in their callback. IREE does not dictate the design of user programs and as such enables mixed stateful/stateless, asynchronous/synchronous, and arbitrary scheduling models (enqueue/drain, windowing, etc).</p> <p>Inputs and outputs to invocations are provided by the user as primitive values (integers, floats, etc), supported builtin types (lists, byte buffers/strings), custom user types, and HAL types like buffers or buffer views (buffers + shape and type metadata). One or more wait fences can be used to order invocation access to one or more inputs by indicating that the resource is not available until a certain fence is reached. Similarly one or more signal fences can be used to order subsequent access to the resources by indicating the advancement of the timeline when they are available.</p> <pre><code># wait_fence_a must be reached before buffer_a and buffer_b can be read.\n# wait_fence_b must be reached before buffer_c can be read.\n# buffer_a will be ready to read when signal_fence_a has been reached.\nasync_invoke(@fn,\n             (wait_fence_a, buffer_a, buffer_b),\n             42,  # no ordering required on value types\n             (wait_fence_b, buffer_c),\n             (signal_fence_a, buffer_a))\n</code></pre> <p>The above example demonstrates an in-place operation on <code>buffer_a</code>. It's also possible for invocations to return values:</p> <pre><code>result = invoke(@sum, 1, 2)  # = 3\n</code></pre> <p>When executed asynchronously a callback or any construct that can be built upon them (like promises/futures) can receive the results:</p> <pre><code>def my_callback(result):\n  print(result)  # 3\nasync_invoke(@sum, 1, 2, my_callback)\n</code></pre>"},{"location":"developers/design-docs/invocation-execution-model/#stream-ordered-allocations","title":"Stream-ordered Allocations","text":"<p>Invocations generally have only a few KB of overhead and pipelined command buffers take only a small amount more. Storage buffers, however, can easily take hundreds of MB per invocation for I/O and transient state. This compounds as program usage becomes more complex or multiple programs are involved. IREE supports traditional host-ordered allocations (\u00e0 la malloc/free) for persistent buffers like large constants/read-only data or user-managed ringbuffers. Stream-ordered allocations are also supported to allow for pooled buffer reservations that can be allocated in a scheduled order alongside program execution.</p> <p>For more detailed examples see the CUDA blog posts describing their implementation: part 1, part 2.</p> <p>With stream-ordered allocations each allocation and deallocation operation is scheduled with wait and signal fences just as with invocations. This allows these allocation operations to execute remotely on device without host program involvement. For example, scheduling <code>alloca0</code>/<code>dealloca0</code> and <code>alloca1</code>/<code>dealloca1</code> interleaved with the function execution allows for the transient memory required for executing <code>@fn0</code> to remain uncommitted until immediately before it is executed, committed during execution, and then decommitted immediately after execution. The memory required for passing data from <code>@fn0</code> to the subsequent <code>@fn1</code> and <code>@fn2</code> survives until after they have completed executing before being decommitted. By using the same scheduling primitives as execution the allocation topology can be as arbitrarily complex as the invocation topology:</p> <pre><code>stateDiagram\n    direction LR\n    state fence0a &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fence0a\n    state fence0b &lt;&lt;fork&gt;&gt;\n    fence0a --&gt; alloca0\n    fence0a --&gt; alloca1\n    alloca0 --&gt; fence0b\n    alloca1 --&gt; fence0b\n    fence0b --&gt; @fn0\n    state fence1a &lt;&lt;fork&gt;&gt;\n    @fn0 --&gt; fence1a\n    state fence1b &lt;&lt;fork&gt;&gt;\n    fence1a --&gt; dealloc0\n    dealloc0 --&gt; fence1b\n    fence1b --&gt; @fn1\n    fence1b --&gt; @fn2\n    state fence2a &lt;&lt;join&gt;&gt;\n    @fn1 --&gt; fence2a\n    @fn2 --&gt; fence2a\n    state fence2b\n    fence2a --&gt; dealloc1\n    state fence2b &lt;&lt;join&gt;&gt;\n    dealloc1 --&gt; fence2b\n    fence2b --&gt; [*]</code></pre> <p>When operating in this way allocations from the host-perspective are just reservations for a slice of pooled storage that will be committed at some point in the future. Likewise deallocations from the host-perspective release the prior reservation and schedule the paired decommit at some point in the future. Scheduling N sequential invocations thus requires only enough committed storage for a single invocation in addition to the I/O (unless that too is stream-ordered).</p> <p>This scheduling behavior allows for both minimal peak memory consumption regardless of the number of programs or invocation pipeline depth and sharing of committed storage across programs: the memory consumption of a program at rest is near zero when stateless and the sum of all state when stateful. Target devices that natively support stream-ordered allocations (like CUDA) can even share pools across processes.</p> <p>The other provided feature in combination with the fence guaranteed forward progress is that so long as the memory pool can service a single request execution can still continue even when constrained. A device can serialize two independent invocations requiring 400MB of transient memory when the system only has 512MB available with no user-visible impact besides increased latency. This does require the user to ensure they schedule work that is possible to run or rely on the target system having paging in order to lighten the strictness of the pool quotas.</p> <p>Stream-ordered allocations performed by the user for invocation inputs can be declared as transferred to the program. This allows the program to eagerly deallocate or reuse the input storage while still preserving the internal scheduling requirements of the program.</p>"},{"location":"developers/design-docs/invocation-execution-model/#internal-state","title":"Internal State","text":"<p>A stateful program may contain internal timelines that it uses to order its own execution. Take for example this simple stateful program:</p> <pre><code>class TrivialKernel(Program):\n  _x0 = Program.export_global(x_type)\n  def get(self):\n    return self._x0\n  def set(self, x=x_type):\n    self._x0 = x\n  def matmul(self, x=y_type):\n    self._x0 = self._matmul(x, self._x0)\n  @Program.kernel\n  def _matmul(x, x0):\n    return jnp.matmul(x, x0)\n</code></pre> <p>Each invocation of <code>matmul</code> needs to be executed in-order with prior invocations as there is a data dependency established on <code>self._x0</code>. Attempts to <code>get</code> or <code>set</code> must also be sequenced correctly with the <code>matmul</code> invocations. A basic usage like this:</p> <pre><code>m = TrivialKernel()\nm.set(input)\nm.matmul(a)\nm.matmul(b)\nm.matmul(c)\noutput = m.get()\nprint(output)  # implicit wait\n</code></pre> <p>Would be executed as:</p> <pre><code>sequenceDiagram\n    activate User\n    User-&gt;&gt;TrivialKernel: @set(input)\n    activate TrivialKernel\n    TrivialKernel--&gt;&gt;Device: ;\n    deactivate TrivialKernel\n    activate Device\n    TrivialKernel-&gt;&gt;User: ;\n    User-&gt;&gt;TrivialKernel: @matmul(a)\n    activate TrivialKernel\n    TrivialKernel--&gt;&gt;Device: ;\n    deactivate TrivialKernel\n    TrivialKernel-&gt;&gt;User: ;\n    User-&gt;&gt;TrivialKernel: @matmul(b)\n    activate TrivialKernel\n    TrivialKernel--&gt;&gt;Device: ;\n    deactivate TrivialKernel\n    TrivialKernel-&gt;&gt;User: ;\n    User-&gt;&gt;TrivialKernel: @matmul(c)\n    activate TrivialKernel\n    TrivialKernel--&gt;&gt;Device: ;\n    deactivate TrivialKernel\n    TrivialKernel-&gt;&gt;User: ;\n    User-&gt;&gt;TrivialKernel: @get()\n    activate TrivialKernel\n    TrivialKernel--&gt;&gt;Device: ;\n    deactivate TrivialKernel\n    TrivialKernel-&gt;&gt;User: ;\n    Device--&gt;&gt;Device: ;\n    deactivate User\n    User-&gt;&gt;User: (wait)\n    Device--&gt;&gt;User: (signal)\n    deactivate Device\n    activate User\n    User-&gt;&gt;User: print(output)\n    deactivate User</code></pre> <p>Note that although the user provided no timeline of their own execution is still ordered correctly due to the internal timeline constructed by the program. If the user wanted to also pipeline execution with another program they could do so by providing their own fences.</p>"},{"location":"developers/general/contributing/","title":"Contributing to IREE","text":"<p>We'd love to accept your patches and contributions to this project.</p> <p>Please file issues or reach out on any of our other communication channels before doing substantial work; this will ensure that others don't duplicate the work and that there's a chance to discuss any design issues.</p>"},{"location":"developers/general/contributing/#developer-policies","title":"Developer policies","text":""},{"location":"developers/general/contributing/#code-of-conduct","title":"Code of conduct","text":"<p>This project follows the OpenXLA Code of Conduct.</p>"},{"location":"developers/general/contributing/#contributor-license-agreement","title":"Contributor License Agreement","text":"<p>Contributions to this project must be accompanied by a Contributor License Agreement (CLA). Head over to https://cla.developers.google.com/ to see your current agreements on file or to sign a new one.</p> <ul> <li>You (or your employer) retain the copyright to your contribution; this simply   gives us permission to use and redistribute your contributions as part of the   project.</li> <li>You generally only need to submit a CLA once, so if you've already submitted   one (even if it was for a different project), you probably don't need to do it   again.</li> </ul>"},{"location":"developers/general/contributing/#coding-style-guidelines","title":"Coding style guidelines","text":"<p>Most of the code style is derived from the Google Style Guides for the appropriate language and is generally not something we accept changes on (as clang-format and other linters set that for us). The C++ compiler portion of the project follows the MLIR/LLVM style guide.</p> <p>Improvements to code structure and clarity are welcome but please file issues to track such work first. Pure style changes are unlikely to be accepted unless they are applied consistently across the project.</p> Tip - code formatters and lint scripts <p>Formatters like <code>clang-format</code> (C/C++) and Black (Python) can be set to run automatically in your editor of choice.</p> <p>The script at <code>build_tools/scripts/lint.sh</code> can also be used to run the full suite of lint checks.</p>"},{"location":"developers/general/contributing/#code-reviews","title":"Code reviews","text":"<p>All submissions, including submissions by maintainers, require review. We use GitHub pull requests (PRs) for this purpose. Consult GitHub Help for more information on using pull requests.</p> <ul> <li>Please keep PRs small (focused on a single issue) to make reviews and later   culprit-finding easier.</li> <li>You may see trusted core contributors bending this rule for project   maintenance and major subsystem renovation. If you feel like the rules aren't   working for a certain situation, please ask as we bias towards pragmatism for   cases that require it.</li> </ul>"},{"location":"developers/general/contributing/#github-actions-workflows","title":"GitHub Actions workflows","text":"<p>We use GitHub Actions to automatically build and test various parts of the project.</p> <ul> <li>Most presubmit workflows will only run automatically on PRs if you are a   project collaborator. Otherwise a maintainer must   approve workflow runs.   If you are sending code changes to the project, please ask to be added as a   collaborator, so that these can run automatically.</li> <li>It is generally expected that PRs will only be merged when all checks are   passing. In some cases, pre-existing failures may be bypassed by a maintainer.</li> </ul> Tip - adjusting workflow behavior <p>Some workflows only run on commits after they are merged. See the CI behavior manipulation section below to learn how to customize this behavior.</p>"},{"location":"developers/general/contributing/#merging-approved-changes","title":"Merging approved changes","text":"<p>After review and presubmit checks, PRs should typically be merged using \"squash and merge\".</p> <ul> <li>The squashed commit summary should match the PR title and the commit   description should match the PR body (this is the default behavior).   Accordingly, please write these as you would a helpful commit message.</li> </ul> <p>It is assumed that the PR author will merge their change unless they ask someone else to merge it for them (e.g. because they don't have write access yet).</p>"},{"location":"developers/general/contributing/#obtaining-commit-access","title":"Obtaining commit access","text":"<p>Access to affiliated repositories is divided into three tiers:</p> Tier Description Team link Triage New project members should typically start here Can be assigned issues Can apply labels to issues / PRs Can run workflows without approval iree-triage Write Established project contributors should request this access Can merge approved pull requests Can create branches iree-write Maintain  Can edit repository settings Can push to protected branches iree-maintain <p>All access tiers first require joining the OpenXLA GitHub organization.</p> <p>Fill out this form to request access </p> <p>Once you are a member of the OpenXLA GitHub organization, you can request to join any of the teams on https://github.com/orgs/openxla/teams.</p> <p>Note: other GitHub organizations</p> <p>Work on IREE sometimes spans other GitHub organizations like iree-org and shark-infra. Reach out to a project member if you would also like access to repositories in those organizations.</p>"},{"location":"developers/general/contributing/#credits-in-the-authors-file","title":"Credits in the AUTHORS file","text":"<p>If you would like additional recognition for your contributions, you may add yourself or your organization to the AUTHORS file that keeps track of those who have made significant contributions to the project.</p> <ul> <li>Please add the entity who owns the copyright for your contribution.</li> <li>The source control history remains the most accurate source for individual   contributions.</li> </ul>"},{"location":"developers/general/contributing/#tips-for-contributors","title":"Tips for contributors","text":""},{"location":"developers/general/contributing/#tool-recommendations","title":"Tool recommendations","text":"Program or tool Description  Visual Studio Code (VSCode) The most commonly used editor amongst IREE developers  Ccache A fast C/C++ compiler cache. See the CMake with <code>ccache</code> page  GitHub CLI A CLI for interacting with GitHub  \"Refined GitHub\" browser extensions Extension that add features to the GitHub UI"},{"location":"developers/general/contributing/#build-systems","title":"Build systems","text":"<p>IREE supports building from source with both Bazel and CMake.</p> <ul> <li>CMake is the preferred build system and offers the most flexible   configuration options</li> <li>Bazel is a stricter build system and helps with usage in Google's downstream   source repository</li> <li>Certain dependencies (think large/complex projects like CUDA, TensorFlow,   PyTorch, etc.) may be difficult to support with one build system or the   other, so the project may configure these as optional</li> </ul>"},{"location":"developers/general/contributing/#continuous-integration-ci","title":"Continuous integration (CI)","text":"<p>IREE uses GitHub Actions for CI. The primary CI is configured in the ci.yml workflow file.</p>"},{"location":"developers/general/contributing/#self-hosted-runners","title":"Self-hosted runners","text":"<p>In addition to the default runners GitHub provides, IREE uses self-hosted runners to run many of its workflow jobs. These enable access to additional compute and custom configurations such as accelerators. Configuration scripting is checked in to this repository (see the README for that directory).</p>"},{"location":"developers/general/contributing/#custom-managed-runners","title":"Custom managed runners","text":"<p>In addition to our self-hosted runners, we use GitHub's large managed runners for some platforms.</p>"},{"location":"developers/general/contributing/#ci-behavior-manipulation","title":"CI behavior manipulation","text":"<p>The setup step of the CI determines which CI jobs to run. This is controlled by the configure_ci.py script. It will generally run a pre-determined set of jobs on presubmit with some jobs kept as post-submit only. If changes are only to a certain set of excluded files that we know don't affect CI (e.g. Markdown files), then it will skip the jobs.</p> <p>You can customize which jobs run using git trailers in the PR description.</p> <p>The available options are</p> <pre><code>ci-skip: jobs,to,skip\nci-extra: extra,jobs,to,run\nci-exactly: exact,set,of,jobs,to,run\nskip-ci: free form reason\nskip-llvm-integrate-benchmark: free form reason\nbenchmark-extra: extra,benchmarks,to,run\nrunner-env: [testing|prod]\n</code></pre> Using <code>skip-ci</code> <p><code>skip-ci</code> skips all jobs. It is mutually exclusive with the other <code>ci-*</code> options and is synonomous with <code>ci-skip: all</code>.</p> <pre><code>skip-ci: free form reason\n</code></pre> Using <code>ci-skip</code>, <code>ci-extra</code>, <code>ci-exactly</code> <p>The <code>ci-*</code> options instruct the setup script on which jobs to include or exclude from its run. They take a comma-separated list of jobs which must be from the set of top-level job identifiers in the <code>ci.yml</code> file or the special keyword \"all\" to indicate all jobs.</p> <pre><code>ci-skip: jobs,to,skip\nci-extra: extra,jobs,to,run\nci-exactly: exact,set,of,jobs,to,run\n</code></pre> <ul> <li><code>ci-skip</code> removes jobs that would otherwise be included, though it is not an error to list jobs that would not be included by default.</li> <li><code>ci-extra</code> adds additional jobs that would not have otherwise been run, though it is not an error to list jobs that would have been included anyway. It is an error to list a job in both \"skip\" and \"extra\".</li> <li><code>ci-exactly</code> provides an exact list of jobs that should run. It is mutually exclusive with both \"skip\" and \"extra\".</li> </ul> <p>In all these cases, the setup does not make any effort to ensure that job dependencies are satisfied. Thus, if you request skipping the <code>build_all</code> job, all the jobs that depend on it will fail, not be skipped.</p> Using <code>benchmark-extra</code>, <code>skip-llvm-integrate-benchmark</code> <pre><code>benchmark-extra: extra,benchmarks,to,run\nskip-llvm-integrate-benchmark: free form reason\n</code></pre> <p>Benchmarks don't run by default on PRs, and must be specifically requested.</p> <p>The <code>benchmark-extra</code> option allows specifying additional benchmark presets to run as part of benchmarking. It accepts a comma-separated list of benchmark presets. This combines with labels added to the PR (which are a more limited set of options). See the benchmark suites documentation.</p> <p>Benchmarks do run by default on PRs detected to be an integration of LLVM into IREE, but this behavior can be disabled with <code>skip-llvm-integrate-benchmark</code>.</p> Using <code>runner-env</code> <p>The <code>runner-env</code> option controls which runner environment to target for our self-hosted runners. We maintain a test environment to allow testing out new configurations prior to rolling them out. This trailer is for advanced users who are working on the CI infrastructure itself.</p> <pre><code>runner-env: [testing|prod]\n</code></pre>"},{"location":"developers/general/contributing/#ci-configuration-recipes","title":"CI configuration recipes","text":"<p>Copy/paste any of these at the bottom of a PR description to change what the CI runs.</p> <ul> <li> <p>Also run Windows and macOS builds that are normally post-merge only:</p> <pre><code>ci-extra: build_test_all_windows,build_test_all_macos_arm64,build_test_all_macos_x86_64\n</code></pre> </li> <li> <p>Also run GPU tests on NVIDIA A100 runners (opt-in due to low availability):</p> <pre><code>ci-extra: test_a100\n</code></pre> </li> <li> <p>Skip all CI builds and tests, e.g. for comment-only changes:</p> <pre><code>skip-ci: Comment-only change.\n</code></pre> </li> <li> <p>Only run Bazel builds, e.g. for changes only affecting Bazel rules:</p> <pre><code>ci-exactly: build_test_all_bazel\n</code></pre> </li> </ul> <p>For example, this PR opted in to running the <code>build_test_all_windows</code> job:</p> <p></p> <p>The enabled jobs can be viewed from the Summary page of an action run:</p> <p></p>"},{"location":"developers/general/contributing/#git-workflows","title":"Git workflows","text":"<p>We tend to use the \"triangular\" or \"forking\" workflow. Develop primarily on a clone of the repository on your development machine. Any local branches named the same as persistent branches from the main repository are pristine (though potentially stale) copies. You only fastforward these to match upstream and otherwise do development on other branches. When sending PRs, you push to a different branch on your public fork and create the PR from there.</p>"},{"location":"developers/general/contributing/#setup","title":"Setup","text":"<ol> <li> <p>Create a fork of the main repository.</p> </li> <li> <p>Create a local git repository with remotes <code>upstream</code> (the main repository)     and <code>origin</code> (your personal fork). To list your current remotes     <code>git remote -v</code>.</p> <p>a. If you already cloned from the main repository (e.g. by following the getting started guide):</p> <pre><code># From your existing git repo\n$ git remote rename origin upstream\n$ git remote add origin https://github.com/&lt;github_username&gt;/iree.git\n</code></pre> <p>b. If you haven't already cloned:</p> <pre><code># From whatever directory under which you want to nest your repo\n$ git clone https://github.com/&lt;github_username&gt;/iree.git\n$ cd iree\n$ git remote add upstream https://github.com/openxla/iree.git\n</code></pre> <p>This is especially important for maintainers who have write access (so can push directly to the main repository) and admins who have elevated privileges (so can push directly to protected branches).</p> <p>These names are just suggestions, but you might find some scripts where the defaults are for remotes named like this.</p> <p>For extra safety, you can make it difficult to push directly to upstream by setting the push url to something invalid: <code>git remote set-url --push upstream DISABLE</code>, which requires re-enabling the push URL explicitly before pushing. You can wrap this behavior in a custom git command like git-sudo.</p> </li> <li> <p>Use a script like     git_update.sh     to easily synchronize <code>main</code> with <code>upstream</code>. Submodules make this is a     little trickier than it should be. You can also turn this into a git command     by adding it to your path as <code>git-update</code>.</p> </li> </ol>"},{"location":"developers/general/contributing/#git-config","title":"Git config","text":"<p>These are some additional options you could put in your top-level <code>.gitconfig</code> or repository-specific <code>.git/config</code> files that are conducive the recommended workflow</p> <pre><code>[push]\ndefault = current\n[alias]\n# Delete branches that you pushed and have been deleted upstream, e.g. because\n# the PR was merged.\ngone = ! \"git fetch -p  &amp;&amp; git for-each-ref --format '%(refname:short) %(upstream:track)' | awk '$2 == \\\"[gone]\\\" {print $1}' | xargs -r git branch -D\"\n# Update from upstream (custom command) and delete obsolete local branches.\nsync = ! (git update main &amp;&amp; git gone)\n# Create a new branch based off of main (requires a clean working directory).\nnew = \"!f(){ \\\\\\ngit checkout main &amp;&amp; git switch -c $1; \\\\\\n}; f\"\n# Display branches in a useful \"latest last\" format\nbr = for-each-ref --sort=committerdate refs/heads/ --format='%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) (%(color:green)%(committerdate:relative)%(color:reset))'\n# `git git foo` -&gt; `git foo` typo fixer\ngit = \"!f(){ \\\\\\n git \\\"$@\\\"; \\\\\\n}; f\"\n# Get the git root directory\nroot = rev-parse --show-toplevel\n# checkout, but also sync submodules\nch = \"!f() { \\\\\\n git checkout \\\"$@\\\"; git submodule sync &amp;&amp; git submodule update --init; \\\\\\n}; f\"\n# See the diff for a PR branch vs the main branch\ndiffmain = diff --merge-base main\n# See only the files that differ vs the main branch\nwhatsout = diffmain --name-only\n[checkout]\n# If the checkout command\ndefaultRemote = origin\n[pull]\n# When pulling, only complete the pull if its a clean fast forward.\nff = only\n[remote]\n# Push to your fork (origin) by default\npushDefault = origin\n[url \"ssh://git@github.com/\"]\n# Pull with https (so no auth required), but push with ssh.\npushInsteadOf = https://github.com/\n</code></pre>"},{"location":"developers/general/developer-overview/","title":"Developer overview","text":"<p>This guide provides an overview of IREE's project structure and main tools for developers.</p>"},{"location":"developers/general/developer-overview/#project-code-layout","title":"Project code layout","text":"<ul> <li>/compiler/:   MLIR dialects, LLVM compiler passes, module translation code, etc.<ul> <li>bindings/: Python and other language bindings</li> </ul> </li> <li>/runtime/:   Standalone runtime code including the VM and HAL drivers<ul> <li>bindings/: Python and other language bindings</li> </ul> </li> <li>/integrations/:   Integrations between IREE and other frameworks, such as TensorFlow</li> <li>/tests/:   Tests for full compiler-&gt;runtime workflows</li> <li>/tools/:   Developer tools (<code>iree-compile</code>, <code>iree-run-module</code>, etc.)</li> <li>/samples/: Also see the   separate https://github.com/iree-org/iree-samples repository</li> </ul>"},{"location":"developers/general/developer-overview/#iree-compiler-code-layout","title":"IREE compiler code layout","text":"<ul> <li>API/:   Public C API</li> <li>Codegen/:   Code generation for compute kernels</li> <li>Dialect/:   MLIR dialects (<code>Flow</code>, <code>HAL</code>, <code>Stream</code>, <code>VM</code>, etc.)</li> <li>InputConversion/:   Conversions from input dialects and preprocessing</li> </ul>"},{"location":"developers/general/developer-overview/#iree-runtime-code-layout","title":"IREE runtime code layout","text":"<ul> <li>base/:   Common types and utilities used throughout the runtime</li> <li>hal/:   Hardware Abstraction Layer for IREE's runtime, with   implementations for hardware and software backends</li> <li>schemas/:   Data storage format definitions, primarily using   FlatBuffers</li> <li>task/:   System for running tasks across multiple CPU threads</li> <li>tooling/:   Utilities for tests and developer tools, not suitable for use as-is in   downstream applications</li> <li>vm/:   Bytecode Virtual Machine used to work with IREE modules and invoke   IREE functions</li> </ul>"},{"location":"developers/general/developer-overview/#developer-tools","title":"Developer tools","text":"<p>IREE's core compiler accepts programs in supported input MLIR dialects (e.g. <code>stablehlo</code>, <code>tosa</code>, <code>linalg</code>). Import tools and APIs may be used to convert from framework-specific formats like TensorFlow SavedModel to MLIR modules. While programs are ultimately compiled down to modules suitable for running on some combination of IREE's target deployment platforms, IREE's developer tools can run individual compiler passes, translations, and other transformations step by step.</p>"},{"location":"developers/general/developer-overview/#iree-opt","title":"iree-opt","text":"<p><code>iree-opt</code> is a tool for testing IREE's compiler passes. It is similar to mlir-opt and runs sets of IREE's compiler passes on <code>.mlir</code> input files. See \"conversion\" in MLIR's Glossary for more information. Transformations performed by <code>iree-opt</code> can range from individual passes performing isolated manipulations to broad pipelines that encompass a sequence of steps.</p> <p>Test <code>.mlir</code> files that are checked in typically include a <code>RUN</code> block at the top of the file that specifies which passes should be performed and if <code>FileCheck</code> should be used to test the generated output.</p> <p>Here's an example of a small compiler pass running on a test file:</p> <pre><code>$ ../iree-build/tools/iree-opt \\\n--split-input-file \\\n--mlir-print-ir-before-all \\\n--iree-drop-compiler-hints \\\n$PWD/compiler/src/iree/compiler/Dialect/Util/Transforms/test/drop_compiler_hints.mlir\n</code></pre> <p>For a more complex example, here's how to run IREE's complete transformation pipeline targeting the VMVX backend on the fullyconnected.mlir model file:</p> <pre><code>$ ../iree-build/tools/iree-opt \\\n--iree-transformation-pipeline \\\n--iree-hal-target-backends=vmvx \\\n$PWD/tests/e2e/stablehlo_models/fullyconnected.mlir\n</code></pre>"},{"location":"developers/general/developer-overview/#iree-compile","title":"iree-compile","text":"<p><code>iree-compile</code> is IREE's main compiler driver for generating binaries from supported input MLIR assembly.</p> <p>For example, to translate <code>simple.mlir</code> to an IREE module:</p> <pre><code>$ ../iree-build/tools/iree-compile \\\n--iree-hal-target-backends=vmvx \\\n$PWD/samples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre>"},{"location":"developers/general/developer-overview/#iree-run-module","title":"iree-run-module","text":"<p>The <code>iree-run-module</code> program takes an already translated IREE module as input and executes an exported main function using the provided inputs.</p> <p>This program can be used in sequence with <code>iree-compile</code> to translate a <code>.mlir</code> file to an IREE module and then execute it. Here is an example command that executes the simple <code>simple_abs_vmvx.vmfb</code> compiled from <code>simple_abs.mlir</code> above on IREE's VMVX driver:</p> <pre><code>$ ../iree-build/tools/iree-run-module \\\n--module=/tmp/simple_abs_vmvx.vmfb \\\n--device=local-task \\\n--function=abs \\\n--input=f32=-2\n</code></pre>"},{"location":"developers/general/developer-overview/#iree-check-module","title":"iree-check-module","text":"<p>The <code>iree-check-module</code> program takes an already translated IREE module as input and executes it as a series of googletest tests. This is the test runner for the IREE check framework.</p> <pre><code>$ ../iree-build/tools/iree-compile \\\n--iree-input-type=stablehlo \\\n--iree-hal-target-backends=vmvx \\\n$PWD/tests/e2e/xla_ops/abs.mlir \\\n-o /tmp/abs.vmfb\n</code></pre> <pre><code>$ ../iree-build/tools/iree-check-module \\\n--device=local-task \\\n--module=/tmp/abs.vmfb\n</code></pre>"},{"location":"developers/general/developer-overview/#iree-run-mlir","title":"iree-run-mlir","text":"<p>The <code>iree-run-mlir</code> program takes a <code>.mlir</code> file as input, translates it to an IREE bytecode module, and executes the module.</p> <p>It is designed for testing and debugging, not production uses, and therefore does some additional work that usually must be explicit, like marking every function as exported by default and running all of them.</p> <p>For example, to execute the contents of samples/models/simple_abs.mlir:</p> <pre><code># iree-run-mlir &lt;compiler flags&gt; [input.mlir] &lt;runtime flags&gt;\n$ ../iree-build/tools/iree-run-mlir \\\n--iree-hal-target-backends=vmvx \\\n$PWD/samples/models/simple_abs.mlir \\\n--input=f32=-2\n</code></pre>"},{"location":"developers/general/developer-overview/#iree-dump-module","title":"iree-dump-module","text":"<p>The <code>iree-dump-module</code> program prints the contents of an IREE module FlatBuffer file.</p> <p>For example, to inspect the module translated above:</p> <pre><code>../iree-build/tools/iree-dump-module /tmp/simple_abs_vmvx.vmfb\n</code></pre>"},{"location":"developers/general/developer-overview/#useful-generic-flags","title":"Useful generic flags","text":""},{"location":"developers/general/developer-overview/#read-inputs-from-a-file","title":"Read inputs from a file","text":"<p>All the IREE tools support reading input values from a file. This is quite useful for debugging. Use <code>--help</code> for each tool to see what the flag to set. The inputs are expected to be newline-separated. Each input should be either a scalar or a buffer. Scalars should be in the format <code>type=value</code> and buffers should be in the format <code>[shape]xtype=[value]</code>. For example:</p> <pre><code>1x5xf32=1,-2,-3,4,-5\n1x5x3x1xf32=15,14,13,12,11,10,9,8,7,6,5,4,3,2,1\n</code></pre>"},{"location":"developers/general/developer-overview/#-iree-flow-trace-dispatch-tensors","title":"<code>--iree-flow-trace-dispatch-tensors</code>","text":"<p>This flag will enable tracing inputs and outputs for each dispatch function. It is easier to narrow down test cases, since IREE breaks a ML workload into multiple dispatch function. When the flag is on, IREE will insert trace points before and after each dispatch function. The first trace op is for inputs, and the second trace op is for outputs. There will be two events for one dispatch function.</p>"},{"location":"developers/general/developer-tips/","title":"Developer tips and tricks","text":"<p>The IREE compiler is built using MLIR, so it naturally supports the common MLIR debugging workflows. For areas where IREE differentiates itself, this page lists other helpful tips and tricks.</p>"},{"location":"developers/general/developer-tips/#setting-compiler-options","title":"Setting compiler options","text":"<p>Tools such as <code>iree-compile</code> take options via command-line flags. Pass <code>--help</code> to see the full list:</p> <pre><code>$ iree-compile --help\n\nOVERVIEW: IREE compilation driver\n\nUSAGE: iree-compile [options] &lt;input file or '-' for stdin&gt;\n\nOPTIONS:\n  ...\n</code></pre> <p>Tip - Options and the Python bindings</p> <p>If you are using the Python bindings, options can be passed via the <code>extra_args=[\"--flag\"]</code> argument:</p> <pre><code>import iree.compiler as ireec\n\ninput_mlir = \"\"\"\nfunc.func @abs(%input : tensor&lt;f32&gt;) -&gt; (tensor&lt;f32&gt;) {\n%result = math.absf %input : tensor&lt;f32&gt;\n  return %result : tensor&lt;f32&gt;\n}\"\"\"\n\ncompiled_module = ireec.tools.compile_str(\n    input_mlir,\n    target_backends=[\"llvm-cpu\"],\nextra_args=[\"--mlir-timing\"])\n</code></pre>"},{"location":"developers/general/developer-tips/#inspecting-vmfb-files","title":"Inspecting <code>.vmfb</code> files","text":"<p>The IREE compiler generates FlatBuffer files using the <code>.vmfb</code> file extension, short for \"Virtual Machine FlatBuffer\", which can then be loaded and executed using IREE's runtime.</p> Info - other output formats <p>The IREE compiler can output different formats with the <code>`--output-format=</code> flag:</p> Flag value Output <code>--output-format=vm-bytecode</code> (default) VM Bytecode (<code>.vmfb</code>) files <code>--output-format=vm-c</code> C source modules <p>VM Bytecode files are usable across a range of deployment scenarios, while C source modules provide low level connection points for constrained environments like bare metal platforms.</p> <p>By default, <code>.vmfb</code> files can be opened as zip files: (1)</p> <ol> <li>Setting <code>--iree-vm-emit-polyglot-zip=false</code> will disable this feature and    decrease file size slightly</li> </ol> <pre><code>$ unzip -d simple_abs_cpu ./simple_abs_cpu.vmfb\n\nArchive:  ./simple_abs_cpu.vmfb\n  extracting: simple_abs_cpu/module.fb\n  extracting: simple_abs_cpu/abs_dispatch_0_system_elf_x86_64.so\n</code></pre> <p>The embedded binary (here an ELF shared object with CPU code) can be parsed by standard tools:</p> <pre><code>$ readelf -Ws ./simple_abs_cpu/abs_dispatch_0_system_elf_x86_64.so\n\nSymbol table '.dynsym' contains 2 entries:\n  Num:    Value          Size Type    Bind   Vis      Ndx Name\n    0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n    1: 0000000000001760    17 FUNC    GLOBAL DEFAULT    7 iree_hal_executable_library_query\n\nSymbol table '.symtab' contains 42 entries:\n  Num:    Value          Size Type    Bind   Vis      Ndx Name\n    0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n    1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS abs_dispatch_0\n    2: 0000000000001730    34 FUNC    LOCAL  DEFAULT    7 abs_dispatch_0_generic\n    3: 00000000000034c0    80 OBJECT  LOCAL  DEFAULT    8 iree_hal_executable_library_query_v0\n    4: 0000000000001780   111 FUNC    LOCAL  DEFAULT    7 iree_h2f_ieee\n    5: 00000000000017f0   207 FUNC    LOCAL  DEFAULT    7 iree_f2h_ieee\n    ...\n</code></pre> <p>The <code>iree-dump-module</code> tool can also be used to see information about a given <code>.vmfb</code> file:</p> <pre><code>$ iree-dump-module simple_abs.vmfb\n\n//===---------------------------------------------------------------------===//\n// @module : version 0\n//===---------------------------------------------------------------------===//\n\nRequired Types:\n  [  0] i32\n  [  1] i64\n  [  2] !hal.allocator\n  [  3] !hal.buffer\n  ...\n\nModule Dependencies:\n  hal, version &gt;= 0, required\n\nImported Functions:\n  [  0] hal.ex.shared_device() -&gt; (!vm.ref&lt;?&gt;)\n  [  1] hal.allocator.allocate(!vm.ref&lt;?&gt;, i32, i32, i64) -&gt; (!vm.ref&lt;?&gt;)\n  ...\n\nExported Functions:\n  [  0] abs(!vm.ref&lt;?&gt;) -&gt; (!vm.ref&lt;?&gt;)\n  [  1] __init() -&gt; ()\n\n...\n</code></pre>"},{"location":"developers/general/developer-tips/#dumping-executable-files","title":"Dumping executable files","text":"<p>The <code>--iree-hal-dump-executable-*</code> flags instruct the compiler to save files related to \"executable translation\" (code generation for a specific hardware target) into a directory of your choosing. If you are interested in seeing which operations in your input program were fused into a compute kernel or what device code was generated for a given program structure, these flags are a great starting point.</p> Flag Files dumped <code>iree-hal-dump-executable-files-to</code> All files (meta-flag) <code>iree-hal-dump-executable-sources-to</code> Source <code>.mlir</code> files prior to HAL compilation <code>iree-hal-dump-executable-intermediates-to</code> Intermediate files (e.g. <code>.o</code> files, <code>.mlir</code> stages) <code>iree-hal-dump-executable-binaries-to</code> Binary files (e.g. <code>.so</code>, <code>.spv</code>, <code>.ptx</code>), as used in the <code>.vmfb</code> <code>iree-hal-dump-executable-benchmarks-to</code> Standalone benchmark files for <code>iree-benchmark-module</code> CPUGPU - VulkanGPU - CUDA <pre><code>$ mkdir -p /tmp/iree/simple_abs/\n\n$ iree-compile simple_abs.mlir \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-llvmcpu-link-embedded=false \\\n--iree-hal-dump-executable-files-to=/tmp/iree/simple_abs \\\n-o /tmp/iree/simple_abs/simple_abs_cpu.vmfb\n\n$ ls /tmp/iree/simple_abs\n\nmodule_abs_dispatch_0.mlir\nmodule_abs_dispatch_0_system_elf_x86_64_benchmark.mlir\nmodule_abs_dispatch_0_system_elf_x86_64.codegen.bc\nmodule_abs_dispatch_0_system_elf_x86_64.linked.bc\nmodule_abs_dispatch_0_system_elf_x86_64.optimized.bc\nmodule_abs_dispatch_0_system_elf_x86_64.o\nmodule_abs_dispatch_0_system_elf_x86_64.s\nmodule_abs_dispatch_0_system_elf_x86_64.so\nsimple_abs_cpu.vmfb\n</code></pre> <p>Tip - Embedded and system linking</p> <p>The default value of <code>--iree-llvmcpu-link-embedded=true</code> generates embedded ELF files. By disabling that flag, the compiler will produce platform-standard <code>.so</code> files for Linux, <code>.dll</code> files for Windows, etc. While embedded ELF files can be smaller and more portable, inspection of artifacts is easier with platform-standard shared object files.</p> Tip - Disassembling <code>.bc</code> files with <code>llvm-dis</code> <p>The <code>.bc</code> intermediate files use the LLVM BitCode format, which can be disassembled using <code>llvm-dis</code>:</p> <pre><code>// Build `llvm-dis` from source as needed:\n$ cmake --build iree-build/ --target llvm-dis\n$ iree-build/llvm-project/bin/llvm-dis --help\n\n$ cd /tmp/iree/simple_abs/\n$ llvm-dis module_abs_dispatch_0_system_elf_x86_64.codegen.bc\n$ cat module_abs_dispatch_0_system_elf_x86_64.codegen.ll\n\n; ModuleID = 'module_abs_dispatch_0_system_elf_x86_64.codegen.bc'\nsource_filename = \"abs_dispatch_0\"\ntarget triple = \"x86_64-linux-gnu\"\n\n%iree_hal_executable_library_header_t = type { i32, ptr, i32, i32 }\n%iree_hal_executable_dispatch_attrs_v0_t = type { i16, i16 }\n\n...\n\ndefine internal i32 @abs_dispatch_0_generic(\n    ptr noalias nonnull align 16 %0,\n    ptr noalias nonnull align 16 %1,\n    ptr noalias nonnull align 16 %2) #0 {\n  %4 = load %iree_hal_executable_dispatch_state_v0_t, ptr %1, align 8,\n  %5 = extractvalue %iree_hal_executable_dispatch_state_v0_t %4, 10,\n  %6 = load ptr, ptr %5, align 8,\n  %7 = ptrtoint ptr %6 to i64,\n  %8 = and i64 %7, 63,\n  %9 = icmp eq i64 %8, 0,\n  call void @llvm.assume(i1 %9),\n  %10 = load %iree_hal_executable_dispatch_state_v0_t, ptr %1, align 8,\n  %11 = extractvalue %iree_hal_executable_dispatch_state_v0_t %10, 10,\n  %12 = getelementptr ptr, ptr %11, i32 1,\n  %13 = load ptr, ptr %12, align 8,\n  %14 = ptrtoint ptr %13 to i64,\n  %15 = and i64 %14, 63,\n  %16 = icmp eq i64 %15, 0,\n  call void @llvm.assume(i1 %16),\n  %17 = load float, ptr %6, align 4,\n  %18 = call float @llvm.fabs.f32(float %17),\n  store float %18, ptr %13, align 4,\n  ret i32 0,\n}\n\n...\n</code></pre> <pre><code>$ mkdir -p /tmp/iree/simple_abs/\n\n$ iree-compile simple_abs.mlir \\\n--iree-hal-target-backends=vulkan-spirv \\\n--iree-hal-dump-executable-files-to=/tmp/iree/simple_abs \\\n-o /tmp/iree/simple_abs/simple_abs_vulkan.vmfb\n\n$ ls /tmp/iree/simple_abs\n\nmodule_abs_dispatch_0.mlir\nmodule_abs_dispatch_0_vulkan_spirv_fb_benchmark.mlir\nmodule_abs_dispatch_0_vulkan_spirv_fb.mlir\nmodule_abs_dispatch_0_vulkan_spirv_fb.spv\nsimple_abs_vulkan.vmfb\n</code></pre> Tip - Disassembling <code>.spv</code> files with <code>spirv-dis</code> <p>The <code>.spv</code> files use the SPIR-V binary format, which can be disassembled using <code>spirv-dis</code> from SPIR-V Tools:</p> <pre><code>$ cd /tmp/iree/simple_abs/\n$ spirv-dis module_abs_dispatch_0_vulkan_spirv_fb.spv\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos; 22\n; Bound: 20\n; Schema: 0\n              OpCapability Shader\n              OpExtension \"SPV_KHR_storage_buffer_storage_class\"\n        %18 = OpExtInstImport \"GLSL.std.450\"\n              OpMemoryModel Logical GLSL450\n              OpEntryPoint GLCompute %abs_dispatch_0_generic \"abs_dispatch_0_generic\"\n              OpExecutionMode %abs_dispatch_0_generic LocalSize 1 1 1\n              OpName %__resource_var_0_0_ \"__resource_var_0_0_\"\n              OpName %__resource_var_0_1_ \"__resource_var_0_1_\"\n              OpName %abs_dispatch_0_generic \"abs_dispatch_0_generic\"\n              OpDecorate %_arr_float_uint_1 ArrayStride 4\n              OpMemberDecorate %_struct_2 0 Offset 0\n              OpDecorate %_struct_2 Block\n              OpDecorate %__resource_var_0_0_ Binding 0\n              OpDecorate %__resource_var_0_0_ DescriptorSet 0\n              OpDecorate %__resource_var_0_1_ Binding 1\n              OpDecorate %__resource_var_0_1_ DescriptorSet 0\n      %float = OpTypeFloat 32\n      %uint = OpTypeInt 32 0\n    %uint_1 = OpConstant %uint 1\n%_arr_float_uint_1 = OpTypeArray %float %uint_1\n  %_struct_2 = OpTypeStruct %_arr_float_uint_1\n%_ptr_StorageBuffer__struct_2 = OpTypePointer StorageBuffer %_struct_2\n%__resource_var_0_0_ = OpVariable %_ptr_StorageBuffer__struct_2 StorageBuffer\n%__resource_var_0_1_ = OpVariable %_ptr_StorageBuffer__struct_2 StorageBuffer\n      %void = OpTypeVoid\n          %9 = OpTypeFunction %void\n    %uint_0 = OpConstant %uint 0\n%_ptr_StorageBuffer_float = OpTypePointer StorageBuffer %float\n%abs_dispatch_0_generic = OpFunction %void None %9\n        %12 = OpLabel\n        %15 = OpAccessChain %_ptr_StorageBuffer_float %__resource_var_0_0_ %uint_0 %uint_0\n        %16 = OpLoad %float %15\n        %17 = OpExtInst %float %18 FAbs %16\n        %19 = OpAccessChain %_ptr_StorageBuffer_float %__resource_var_0_1_ %uint_0 %uint_0\n              OpStore %19 %17\n              OpReturn\n              OpFunctionEnd\n</code></pre> <pre><code>$ mkdir -p /tmp/iree/simple_abs/\n\n$ iree-compile simple_abs.mlir \\\n--iree-hal-target-backends=cuda \\\n--iree-hal-dump-executable-files-to=/tmp/iree/simple_abs \\\n-o /tmp/iree/simple_abs/simple_abs_cuda.vmfb\n\n$ ls /tmp/iree/simple_abs\n\nmodule_abs_dispatch_0_cuda_nvptx_fb_benchmark.mlir\nmodule_abs_dispatch_0_cuda_nvptx_fb.codegen.bc\nmodule_abs_dispatch_0_cuda_nvptx_fb.linked.bc\nmodule_abs_dispatch_0_cuda_nvptx_fb.optimized.bc\nmodule_abs_dispatch_0_cuda_nvptx_fb.ptx\nmodule_abs_dispatch_0.mlir\nsimple_abs_cuda.vmfb\n</code></pre> Tip - Disassembling <code>.bc</code> files with <code>llvm-dis</code> <p>The <code>.bc</code> intermediate files use the LLVM BitCode format, which can be disassembled using <code>llvm-dis</code>:</p> <pre><code>// Build `llvm-dis` from source as needed:\n$ cmake --build iree-build/ --target llvm-dis\n$ iree-build/llvm-project/bin/llvm-dis --help\n\n$ cd /tmp/iree/simple_abs/\n$ llvm-dis module_abs_dispatch_0_cuda_nvptx_fb.codegen.bc\n$ cat module_abs_dispatch_0_cuda_nvptx_fb.codegen.ll\n\n; ModuleID = 'module_abs_dispatch_0_cuda_nvptx_fb.codegen.bc'\nsource_filename = \"abs_dispatch_0\"\n\ndeclare ptr @malloc(i64)\n\ndeclare void @free(ptr)\n\ndeclare float @__nv_fabsf(float)\n\ndefine void @abs_dispatch_0_generic(ptr noalias readonly align 16 %0, ptr noalias align 16 %1) {\n  %3 = ptrtoint ptr %0 to i64\n  %4 = and i64 %3, 63\n  %5 = icmp eq i64 %4, 0\n  call void @llvm.assume(i1 %5)\n  %6 = ptrtoint ptr %1 to i64\n  %7 = and i64 %6, 63\n  %8 = icmp eq i64 %7, 0\n  call void @llvm.assume(i1 %8)\n  %9 = load float, ptr %0, align 4\n  %10 = call float @__nv_fabsf(float %9)\n  store float %10, ptr %1, align 4\n  ret void\n}\n\n!nvvm.annotations = !{!0, !1, !2, !3}\n\n!0 = !{ptr @abs_dispatch_0_generic, !\"kernel\", i32 1}\n!1 = !{ptr @abs_dispatch_0_generic, !\"maxntidx\", i32 1}\n!2 = !{ptr @abs_dispatch_0_generic, !\"maxntidy\", i32 1}\n!3 = !{ptr @abs_dispatch_0_generic, !\"maxntidz\", i32 1}\n</code></pre>"},{"location":"developers/general/developer-tips/#compiling-phase-by-phase","title":"Compiling phase by phase","text":"<p>IREE compiles programs through a series of broad phases:</p> <pre><code>graph LR\n  accTitle: Compilation phases overview\n  accDescr: Input to ABI to Flow to Stream to HAL to VM\n\n  A([Input])\n  A --&gt; B([ABI])\n  B --&gt; C([Flow])\n  C --&gt; D([Stream])\n  D --&gt; E([HAL])\n  E --&gt; F([VM])</code></pre> Tip - available phases <p>These are the phase names available for use with the <code>--compile-to</code> and <code>--compile-from</code> flags described below:</p> Phase name Description <code>input</code> Performs input processing and lowering into core IREE input dialects (linalg/etc) <code>abi</code> Adjusts the program ABI for the specified execution environment <code>preprocessing</code> Applies customizable <code>preprocessing</code> prior to FLow/Stream/HAL/VM <code>flow</code> Models execution data flow and partitioning using the <code>flow</code> dialect <code>stream</code> Models execution partitioning and scheduling using the <code>stream</code> dialect <code>executable-sources</code> Prepares <code>hal</code> dialect executables for translation, prior to codegen <code>executable-targets</code> Runs code generation for <code>hal</code> dialect executables <code>hal</code> Finishes <code>hal</code> dialect processing <code>vm</code> Lowers to IREE's abstract virtual machine using the <code>vm</code> dialect <code>end</code> Completes the full compilation pipeline <p>For an accurate list of phases, see the source code or check the help output with a command such as:</p> <pre><code>iree-compile --help | sed -n '/--compile-to/,/--/p' | head -n -1\n</code></pre> <p>You can output a program snapshot at intermediate phases with the <code>--compile-to=&lt;phase name&gt;</code> flag:</p> <pre><code>$ cat simple_abs.mlir\n\nfunc.func @abs(%input : tensor&lt;f32&gt;) -&gt; (tensor&lt;f32&gt;) {\n  %result = math.absf %input : tensor&lt;f32&gt;\n  return %result : tensor&lt;f32&gt;\n}\n\n$ iree-compile simple_abs.mlir --compile-to=abi\n\nmodule {\n  func.func @abs(%arg0: !hal.buffer_view) -&gt; !hal.buffer_view attributes {iree.abi.stub} {\n    %0 = hal.tensor.import %arg0 \"input 0\" : !hal.buffer_view -&gt; tensor&lt;f32&gt;\n    %1 = math.absf %0 : tensor&lt;f32&gt;\n    %2 = hal.tensor.export %1 \"output 0\" : tensor&lt;f32&gt; -&gt; !hal.buffer_view\n    return %2 : !hal.buffer_view\n  }\n}\n</code></pre> <p>This is similar to the <code>--mlir-print-ir-after=</code> flag, but at clearly defined pipeline phases.</p> <p>Compilation can be continued from any intermediate phase. This allows for interative workflows - compile to a phase, make edits to the <code>.mlir</code> file, then resume compilation and continue through the pipeline:</p> <pre><code>$ iree-compile simple_abs.mlir --compile-to=abi -o simple_abs_abi.mlir\n\n$ sed \\\n-e 's/math.absf/math.exp/' \\\n-e 's/@abs/@exp/' \\\nsimple_abs_abi.mlir &gt; simple_exp_abi.mlir\n\n$ iree-compile simple_exp_abi.mlir \\\n--iree-hal-target-backends=llvm-cpu \\\n-o simple_exp_cpu.vmfb\n</code></pre> <p>or explicitly resume from an intermediate phase with <code>--compile-from=&lt;phase name&gt;</code>:</p> <pre><code>$ iree-compile simple_exp_abi.mlir \\\n--iree-hal-target-backends=llvm-cpu \\\n--compile-from=abi \\\n-o simple_exp_cpu.vmfb\n</code></pre>"},{"location":"developers/general/release-management/","title":"Release management","text":"<p>IREE cuts automated releases via a workflow that is triggered daily. The only constraint placed on the commit that is released is that it has passed all CI checks. These are published on GitHub with the \"pre-release\" status. For debugging this process, see the Release debugging playbook.</p> <p>We periodically promote one of these candidates to a \"stable\" release by removing the \"pre-release\" status. This makes it show up as a \"latest\" release on GitHub. We also push the Python packages for this release to PyPI.</p>"},{"location":"developers/general/release-management/#picking-a-candidate-to-promote","title":"Picking a candidate to promote","text":"<p>When selecting a candidate we use the following criteria:</p> <ol> <li>\u2a864 days old so that problems with it may have been spotted</li> <li>Contains no P0 regressions vs the previous stable release</li> <li>LLVM submodule commit ideally exists upstream (no cherry picks or patches)</li> </ol> <p>When you've identified a potential candidate, email the iree-discuss list with the proposal and solicit feedback. People may point out known regressions or request that some feature make the cut.</p>"},{"location":"developers/general/release-management/#promoting-a-candidate-to-stable","title":"Promoting a candidate to stable","text":"<ol> <li> <p>(Authorized users only) Push to PyPI using     pypi_deploy.sh</p> <ul> <li>For Googlers, the password is stored at http://go/iree-pypi-password</li> </ul> </li> <li> <p>Open the release on GitHub. Rename the release from \"candidate\" to \"stable\",     uncheck the option for \"pre-release\", and check the option for \"latest\".</p> <p></p> <p></p> </li> </ol>"},{"location":"developers/general/testing-guide/","title":"Testing guide","text":"<p>Like the IREE project in general, IREE tests are divided into a few different components and use different tooling depending on the needs of that component.</p> Test type Test Build system Supported platforms Compiler tests iree_lit_test Bazel/CMake Host Runtime tests iree_cc_test Bazel/CMake Host/Device iree_native_test Bazel/CMake Host/Device iree_hal_cts_test_suite CMake Host/Device Core E2E tests iree_check_test Bazel/CMake Host/Device iree_trace_runner_test Bazel/CMake Host/Device iree_generated_trace_runner_test Bazel/CMake Host/Device iree_static_linker_test CMake Host/Device <p>There are also more <code>*_test_suite</code> targets that groups test targets with the same configuration together.</p>"},{"location":"developers/general/testing-guide/#compiler-tests","title":"Compiler tests","text":"<p>Tests for the IREE compilation pipeline are written as lit tests in the same style as MLIR.</p> <p>By convention, IREE includes tests for</p> <ul> <li>printing and parsing of ops in <code>.../IR/test/{OP_CATEGORY}_ops.mlir</code> files</li> <li>folding and canonicalization in <code>.../IR/test/{OP_CATEGORY}_folding.mlir</code> files</li> <li>compiler passes and pipelines in other <code>.../test/*.mlir</code> files</li> </ul>"},{"location":"developers/general/testing-guide/#running-a-test","title":"Running a test","text":"<p>For the test <code>iree/compiler/Dialect/VM/Conversion/MathToVM/test/arithmetic_ops.mlir</code></p> <p>With CMake, run this from the build directory:</p> <pre><code>ctest -R iree/compiler/Dialect/VM/Conversion/MathToVM/test/arithmetic_ops.mlir.test\n</code></pre> <p>With Bazel, run this from the repo root:</p> <pre><code>bazel test //compiler/src/iree/compiler/Dialect/VM/Conversion/MathToVM/test:arithmetic_ops.mlir.test\n</code></pre>"},{"location":"developers/general/testing-guide/#writing-a-test","title":"Writing a test","text":"<p>For advice on writing MLIR compiler tests, see the MLIR testing guide. Tests should be <code>.mlir</code> files in <code>test</code> directory adjacent to the functionality they are testing. Instead of <code>mlir-opt</code>, use <code>iree-opt</code>, which registers IREE dialects and passes and doesn't register some unnecessary core ones.</p> <p>As with most parts of the IREE compiler, these should not have a dependency on the runtime.</p>"},{"location":"developers/general/testing-guide/#configuring-the-build-system","title":"Configuring the build system","text":"<p>In the Bazel BUILD file, create a <code>iree_lit_test_suite</code> rule. We usually create a single suite that globs all <code>.mlir</code> files in the directory and is called \"lit\".</p> <pre><code>load(\"//iree/build_tools/bazel:iree_lit_test.bzl\", \"iree_lit_test_suite\")\n\niree_lit_test_suite(\n    name = \"lit\",\n    srcs = glob([\"*.mlir\"]),\n    tools = [\n        \"@llvm-project//llvm:FileCheck\",\n        \"//tools:iree-opt\",\n    ],\n)\n</code></pre> <p>There is a corresponding CMake function, calls to which will be generated by our Bazel to CMake converter.</p> <pre><code>iree_lit_test_suite(\nNAME\nlit\nSRCS\n\"arithmetic_ops.mlir\"\nDATA\nFileCheck\niree-opt\n)\n</code></pre> <p>You can also create a test for a single file with <code>iree_lit_test</code>.</p>"},{"location":"developers/general/testing-guide/#runtime-tests","title":"Runtime tests","text":"<p>Tests for the runtime C++ code use the GoogleTest testing framework. They should generally follow the style and best practices of that framework.</p>"},{"location":"developers/general/testing-guide/#running-a-test_1","title":"Running a test","text":"<p>For the test <code>/runtime/src/iree/base/bitfield_test.cc</code>:</p> <p>With CMake, run this from the build directory:</p> <pre><code>ctest -R iree/base/bitfield_test\n</code></pre> <p>With Bazel, run this from the repo root:</p> <pre><code>bazel test //runtime/src/iree/base:arena_test\n</code></pre>"},{"location":"developers/general/testing-guide/#setting-test-environments","title":"Setting test environments","text":"<p>Parallel testing for <code>ctest</code> can be enabled via the <code>CTEST_PARALLEL_LEVEL</code> environment variable. For example:</p> <pre><code>export CTEST_PARALLEL_LEVEL=$(nproc)\n</code></pre> <p>To use the Vulkan backend as test driver, you may need to select between a Vulkan implementation from SwiftShader and multiple Vulkan-capable hardware devices. This can be done via environment variables. See the generic Vulkan setup page for details regarding these variables.</p> <p>For Bazel, you can persist the configuration in <code>user.bazelrc</code> to save typing. For example:</p> <pre><code>test:vkswiftshader --test_env=\"LD_LIBRARY_PATH=...\"\ntest:vkswiftshader --test_env=\"VK_LAYER_PATH=...\"\ntest:vknative --test_env=\"LD_LIBRARY_PATH=...\"\ntest:vknative --test_env=\"VK_LAYER_PATH=...\"\n</code></pre> <p>Then you can use <code>bazel test --config=vkswiftshader</code> to select SwiftShader as the Vulkan implementation. Similarly for other implementations.</p>"},{"location":"developers/general/testing-guide/#writing-a-test_1","title":"Writing a test","text":"<p>For advice on writing tests in the GoogleTest framework, see the GoogleTest primer. Test files for source file <code>foo.cc</code> with build target <code>foo</code> should live in the same directory with source file <code>foo_test.cc</code> and build target <code>foo_test</code>. You should <code>#include</code> <code>iree/testing/gtest.h</code> instead of any of the gtest or gmock headers.</p> <p>As with all parts of the IREE runtime, these should not have a dependency on the compiler.</p>"},{"location":"developers/general/testing-guide/#configuring-the-build-system_1","title":"Configuring the build system","text":"<p>In the Bazel BUILD file, create a <code>cc_test</code> target with your test file as the source and any necessary dependencies. Usually, you can link in a standard gtest main function. Use <code>iree/testing:gtest_main</code> instead of the <code>gtest_main</code> that comes with gtest.</p> <pre><code>cc_test(\n    name = \"arena_test\",\n    srcs = [\"arena_test.cc\"],\n    deps = [\n        \":arena\",\n        \"//iree/testing:gtest_main\",\n    ],\n)\n</code></pre> <p>We have created a corresponding CMake function <code>iree_cc_test</code> that mirrors the Bazel rule's behavior. Our Bazel to CMake converter should generally derive the <code>CMakeLists.txt</code> file from the BUILD file:</p> <pre><code>iree_cc_test(\nNAME\narena_test\nSRCS\n\"arena_test.cc\"\nDEPS\n::arena\niree::testing::gtest_main\n)\n</code></pre> <p>There are other more specific test targets, such as <code>iree_hal_cts_test_suite</code>, which are designed to test specific runtime support with template configuration and is not supported by Bazel rules.</p>"},{"location":"developers/general/testing-guide/#iree-core-end-to-end-e2e-tests","title":"IREE core end-to-end (e2e) tests","text":"<p>Here \"end-to-end\" means from the input accepted by the IREE core compiler (dialects like TOSA, StableHLO, Linalg) to execution using the IREE runtime components. It does not include tests of the integrations with ML frameworks (e.g. TensorFlow, PyTorch) or bindings to other languages (e.g. Python).</p> <p>We avoid using the more traditional <code>lit</code> tests used elsewhere in the compiler for runtime execution tests. Lit tests require running the compiler tools on the test platform through shell or python scripts that act on files from a local file system. On platforms like Android, the web, and embedded systems, each of these features is either not available or is severely limited.</p> <p>Instead, to test these flows we use a custom framework called <code>check</code>. The check framework compiles test programs on the host machine into standalone test binary files that can be pushed to test devices (such as Android phones) where they run with gtest style assertions (e.g. <code>check.expect_almost_eq(lhs, rhs)</code>).</p>"},{"location":"developers/general/testing-guide/#building-e2e-tests","title":"Building e2e tests","text":"<p>The files needed by these tests are not built by default with CMake. You'll need to build the special <code>iree-test-deps</code> target to generate test files prior to running CTest (from the build directory):</p> <pre><code>cmake --build . --target iree-test-deps\n</code></pre> <p>To run e2e model tests in generated_e2e_model_tests.cmake, because of their dependencies, <code>-DIREE_BUILD_E2E_TEST_ARTIFACTS=ON</code> needs to be set when configuring CMake. Also see IREE Benchmark Suite Prerequisites for required packages.</p>"},{"location":"developers/general/testing-guide/#running-a-test_2","title":"Running a Test","text":"<p>For the test <code>tests/e2e/xla_ops/floor.mlir</code> compiled for the VMVX target backend and running on the VMVX driver (here they match exactly, but in principle there's a many-to-many mapping from backends to drivers).</p> <p>With CMake, run this from the build directory:</p> <pre><code>ctest -R tests/e2e/xla_ops/check_vmvx_local-task_floor.mlir\n</code></pre> <p>With Bazel, run this from the repo root:</p> <pre><code>bazel test tests/e2e/xla_ops:check_vmvx_local-task_floor.mlir\n</code></pre>"},{"location":"developers/general/testing-guide/#setting-test-environments_1","title":"Setting test environments","text":"<p>Similarly, you can use environment variables to select Vulkan implementations for running tests as explained in the Runtime tests section.</p>"},{"location":"developers/general/testing-guide/#writing-a-test_2","title":"Writing a test","text":"<p>These tests live in <code>tests/e2e</code>. A single test consists of a <code>.mlir</code> source file specifying an IREE module where each exported function takes no inputs and returns no results and corresponds to a single test case.</p> <p>As an example, here are some tests for the MHLO floor operation:</p> <pre><code>func.func @tensor() {\n  %input = util.unfoldable_constant dense&lt;[0.0, 1.1, 2.5, 4.9]&gt; : tensor&lt;4xf32&gt;\n  %result = \"mhlo.floor\"(%input) : (tensor&lt;4xf32&gt;) -&gt; tensor&lt;4xf32&gt;\n  check.expect_almost_eq_const(%result, dense&lt;[0.0, 1.0, 2.0, 4.0]&gt; : tensor&lt;4xf32&gt;): tensor&lt;4xf32&gt;\n  return\n}\n\nfunc.func @scalar() {\n  %input = util.unfoldable_constant dense&lt;101.3&gt; : tensor&lt;f32&gt;\n  %result = \"mhlo.floor\"(%input) : (tensor&lt;f32&gt;) -&gt; tensor&lt;f32&gt;\n  check.expect_almost_eq_const(%result, dense&lt;101.0&gt; : tensor&lt;f32&gt;): tensor&lt;f32&gt;\n  return\n}\n\nfunc.func @negative() {\n  %input = util.unfoldable_constant dense&lt;-1.1&gt; : tensor&lt;f32&gt;\n  %result = \"mhlo.floor\"(%input) : (tensor&lt;f32&gt;) -&gt; tensor&lt;f32&gt;\n  check.expect_almost_eq_const(%result, dense&lt;-2.0&gt; : tensor&lt;f32&gt;): tensor&lt;f32&gt;\n  return\n}\n</code></pre> <p>Test cases are created in gtest for each public function exported by the module.</p> <p>Note the use of <code>util.unfoldable_constant</code> to specify test constants. If we were to use a regular constant the compiler would fold away everything at compile time and our test would not actually test the runtime. <code>unfoldable_constant</code> adds a barrier that prevents folding. To prevent folding/constant propagate on an arbitrary SSA-value you can use <code>util.optimization_barrier</code>.</p> <p>Next we use this input constant to exercise the runtime feature under test (in this case, just a single floor operation). Finally, we use a check dialect operation to make an assertion about the output. There are a few different assertion operations. Here we use the <code>expect_almost_eq_const</code> op: almost because we are comparing floats and want to allow for floating-point imprecision, and const because we want to compare it to a constant value. This last part is just syntactic sugar around</p> <pre><code>%expected = arith.constant dense&lt;101.0&gt; : tensor&lt;f32&gt;\ncheck.expect_almost_eq(%result, %expected) : tensor&lt;f32&gt;\n</code></pre> <p>The output of running this test looks like:</p> <pre><code>[==========] Running 4 tests from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 4 tests from module\n[ RUN      ] module.tensor\n[       OK ] module.tensor (76 ms)\n[ RUN      ] module.scalar\n[       OK ] module.scalar (79 ms)\n[ RUN      ] module.double\n[       OK ] module.double (55 ms)\n[ RUN      ] module.negative\n[       OK ] module.negative (54 ms)\n[----------] 4 tests from module (264 ms total)\n\n[----------] Global test environment tear-down\n[==========] 4 tests from 1 test suite ran. (264 ms total)\n[  PASSED  ] 4 tests.\n</code></pre> <p>The \"module\" name for the test suite comes from the default name for an implicit MLIR module. To give the test suite a more descriptive name, use an explicit named top-level module in this file.</p>"},{"location":"developers/general/testing-guide/#configuring-the-build-system_2","title":"Configuring the build system","text":"<p>A single <code>.mlir</code> source file can be turned into a test target with the <code>iree_check_test</code> Bazel macro (and corresponding CMake function).</p> <pre><code>load(\"//build_tools/bazel:iree_check_test.bzl\", \"iree_check_test\")\n\niree_check_test(\n    name = \"check_vmvx_local-task_floor.mlir\",\n    src = \"floor.mlir\",\n    driver = \"local-task\",\n    target_backend = \"vmvx\",\n)\n</code></pre> <p>The target naming convention is \"check_backend_driver_src\". The generated test will automatically be tagged with a \"driver=vmvx\" tag, which can help filter tests by backend (especially when many tests are generated, as below).</p> <p>Usually we want to create a suite of tests across many backends and drivers. This can be accomplished with additional macros. For a single backend/driver pair:</p> <pre><code>load(\"//build_tools/bazel:iree_check_test.bzl\", \"iree_check_single_backend_test_suite\")\n\niree_check_single_backend_test_suite(\n    name = \"check_vmvx_local-task\",\n    srcs = glob([\"*.mlir\"]),\n    driver = \"local-task\",\n    target_backend = \"vmvx\",\n)\n</code></pre> <p>This will generate a separate test target for each file in <code>srcs</code> with a name following the convention above as well as a Bazel test_suite called \"check_vmvx_local-task\" that will run all the generated tests.</p> <p>You can also generate suites across multiple pairs:</p> <pre><code>load(\"//build_tools/bazel:iree_check_test.bzl\", \"iree_check_test_suite\")\n\niree_check_test_suite(\n    name = \"check\",\n    srcs = [\"success.mlir\"],\n    # Leave this argument off to run on all supported backend/driver pairs.\n    target_backends_and_drivers = [\n        (\"vmvx\", \"local-task\"),\n        (\"vulkan-spirv\", \"vulkan\"),\n    ],\n)\n</code></pre> <p>This will create a test per source file and backend/driver pair, a test suite per backend/driver pair, and a test suite, \"check\", that will run all the tests.</p> <p>The CMake functions follow a similar pattern. The calls to them are generated in our <code>CMakeLists.txt</code> file by bazel_to_cmake.</p> <p>There are other test targets that generate tests based on template configuraton and platform detection, such as <code>iree_static_linker_test</code>. Those targets are not supported by Bazel rules at this point.</p>"},{"location":"developers/performance/benchmark-suites/","title":"Benchmark suites","text":"<p>IREE Benchmarks Suites is a collection of benchmarks for IREE developers to track performance improvements/regressions during development.</p> <p>The benchmark suites are run for each commit on the main branch and the results are uploaded to https://perf.iree.dev for regression analysis (for the current supported targets). On pull requests, users can add labels <code>benchmarks:*</code> to trigger the benchmark runs. The results will be compared with https://perf.iree.dev and post in the comments.</p> <p>Information about the definitions of the benchmark suites can be found in the IREE Benchmark Suites Configurations.</p>"},{"location":"developers/performance/benchmark-suites/#running-benchmark-suites-locally","title":"Running benchmark suites locally","text":""},{"location":"developers/performance/benchmark-suites/#prerequisites","title":"Prerequisites","text":"<p>Install <code>iree-import-tf</code> and <code>iree-import-tflite</code> in your Python environment (see Tensorflow Integration and TFLite Integration).</p>"},{"location":"developers/performance/benchmark-suites/#choose-benchmark-presets","title":"Choose benchmark presets","text":"<p>IREE Benchmark Suites contain many benchmarks for different devices and model sizes, which can take lots of space and time to build all of them. So benchmarks are grouped into presets to allow building and running only a subset of them. The available presets are:</p> <p>Execution benchmarks:</p> <ul> <li><code>android-cpu</code>: benchmarks for mobile CPUs</li> <li><code>android-gpu</code>: benchmarks for mobile GPUs</li> <li><code>cuda</code>: benchmarks for CUDA with a small model set</li> <li><code>cuda-large</code>: benchmarks for CUDA with a large model set</li> <li><code>vulkan-nvidia</code>: benchmarks for Vulkan on NVIDIA graphics cards</li> <li><code>x86_64</code>: benchmarks for x86_64 CPUs with a small model set</li> <li><code>x86_64-large</code>: benchmarks for x86_64 with a large model set</li> </ul> <p>Compilation benchmarks (to collect compilation statistics, such as module sizes):</p> <ul> <li><code>comp-stats</code>: compilation benchmarks with a small model set</li> <li><code>comp-stats-large</code>: compilation benchmark with a large model set</li> </ul> <p>Note that <code>*-large</code> presets will download and build a few hundreds GBs of artifacts.</p> <p>Set the environment variables of benchmark presets for the steps below, for example:</p> <pre><code>export EXECUTION_BENCHMARK_PRESETS=\"cuda,x86_64\"\nexport COMPILATION_BENCHMARK_PRESETS=\"comp-stats\"\n</code></pre>"},{"location":"developers/performance/benchmark-suites/#build-benchmark-suites","title":"Build benchmark suites","text":"<p>Configure IREE with <code>-DIREE_BUILD_E2E_TEST_ARTIFACTS=ON</code>:</p> <pre><code>cmake -GNinja -B \"${IREE_BUILD_DIR?}\" -S \"${IREE_REPO?}\" \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DIREE_ENABLE_LLD=ON \\\n-DIREE_BUILD_E2E_TEST_ARTIFACTS=ON\n</code></pre> <p>If you only need the imported MLIR models:</p> <pre><code>cmake --build \"${IREE_BUILD_DIR?}\" --target \\\niree-benchmark-import-models\n  # For large benchmarks (this will take &gt; 100G disk space)\n# iree-benchmark-import-models-large\n</code></pre> <p>Otherwise, compile the benchmark suites and tools for benchmarking:</p> <pre><code>cmake --build \"${IREE_BUILD_DIR?}\" --target \\\niree-benchmark-suites \\\n# If any *-large preset is enabled, also build this target:\n# iree-benchmark-suites-large \\\niree-benchmark-module\nexport E2E_TEST_ARTIFACTS_DIR=\"${IREE_BUILD_DIR?}/e2e_test_artifacts\"\n</code></pre> <p>TODO(#13683): Each preset should have its own target to further reduce unnecessary builds</p>"},{"location":"developers/performance/benchmark-suites/#run-benchmarks","title":"Run benchmarks","text":"<p>Export the execution benchmark config:</p> <pre><code>build_tools/benchmarks/export_benchmark_config.py execution \\\n--benchmark_presets=\"${EXECUTION_BENCHMARK_PRESETS?}\" \\\n&gt; \"${E2E_TEST_ARTIFACTS_DIR?}/exec_config.json\"\n</code></pre> <p>Run benchmarks (currently only support running on a Linux host):</p> <pre><code>build_tools/benchmarks/run_benchmarks_on_linux.py \\\n--normal_benchmark_tool_dir=\"${IREE_BUILD_DIR?}/tools\" \\\n--e2e_test_artifacts_dir=\"${E2E_TEST_ARTIFACTS_DIR?}\" \\\n--execution_benchmark_config=\"${E2E_TEST_ARTIFACTS_DIR?}/exec_config.json\" \\\n--target_device_name=\"&lt;target_device_name, e.g. c2-standard-16&gt;\" \\\n--output=\"${E2E_TEST_ARTIFACTS_DIR?}/benchmark_results.json\" \\\n--verbose \\\n--cpu_uarch=\"&lt;host CPU uarch, e.g. CascadeLake&gt;\"\n# Traces can be collected by adding:\n# --traced_benchmark_tool_dir=\"${IREE_TRACED_BUILD_DIR?}/tools\" \\\n# --trace_capture_tool=/path/to/iree-tracy-capture \\\n# --capture_tarball=captured_tracy_files.tar.gz\n</code></pre> <p>Note that:</p> <ul> <li><code>&lt;target_device_name&gt;</code> selects a benchmark group targets a specific device:<ul> <li>Common options:<ul> <li><code>c2-standard-16</code> for x86_64 CPU benchmarks.</li> <li><code>a2-highgpu-1g</code> for NVIDIA GPU benchmarks.</li> </ul> </li> <li>All device names are defined under     build_tools/python/e2e_test_framework/device_specs.</li> </ul> </li> <li>To run x86_64 benchmarks, right now <code>--cpu_uarch</code> needs to be provided and     only <code>CascadeLake</code> is available currently.</li> <li>To build traced benchmark tools, see     Profiling with Tracy.</li> </ul> <p>Filters can be used to select the benchmarks:</p> <pre><code>build_tools/benchmarks/run_benchmarks_on_linux.py \\\n--normal_benchmark_tool_dir=\"${IREE_BUILD_DIR?}/tools\" \\\n--e2e_test_artifacts_dir=\"${E2E_TEST_ARTIFACTS_DIR?}\" \\\n--execution_benchmark_config=\"${E2E_TEST_ARTIFACTS_DIR?}/exec_config.json\" \\\n--target_device_name=\"c2-standard-16\" \\\n--output=\"${E2E_TEST_ARTIFACTS_DIR?}/benchmark_results.json\" \\\n--verbose \\\n--cpu_uarch=\"CascadeLake\" \\\n--model_name_regex=\"MobileBert*\" \\\n--driver_filter_regex='local-task' \\\n--mode_regex=\"4-thread\"\n</code></pre>"},{"location":"developers/performance/benchmark-suites/#generate-compilation-statistics-compilation-benchmarks","title":"Generate compilation statistics (compilation benchmarks)","text":"<p>Export the compilation benchmark config:</p> <pre><code>build_tools/benchmarks/export_benchmark_config.py compilation \\\n--benchmark_presets=\"${COMPILATION_BENCHMARK_PRESETS?}\" \\\n&gt; \"${E2E_TEST_ARTIFACTS_DIR?}/comp_config.json\"\n</code></pre> <p>Generate the compilation statistics:</p> <pre><code>build_tools/benchmarks/collect_compilation_statistics.py \\\n--compilation_benchmark_config=comp_config.json \\\n--e2e_test_artifacts_dir=\"${E2E_TEST_ARTIFACTS_DIR?}\" \\\n--build_log=\"${IREE_BUILD_DIR?}/.ninja_log\" \\\n--output=\"${E2E_TEST_ARTIFACTS_DIR?}/compile_stats_results.json\"\n</code></pre> <p>Note that you need to use Ninja to build the benchmark suites as the tool collects information from its build log.</p>"},{"location":"developers/performance/benchmark-suites/#show-execution-compilation-benchmark-results","title":"Show execution / compilation benchmark results","text":"<p>If you want to generate a comparison report locally, you can use diff_local_benchmarks.py script to compare two result json files and generate the report. For example:</p> <pre><code>build_tools/benchmarks/diff_local_benchmarks.py \\\n--base \"${E2E_TEST_ARTIFACTS_DIR?}/before_benchmark_results.json\" \\\n--target \"${E2E_TEST_ARTIFACTS_DIR?}/after_benchmark_results.json\" \\\n&gt; report.md\n</code></pre> <p>An example that compares compilation statistics:</p> <pre><code>build_tools/benchmarks/diff_local_benchmarks.py \\\n--base-compile-stats \"${E2E_TEST_ARTIFACTS_DIR?}/before_compile_stats_results.json\" \\\n--target-compile-stats \"${E2E_TEST_ARTIFACTS_DIR?}/after_compile_stats_results.json\" \\\n&gt; report.md\n</code></pre>"},{"location":"developers/performance/benchmark-suites/#find-compile-and-run-commands-to-reproduce-benchmarks","title":"Find compile and run commands to reproduce benchmarks","text":"<p>Each benchmark has its benchmark ID in the benchmark suites, you will see a benchmark ID at:</p> <ul> <li>In the serie's URL of https://perf.iree.dev<ul> <li>Execution benchmark: <code>https://perf.iree.dev/serie?IREE?&lt;benchmark_id&gt;</code></li> <li>Compilation benchmark:     <code>https://perf.iree.dev/serie?IREE?&lt;benchmark_id&gt;-&lt;metric_id&gt;</code></li> </ul> </li> <li>In <code>benchmark_results.json</code> and <code>compile_stats_results.json</code><ul> <li>Execution benchmark result has a field <code>run_config_id</code></li> <li>Compilation benchmark result has a field <code>gen_config_id</code></li> </ul> </li> <li>In PR benchmark summary or the markdown generated by     <code>diff_local_benchmarks.py</code>, each benchmark has the link to its     https://perf.iree.dev URL, which includes the benchmark ID.</li> </ul> <p>If you don't have artifacts locally, see Fetching Benchmark Artifacts from CI to find the GCS directory of the CI artifacts. Then fetch the needed files:</p> <pre><code># Get ${E2E_TEST_ARTIFACTS_DIR_URL} from \"Fetching Benchmark Artifacts from CI\".\nexport E2E_TEST_ARTIFACTS_DIR=\"e2e_test_artifacts\"\n\n# Download all artifacts\nmkdir \"${E2E_TEST_ARTIFACTS_DIR?}\"\ngcloud storage cp -r \"${E2E_TEST_ARTIFACTS_DIR_URL?}\" \"${E2E_TEST_ARTIFACTS_DIR?}\"\n</code></pre> <p>Run the helper tool to dump benchmark commands from benchmark configs:</p> <pre><code>build_tools/benchmarks/benchmark_helper.py dump-cmds \\\n--execution_benchmark_config=\"${E2E_TEST_ARTIFACTS_DIR?}/execution-benchmark-config.json\" \\\n--compilation_benchmark_config=\"${E2E_TEST_ARTIFACTS_DIR?}/compilation-benchmark-config.json\" \\\n--e2e_test_artifacts_dir=\"${E2E_TEST_ARTIFACTS_DIR?}\" \\\n--benchmark_id=\"&lt;benchmark_id&gt;\"\n</code></pre>"},{"location":"developers/performance/benchmark-suites/#get-full-list-of-benchmarks","title":"Get full list of benchmarks","text":"<p>The commands below output the full list of execution and compilation benchmarks, including the benchmark names and their flags:</p> <pre><code>build_tools/benchmarks/export_benchmark_config.py execution &gt; \"${E2E_TEST_ARTIFACTS_DIR?}/exec_config.json\"\nbuild_tools/benchmarks/export_benchmark_config.py compilation &gt; \"${E2E_TEST_ARTIFACTS_DIR?}/comp_config.json\"\nbuild_tools/benchmarks/benchmark_helper.py dump-cmds \\\n--execution_benchmark_config=\"${E2E_TEST_ARTIFACTS_DIR?}/exec_config.json\" \\\n--compilation_benchmark_config=\"${E2E_TEST_ARTIFACTS_DIR?}/comp_config.json\"\n</code></pre>"},{"location":"developers/performance/benchmark-suites/#fetching-benchmark-artifacts-from-ci","title":"Fetching benchmark Artifacts from CI","text":""},{"location":"developers/performance/benchmark-suites/#1-find-the-corresponding-ci-workflow-run","title":"1. Find the corresponding CI workflow run","text":"<p>On the commit of the benchmark run, you can find the list of the workflow jobs by clicking the green check mark. Click any job starts with <code>CI /</code>:</p> <p></p>"},{"location":"developers/performance/benchmark-suites/#2-get-urls-of-gcs-artifacts","title":"2. Get URLs of GCS artifacts","text":"<p>On the CI page, click <code>Summary</code> on the top-left to open the summary page. Scroll down and the links to artifacts are listed in a section titled \"Artifact Links\". Paste the content in your shell to define all needed variables for the following steps:</p> <p></p>"},{"location":"developers/performance/benchmark-suites/#3-fetch-the-benchmark-artifacts","title":"3. Fetch the benchmark artifacts","text":"<p>To fetch files from the GCS URL, the gcloud CLI tool (https://cloud.google.com/sdk/docs/install) can list the directory contents and download files (see https://cloud.google.com/sdk/gcloud/reference/storage for more usages). If you want to use CI artifacts to reproduce benchmarks locally, see Find Compile and Run Commands to Reproduce Benchmarks.</p> <p>Assume you get the GCS URL variables from Get URLs of GCS artifacts.</p> <p>Download artifacts:</p> <pre><code># The GCS directory has the same structure as your local ${IREE_BUILD_DIR?}/e2e_test_artifacts.\ngcloud storage ls \"${E2E_TEST_ARTIFACTS_DIR_URL?}\"\n\n# Download all source and imported MLIR files:\ngcloud storage cp \"${E2E_TEST_ARTIFACTS_DIR_URL?}/*.mlir\" \"&lt;target_dir&gt;\"\n</code></pre> <p>Execution and compilation benchmark configs can be downloaded at:</p> <pre><code># Execution benchmark config:\ngcloud storage cp \\\n\"${E2E_TEST_ARTIFACTS_DIR_URL?}/execution-benchmark-config.json\" \\\n\"${E2E_TEST_ARTIFACTS_DIR?}/exec_config.json\"\n\n# Compilation benchmark config:\ngcloud storage cp \\\n\"${E2E_TEST_ARTIFACTS_DIR_URL?}/compilation-benchmark-config.json\" \\\n\"${E2E_TEST_ARTIFACTS_DIR?}/comp_config.json\"\n</code></pre> <p>Benchmark raw results and traces can be downloaded at:</p> <pre><code># Execution benchmark raw results\ngcloud storage cp \"${EXECUTION_BENCHMARK_RESULTS_DIR_URL?}/benchmark-results-*.json\" .\n\n# Optional: Merge raw results into a single file\nbuild_tools/benchmarks/benchmark_helper.py merge-results benchmark-results-*.json &gt; benchmark_results.json\n\n# Execution benchmark traces\ngcloud storage cp \"${EXECUTION_BENCHMARK_RESULTS_DIR_URL?}/benchmark-traces-*.tar.gz\" .\n\n# Compilation benchmark results\ngcloud storage cp \"${COMPILATION_BENCHMARK_RESULTS_URL?}\" .\n</code></pre>"},{"location":"developers/performance/benchmarking/","title":"Benchmarking","text":"<p>IREE uses benchmarks to inspect performance at varying levels of granularity. Benchmarking is implemented using the Google Benchmark library. To understand performance details and guide optimization, please refer to the IREE profiling documentation.</p>"},{"location":"developers/performance/benchmarking/#module-benchmarks","title":"Module Benchmarks","text":"<p><code>iree-benchmark-module</code> is a program accepting (almost) the same inputs as <code>iree-run-module</code> that will benchmark the invocation of a single entry function. It measures timing for the whole process of invoking a function through the VM, including allocating and freeing output buffers. This is a high-level benchmark of an entire invocation flow. It provides a big picture view, but depends on many different variables, like an integration test. For finer-grained measurements more akin to unit tests, see Executable Benchmarks.</p> <p>To use <code>iree-benchmark-module</code>, generate an IREE module for the target backend:</p> <pre><code>$ bazel run //tools:iree-compile -- \\\n--iree-hal-target-backends=vmvx \\\n$PWD/samples/models/simple_abs.mlir \\\n-o /tmp/module.fb\n</code></pre> <p>and then benchmark an exported function in that module:</p> <pre><code>$ bazel run //tools:iree-benchmark-module -- \\\n--module=/tmp/module.fb \\\n--device=local-task \\\n--function=abs \\\n--input=f32=-2\n</code></pre> <p>You'll see output like</p> <pre><code>Run on (12 X 4500 MHz CPU s)\nCPU Caches:\n  L1 Data 32K (x6)\nL1 Instruction 32K (x6)\nL2 Unified 1024K (x6)\nL3 Unified 8448K (x1)\nLoad Average: 2.21, 1.93, 3.34\n***WARNING*** CPU scaling is enabled, the benchmark real time measurements may\n be noisy and will incur extra overhead.\n***WARNING*** Library was built as DEBUG. Timings may be affected.\n------------------------------------------------------------------------------\nBenchmark                                    Time             CPU   Iterations\n------------------------------------------------------------------------------\nBM_RunModule/process_time/real_time       0.22 ms         0.23 ms         3356\n</code></pre> <p>Notice that there are a few warnings in there (you may not see all of these). The benchmark library helpfully warns about some common issues that will affect benchmark timing. When trying to obtain real benchmark numbers, you should generally build an optimized build (<code>-c opt</code> in Bazel) and disable CPU scaling.</p> <pre><code>bazel build -c opt //tools:iree-benchmark-module\n</code></pre> <p>Another thing to consider is that depending on where you are running the benchmark you might want to avoid additional programs running at the same time. Bazel itself runs a server even when it's not being actively invoked that can be quite a memory hog, so we'll instead invoke the binary directly. Use your favorite process manager (e.g. htop or pkill on Linux) to kill heavy-weight programs such as Chrome and Bazel.</p> <p>Now we'll actually invoke the binary:</p> <pre><code>$ ./bazel-bin/tools/iree-benchmark-module \\\n--module=/tmp/module.fb \\\n--device=local-task \\\n--function=abs \\\n--input=f32=-2\n</code></pre> <pre><code>Run on (12 X 4500 MHz CPU s)\nCPU Caches:\n  L1 Data 32K (x6)\nL1 Instruction 32K (x6)\nL2 Unified 1024K (x6)\nL3 Unified 8448K (x1)\nLoad Average: 1.49, 3.42, 3.49\n------------------------------------------------------------------------------\nBenchmark                                    Time             CPU   Iterations\n------------------------------------------------------------------------------\nBM_RunModule/process_time/real_time      0.011 ms        0.014 ms        61654\n</code></pre> <p>Remember to restore CPU scaling when you're done.</p>"},{"location":"developers/performance/benchmarking/#executable-benchmarks","title":"Executable Benchmarks","text":"<p>We also benchmark the performance of individual parts of the IREE system in isolation. IREE breaks a model down to dispatch functions. To benchmark all the dispatch functions, generate an IREE module with the <code>-iree-flow-export-benchmark-funcs</code> flag set:</p> <pre><code>$ build/tools/iree-compile \\\n--iree-input-type=stablehlo \\\n--iree-flow-export-benchmark-funcs \\\n--iree-hal-target-backends=vmvx \\\ntests/e2e/stablehlo_models/fullyconnected.mlir \\\n-o /tmp/fullyconnected.vmfb\n</code></pre> <p>and then benchmark all exported dispatch functions (and all exported functions) in that module:</p> <pre><code>$ build/tools/iree-benchmark-module\n  --module=/tmp/fullyconnected.vmfb\n  --device=local-task\n</code></pre> <p>If no <code>entry_function</code> is specified, <code>iree-benchmark-module</code> will register a benchmark for each exported function that takes no inputs.</p> <p>You will see output like:</p> <pre><code>Run on (72 X 3700 MHz CPU s)\nCPU Caches:\n  L1 Data 32 KiB (x36)\nL1 Instruction 32 KiB (x36)\nL2 Unified 1024 KiB (x36)\nL3 Unified 25344 KiB (x2)\nLoad Average: 4.39, 5.72, 6.76\n---------------------------------------------------------------------------------------------\nBenchmark                                                   Time             CPU   Iterations\n---------------------------------------------------------------------------------------------\nBM_main_ex_dispatch_0_benchmark/process_time/real_time  0.030 ms        0.037 ms        34065\nBM_main_ex_dispatch_1_benchmark/process_time/real_time  0.034 ms        0.042 ms        20567\nBM_main_ex_dispatch_2_benchmark/process_time/real_time  0.043 ms        0.051 ms        18576\nBM_main_ex_dispatch_3_benchmark/process_time/real_time  0.029 ms        0.036 ms        21345\nBM_main_ex_dispatch_4_benchmark/process_time/real_time  0.042 ms        0.051 ms        15880\nBM_main_ex_dispatch_5_benchmark/process_time/real_time  0.030 ms        0.037 ms        17854\nBM_main_ex_dispatch_6_benchmark/process_time/real_time  0.043 ms        0.052 ms        14919\nBM_main_benchmark/process_time/real_time                0.099 ms        0.107 ms         5892\n</code></pre>"},{"location":"developers/performance/benchmarking/#bytecode-module-benchmarks","title":"Bytecode Module Benchmarks","text":"<p>Normally, the IREE VM is expected to be integrated into applications and driving model execution. So its performance is of crucial importance. We strive to introduce as little overhead as possible and have several benchmark binaries dedicated for evaluating the VM's performance. These benchmark binaries are named as <code>*_benchmark</code> in the <code>iree/vm/</code> directory. They also use the Google Benchmark library as the above.</p>"},{"location":"developers/performance/benchmarking/#cpu-configuration","title":"CPU Configuration","text":"<p>When benchmarking, it's important to consider the configuration of your CPUs. Most notably, CPU scaling can give variable results, so you'll usually want to disable it. This can get pretty complex, but the most basic thing to do is to run all CPUs at maximum frequency. The other thing to consider is what CPU(s) your program is running on. Both of these get more complicated on mobile and in multithreaded workloads.</p>"},{"location":"developers/performance/benchmarking/#linux","title":"Linux","text":"<p>Google benchmark provides some instructions. Note that the library will print \"CPU scaling is enabled\" warnings for any configuration that doesn't have the quota governor set to performance. Similarly the CPU frequency it reports is the maximum frequency of cpu0, not the frequency of the processor it's actually running on. This means that more advanced configurations should ignore these messages.</p> <p>Turn off CPU scaling before benchmarking.</p> <pre><code>sudo cpupower frequency-set --governor performance\n</code></pre> <p>Restore CPU scaling after benchmarking:</p> <pre><code>sudo cpupower frequency-set --governor powersave\n</code></pre> <p>To learn more about different quota governor settings, see https://www.kernel.org/doc/Documentation/cpu-freq/governors.txt. To restrict which CPUs you run on, use the <code>taskset</code> command which takes a hexadecimal mask.</p> <p>To only run on the lowest-numbered CPU you can run</p> <pre><code>taskset 1 sleep 20 &amp;\n</code></pre> <p>You can confirm that the process is running on the given CPU:</p> <pre><code>ps -o psr $!\n</code></pre> <p>Note that <code>$!</code> indicates the process ID of the last executed background command, so you can only use this shorthand if you didn't run any commands after the sleep. For more info on taskset, see https://linux.die.net/man/1/taskset.</p>"},{"location":"developers/performance/benchmarking/#android","title":"Android","text":"<p>Read and understand the Linux instructions first.</p> <p>Android doesn't give us quite as nice tooling, but the principle is basically the same. One important difference is that thermal throttling is a much bigger concern on mobile. Without a cooling plate, it is likely that high clock speeds will overheat the device and engage thermal throttling, which will ignore whatever clock speeds you may have set to prevent things from catching on fire. Therefore the naive approach above is likely not a good idea.</p> <p>You will likely need to be root (use <code>su</code> or <code>adb root</code>). The commands will depend on your exact phone and number of cores. First play around and make sure you understand what everything means. Note that each CPU has its own files which are used to control its behavior, but changes to a single CPU will sometimes affect others (see <code>/sys/devices/system/cpu/cpu0/cpufreq/affected_cpus</code>).</p> <p>Some useful files:</p> <pre><code>/proc/cpuinfo\n/sys/devices/system/cpu/possible\n/sys/devices/system/cpu/present\n/sys/devices/system/cpu/cpu0/online\n/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors\n/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies\n/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq\n/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_min_freq\n/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq\n/sys/devices/system/cpu/cpu0/cpufreq/affected_cpus\n/sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed\n</code></pre> <p>See the clockspeed of each CPU</p> <pre><code>$ for i in `cat /sys/devices/system/cpu/present | tr '-' ' ' | xargs seq`; do \\\npaste \\\n\"/sys/devices/system/cpu/cpu${i?}/cpufreq/cpuinfo_cur_freq\" \\\n\"/sys/devices/system/cpu/cpu${i?}/cpufreq/cpuinfo_min_freq\" \\\n\"/sys/devices/system/cpu/cpu${i?}/cpufreq/cpuinfo_max_freq\"; \\\ndone\n</code></pre> <p>Before changing things, make sure to check the current scaling governor settings first so you can put them back when you're done.</p> <pre><code>$ for i in `cat /sys/devices/system/cpu/present | tr '-' ' ' | xargs seq`; do \\\ncat \"/sys/devices/system/cpu/cpu${i?}/cpufreq/scaling_governor\"; \\\ndone\n</code></pre>"},{"location":"developers/performance/benchmarking/#single-core-example","title":"Single-Core Example","text":"<p>Here's an example to run IREE in a single-threaded context on CPU 7 at its lowest clock speed.</p> <p>First we'll take control of the clockspeed by setting the governor to \"userspace\".</p> <pre><code>$ for i in `cat /sys/devices/system/cpu/present | tr '-' ' ' | xargs seq`; do \\\necho userspace &gt; \\\n\"/sys/devices/system/cpu/cpu${i?}/cpufreq/scaling_governor\"; \\\ndone\n</code></pre> <p>We can now set individual clock speeds. We'll pin cpu7 to its minimum frequency. We choose the minimum instead of the maximum here to mitigate thermal throttling concerns</p> <pre><code>$ cat /sys/devices/system/cpu/cpu7/cpufreq/cpuinfo_min_freq &gt; \\\n/sys/devices/system/cpu/cpu7/cpufreq/scaling_setspeed\n</code></pre> <p>We can confirm the frequencies of all the CPUs by running the same command above. Now to run a command specifically on cpu7, use <code>taskset 80</code> (hex for 10000000):</p> <pre><code>taskset 80 sleep 20 &amp;\nps -o psr $!\n</code></pre> <p>Remember to cleanup when you're done! Here we'll set the scaling governor back to schedutil because that's what they were before on the particular device this, was tested on, but that may not exist on all devices.</p> <pre><code>$ for i in `cat /sys/devices/system/cpu/present | tr '-' ' ' | xargs seq`; do \\\necho schedutil &gt; \\\n\"/sys/devices/system/cpu/cpu${i?}/cpufreq/scaling_governor\"; \\\ndone\n</code></pre>"},{"location":"developers/performance/benchmarking/#android-scripts","title":"Android Scripts","text":"<p>We provide a few scripts to set clockspeeds on Android (under <code>build_tools/benchmarks</code>). These are somewhat device-specific:</p> <ul> <li>The <code>set_android_scaling_governor.sh</code> work on all CPUs, but the default   governor name may be different across devices.</li> <li>The <code>set_*_gpu_scaling_policy.sh</code> script used should match the actual GPU on   your device.</li> </ul> <p>Sample configuration steps for Pixel 6:</p> <ol> <li>Copy all scripts to the device:</li> </ol> <pre><code>adb push build_tools/benchmarks/*.sh /data/local/tmp\n</code></pre> <ol> <li>Launch interactive adb shell as super user:</li> </ol> <pre><code>adb shell\noriole:/ # su\noriole:/ # cd /data/local/tmp\n</code></pre> <ol> <li>Pin frequencies (high clockspeeds):</li> </ol> <pre><code>oriole:/ # ./set_android_scaling_governor.sh\nCPU info (before changing governor):\n cpu     governor        cur     min     max\n ------------------------------------------------\n cpu0    sched_pixel     1098000 300000  1803000\ncpu1    sched_pixel     1598000 300000  1803000\ncpu2    sched_pixel     1598000 300000  1803000\ncpu3    sched_pixel     1098000 300000  1803000\ncpu4    sched_pixel     400000  400000  2253000\ncpu5    sched_pixel     400000  400000  2253000\ncpu6    sched_pixel     500000  500000  2802000\ncpu7    sched_pixel     500000  500000  2802000\nSetting CPU frequency governor to performance\n CPU info (after changing governor):\n cpu     governor        cur     min     max\n ------------------------------------------------\n cpu0    performance     1803000 300000  1803000\ncpu1    performance     1803000 300000  1803000\ncpu2    performance     1803000 300000  1803000\ncpu3    performance     1803000 300000  1803000\ncpu4    performance     2253000 400000  2253000\ncpu5    performance     2253000 400000  2253000\ncpu6    performance     2802000 500000  2802000\ncpu7    performance     2802000 500000  2802000\noriole:/data/local/tmp # ./set_pixel6_gpu_scaling_policy.sh\nGPU info (before changing frequency scaling policy):\n policy                                  cur     min     max\n --------------------------------------------------------------\n coarse_demand [adaptive] always_on      251000  151000  848000\nSetting GPU frequency scaling policy to performance\n GPU info (after changing frequency scaling policy):\n policy                                  cur     min     max\n --------------------------------------------------------------\n coarse_demand adaptive [always_on]      848000  151000  848000\n</code></pre> <ol> <li>Restore default frequencies:</li> </ol> <pre><code>oriole:/ # ./set_android_scaling_governor.sh sched_pixel\n...\noriole:/ # ./set_pixel6_gpu_scaling_policy.sh default\n...\n</code></pre> <p>TODO(scotttodd): Windows instructions</p>"},{"location":"developers/performance/profiling-cpu-events/","title":"Profiling CPUs","text":"<p>CPUs are able to record certain events that may be relevant when investigating the performance of a program. A common example of such an event is a \"cache miss\", when the program tries to access data in memory that isn't already in some CPU cache, causing that access to be slower than it could otherwise be.</p> <p>Querying and analyzing this data can be useful, but is hard in two distinct ways:</p> <ul> <li>Depending on the CPU and on the OS, both hardware and software limitations can   get in the way of obtaining accurate data.</li> <li>This data tends to be inherently difficult to interpret, even when it is   perfectly accurate. In practice it is often noisy and inaccurate, which makes   interpretation even more complicated.</li> </ul> <p>There are two parts to this page: platform-specific information about how to query this data, and, at the end, a platform-independent explanation of how to interpret it.</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#perf-and-simpleperf-on-linux-and-android","title":"Perf and Simpleperf, on Linux and Android","text":"","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#overview","title":"Overview","text":"<p>The Linux kernel exposes system event counters to user-space programs by means of the <code>perf_event_open</code> system call. This includes both hardware event counters (such as CPU cache events) and software events from the kernel (such as page faults and context switches). Anyone may use this system call to implement a profiler, but Linux readily offers one, <code>perf</code>.</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#preserving-artifacts","title":"Preserving artifacts","text":"<p>By default IREE cleans up any temporary files it creates while running. Tools like perf, however, require those files exist even after the process has exited. The environment variable <code>IREE_PRESERVE_DYLIB_TEMP_FILES</code> can be set to preserve the files. This is only needed for the CPU path when using the system loader.</p> <pre><code>export IREE_PRESERVE_DYLIB_TEMP_FILES=1\n</code></pre>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#desktop-linux","title":"Desktop linux","text":"<p>On desktop Linux we can use <code>perf</code>. It is provided on most Linux distributions, for instance on Debian-based distributions do:</p> <pre><code>sudo apt install linux-perf\n</code></pre> <p>Run the program to be profiled, prepending its command line with <code>perf record</code>. By default this will write the profile data to the current directory, <code>./perf.data</code>. Sometimes this isn't ideal, such as then the current directory is under version control. Explicit paths can be specified by <code>-o</code> flag to direct the output of <code>perf record</code>, and then by <code>-i</code> flags to select the input of subsequent commands analyzing the profile. Example:</p> <pre><code>perf record -o /tmp/perf.data \\\n./tools/iree-benchmark-module \\\n--device=local-task \\\n... command-line arguments of iree-benchmark-module as usual ...\n</code></pre> <p>By default, this samples time spent. One may specify instead an event to sample by, with the <code>-e</code> flag. For instance, to sample by L1 cache misses, one may do:</p> <pre><code>perf record -o /tmp/perf.data -e L1-dcache-load-misses \\\n./tools/iree-benchmark-module \\\n--device=local-task \\\n... command-line arguments of iree-benchmark-module as usual ...\n</code></pre> <p><code>perf list</code> dumps the list of event types.</p> <p>Once you have recorded a profile, there are two main ways to analyze it: <code>perf report</code> and <code>perf annotate</code>.</p> <p><code>perf report</code> breaks down the event counts by symbol. In the default case where what was sampled was time, this is just an ordinary profile by symbol name, no different than what could be viewed in other profilers such as Tracy. Where it gets really interesting is when the profile was recording a specific event type, as in the above <code>-e L1-dcache-load-misses</code> example:</p> <pre><code>perf report -i /tmp/perf.data\n\nSamples: 6K of event 'L1-dcache-load-misses', Event count (approx.): 362571861\nOverhead  Command          Shared Object              Symbol\n  61.53%  cpu0             dylib_executablenzpx2Q.so  [.] serving_default_ex_dispatch_31\n  13.30%  cpu0             dylib_executablenzpx2Q.so  [.] serving_default_ex_dispatch_11\n   2.11%  cpu0             dylib_executablenzpx2Q.so  [.] serving_default_ex_dispatch_13\n   1.90%  cpu0             dylib_executablenzpx2Q.so  [.] serving_default_ex_dispatch_19\n   1.54%  cpu0             dylib_executablenzpx2Q.so  [.] serving_default_ex_dispatch_25\n   1.49%  cpu0             dylib_executablenzpx2Q.so  [.] serving_default_ex_dispatch_5\n</code></pre> <p><code>perf annotate</code> breaks down the event counts by instruction. Again, in the default case where what was sampled was time, this is no different than what could be viewed in Tracy, and the real motivation to use <code>perf</code> is when profiling by specific event types as in the above <code>-e L1-dcache-load-misses</code> example:</p> <pre><code>perf annotate -i perf.data\n\nSamples: 6K of event 'L1-dcache-load-misses', 4000 Hz, Event count (approx.): 362571861\nserving_default_ex_dispatch_31  /tmp/dylib_executablenzpx2Q.so [Percent: local period]\n1.66 \u2502        movups -0x1000(%rdi),%xmm10\n  0.48 \u2502        movups -0x800(%rdi),%xmm9\n  0.82 \u2502        movups (%rdi),%xmm8\n  0.49 \u2502        movaps %xmm1,%xmm4\n  0.12 \u2502        shufps $0x0,%xmm1,%xmm4\n  0.14 \u2502        mulps  %xmm5,%xmm4\n  0.28 \u2502        addps  %xmm6,%xmm4\n  0.60 \u2502        movaps %xmm3,%xmm6\n  0.34 \u2502        shufps $0x0,%xmm3,%xmm6\n</code></pre>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#warning","title":"Warning","text":"<p><code>perf annotate</code> is even noisier than <code>perf report</code> as it can be overly optimistic, depending on the CPU, to pin an event to a specific instruction. Typically, this works fairly well on x86 CPUs and less well on ARM CPUs and more generally on anything mobile. Even on a desktop x86 CPU, this is noisy, as the above example (recorded on a Skylake workstation) shows: it blamed a <code>mulps %xmm5,%xmm4</code> instruction for a cache miss, which doesn't make sense as that instruction only touches registers.</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#android","title":"Android","text":"<p>On Android we can use <code>simpleperf</code>. It's preinstalled on current Android <code>userdebug</code> images, and part of the Android NDK.</p> <p>In theory, as Android is Linux, it should be possible to use <code>perf</code>. Unfortunately, <code>perf</code> is difficult to build for Android. Fortunately, <code>simpleperf</code> is readily available: it is preinstalled in Android <code>userdebug</code> images, and it is part of the Android NDK.</p> <p>First, we record on the device:</p> <pre><code>adb shell \\\nsimpleperf record -e raw-l1d-cache-refill -o /data/local/tmp/perf.data \\\n/data/local/tmp/iree-benchmark-module \\\n--device=local-task \\\n... command-line arguments of iree-benchmark-module as usual ...\n</code></pre> <p>Then pull the recorded data from the device, and analyze on the desktop. We assume that <code>${ANDROID_NDK}</code> points to the local copy of the Android NDK.</p> <pre><code>adb pull /data/local/tmp/perf.data /tmp/perf.data\n${ANDROID_NDK}/simpleperf/report.py -i /tmp/perf.data\n</code></pre> <p>This prints a breakdown of <code>raw-l1d-cache-refill</code> events by symbol.</p> <p>Like with <code>perf</code>, a list of event types can be queried by the <code>list</code> subcommand:</p> <pre><code>adb shell simpleperf list\n</code></pre>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#no-support-for-annotate-by-cpu-event","title":"No support for <code>annotate</code> by CPU event","text":"<p>There is no <code>simpleperf annotate</code>. The <code>simpleperf</code> documentation lists a couple of ways of achieving the same thing.</p> <p>However:</p> <ul> <li>The common case of annotating by time, as opposed to annotating by CPU event,   is supported by Tracy.</li> <li>Annotating by CPU event is inherently not working due to hardware limitations   of the ARM CPUs found in Android devices. That is, the hardware is too   imprecise at pinning an event to a particular instruction.</li> </ul>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#interpreting-cpu-event-counts","title":"Interpreting CPU event counts","text":"","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#problems","title":"Problems","text":"<p>There are multiple layers of complexity in interpreting CPU event counts.</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#these-events-are-in-themselves-normal","title":"These events are in themselves normal","text":"<p>The first difficulty is in the fact that most of these events are normal. So just knowing that they happened is not in itself actionable.</p> <p>For example, if we learn that some code causes cache misses, that isn't big news: so does all code. Maybe this code has too many cache misses, but how many is too many? Maybe this code alone accounts for a large fraction of the overall total of the whole program, but maybe even that is normal, for instance if the code being studied is the 'hot' part of the program where a large fraction of overall time is spent?</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#these-events-are-hardware-dependent-and-under-documented","title":"These events are hardware-dependent and under-documented","text":"<p>Many of these events have a meaning that varies between CPUs and that is difficult to characterize on any CPU, let alone in a way that applies to all CPUs.</p> <p>For example, take the \"L2 data cache refill\". On ARM, with <code>simpleperf</code>, that would be <code>raw-l2d-cache-refill</code>. Questions:</p> <ul> <li>Is \u201cL2\u201d inclusive of   \u201cL1\u201d?</li> <li>How many bytes are transferred per \u201crefill\u201d?</li> <li>Are accesses induced by speculative execution or by automatic pre-fetching   counted in the same way as accesses induced by actual code execution?</li> </ul> <p>The answers to all of the above questions are CPU-dependent. They may even vary between the CPU cores of the same Android device.</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#these-events-are-imprecise-and-noisy-particularly-on-arm-cpus","title":"These events are imprecise and noisy, particularly on ARM CPUs","text":"<p>Expect noise levels above 10% in many CPU event counts on ARM CPUs. Moreover, on ARM, as discussed above, there is inaccuracy in which instruction is blamed for which event, which will increase inaccuracy of per-symbol breakdowns for very cheap symbols (and makes <code>perf annotate</code> impossible as noted above). Finally, be aware that some ARM CPUs may perform event count interpolation, so we may not have any access to true hardware counts.</p>","tags":["CPU"]},{"location":"developers/performance/profiling-cpu-events/#recommendations","title":"Recommendations","text":"<p>Here is a workflow pattern that allows to make significant use of CPU event counts, despite all the problems noted above:</p> <ul> <li>Hypothesize that some code diff might help performance, and might help   reducing the number of CPU events of a certain type, and that the two might be   related.</li> <li>Benchmark with and without the code diff, on the same device, everything else   being equal.<ul> <li>Let your benchmark perform a fixed number of iterations, or, if using a benchmark termination condition of the form \"run until at least N seconds have elapsed\", carefully divide event counts by the actual number of iterations that were run.</li> </ul> </li> <li>If the observed CPU event count difference is significant, go ahead and claim   that your code diff probably helps with that aspect of CPU behavior.</li> </ul> <p>Some things NOT to be done:</p> <ul> <li>Don\u2019t try to compare different metrics, not even when it seems obvious that   they should satisfy a simple relationship, not even on the same CPU (e.g. \u201cL1   accesses should be greater than L2 accesses\u201d).</li> <li>Don\u2019t divide by some \u201ctotal\u201d metric to get some kinds of ratios. For example,   don\u2019t try to compute a \u201ccache miss ratio\u201d as quotient of \u201ccache refill\u201d over   \u201call cache accesses\u201d metrics. The first problem with that (even before we get   to CPU-specific issues) is that that\u2019s rewarding increases to the \u201call cache   accesses\u201d metrics, so if something bad happens in your codegen and your kernel   ends up spilling a lot of register to the stack, that\u2019s going to be a lot more   accesses which will all be L1 hits so that\u2019ll help this ratio look better!  So   more generally, just try to minimize some CPU metrics (that count \u201ccostly\u201d   events), not some more complex math expression formed from arithmetic on CPU   metrics.</li> </ul>","tags":["CPU"]},{"location":"developers/performance/profiling-gpu-vulkan/","title":"Profiling GPUs using Vulkan","text":"<p>Tracy offers great insights into CPU/GPU interactions and Vulkan API usage details. However, information at a finer granularity, especially inside a particular shader dispatch, is missing. To supplement general purpose tools like Tracy, vendor-specific tools can be used.</p> <p>(TODO: add some pictures for each tool)</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#renderdoc","title":"RenderDoc","text":"<p>Support for RenderDoc can be enabled by configuring cmake with <code>-DIREE_ENABLE_RENDERDOC_PROFILING=ON</code>. When built in to IREE the profiling functionality is available for programmatic use via the <code>iree_hal_device_profiling_begin</code> and <code>iree_hal_device_profiling_end</code> APIs.</p> <p>When using one of the standard IREE tools (<code>iree-run-module</code>, <code>iree-benchmark-module</code>, etc) the <code>--device_profiling_mode=queue</code> flag can be passed to enable capture around the entire invocation (be careful when benchmarking as the recordings can be quite large!). The default capture file name can be specified with <code>--device_profiling_file=foo.rdc</code>.</p> <p>Capturing in the RenderDoc UI can be done by specifying the IREE tool or embedding application (<code>iree-run-module</code>, etc) as the launch executable and adding all arguments as normal.</p> <p>Capturing from the command line can be done using <code>renderdoccmd</code> with the specified file appearing (by default) in the executable directory:</p> <pre><code>renderdoccmd capture tools/iree-run-module --device_profiling_mode=queue --device_profiling_file=foo.rdc ...\nstat tools/foo.rdc\nrenderdoccmd capture tools/iree-run-module --device_profiling_mode=queue --device_profiling_file=/some/path/foo.rdc ...\nstat /some/path/foo.rdc\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#android-gpus","title":"Android GPUs","text":"<p>There are multiple GPU vendors for the Android platforms, each offering their own tools. Android GPU Inspector (AGI) provides a cross-vendor solution. See the documentation for more details.</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#build-android-app-to-run-iree","title":"Build Android app to run IREE","text":"<p>In order to perform capture and analysis with AGI, you will need a full Android app. In IREE we have a simple Android native app wrapper to help package IREE core libraries together with a specific VM bytecode invocation into an Android app. The wrapper and its documentation are placed at <code>tools/android/run_module_app/</code>.</p> <p>For example, to package a module compiled from the following <code>stablehlo-dot.mlir</code> as an Android app:</p> <pre><code>func @dot(%lhs: tensor&lt;2x4xf32&gt;, %rhs: tensor&lt;4x2xf32&gt;) -&gt; tensor&lt;2x2xf32&gt; {\n  %0 = \"stablehlo.dot\"(%lhs, %rhs) : (tensor&lt;2x4xf32&gt;, tensor&lt;4x2xf32&gt;) -&gt; tensor&lt;2x2xf32&gt;\n  return %0 : tensor&lt;2x2xf32&gt;\n}\n</code></pre> <pre><code># First compile into a VM bytecode module\n$ /path/to/iree/build/tools/iree-compile -- \\\n--iree-input-type=stablehlo \\\n--iree-hal-target-backends=vulkan-spirv \\\n/path/to/stablehlo-dot.mlir \\\n-o /tmp/stablehlo-dot.vmfb\n\n# Then package the Android app\n$ /path/to/iree/source/tools/android/run_module_app/build_apk.sh \\\n./build-apk \\\n--device vulkan \\\n--module /tmp/stablehlo-dot.vmfb \\\n--function dot \\\n--input=...\n</code></pre> <p>Where <code>/path/to/input/file</code> is a file containing inputs to <code>dot</code>, for example:</p> <pre><code>2x4xf32=[[1.0 2.0 3.0 4.0][5.0 6.0 7.0 8.0]]\n4x2xf32=[[9.0 10.0][11.0 12.0][13.0 14.0][15.0 16.0]]\n</code></pre> <p>The above will build an <code>iree-run-module.apk</code> under the <code>./build-apk/</code> directory, which you can then install via <code>adb install</code>.</p> <p><code>build_apk.sh</code> needs the Android SDK and NDK internally, an easy way to manage them is by installing Android Studio. After installation, you will need to set up a few environment variables, which are printed at the beginning of <code>build_apk.sh</code> invocation.</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#capture-and-analyze-with-agi","title":"Capture and analyze with AGI","text":"<p>You can follow AGI's Getting Started page to learn how to use it. In general the steps are:</p> <ul> <li>Install the latest AGI from https://github.com/google/agi/releases and launch.</li> <li>Fill in the \"Application\" field by searching the app. The line should read   like <code>android.intent.action.MAIN:dev.iree.run_module/android.app.NativeActivity</code>.</li> <li>Select start at beginning and choose a proper duration.</li> <li>Configure system profile to include all GPU counters.</li> <li>Start capture.</li> </ul> <p>Generated traces are in the perfetto format. They can be viewed directly within AGI and also online in a browser at https://ui.perfetto.dev/, without needing an Android device.</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#desktop-gpus","title":"Desktop GPUs","text":"<p>Vulkan supports both graphics and compute, but most tools in the Vulkan ecosystem focus on graphics. As a result, some Vulkan profiling tools expect commands to correspond to a sequence of frames presented to displays via framebuffers. This means additional steps for IREE and other Vulkan applications that solely rely on headless compute. For graphics-focused tools, we need to wrap IREE's logic inside a dummy rendering loop in order to provide the necessary markers for these tools to perform capture and analysis.</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#amd","title":"AMD","text":"<p>For AMD GPUs, Radeon GPU Profiler (RGP) is the tool to understand fine details of how IREE GPU performs. See the documentation for details.</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-gpu-vulkan/#nvidia","title":"NVIDIA","text":"<p>For NVIDIA GPUs, NVIDIA Nsight Graphics is the tool to understand fine details of how IREE GPU performs. See the documentation for details.</p>","tags":["GPU","Vulkan"]},{"location":"developers/performance/profiling-with-tracy/","title":"Profiling with Tracy","text":"<p>Tracy is a profiler that puts together in a single view both instrumentation and system profiling (sampling, systrace). It's key to understand the nuance here.</p> <ul> <li>Instrumentation is code built into the process being profiled, collecting   timestamps at the start and end of \"zones\". Once it's enabled at build time,   it typically just works \u2014 it is a part of our application logic just   like anything else, so there's no reason why it would not work.</li> <li>Sampling and SysTrace rely on specific   system features to collect information on what is actually running. These   rely on OS and binary (ELF) file features, so they can take a bit more care to   get to work properly.</li> </ul> <p>There are two components to Tracy. They communicate over a TCP socket.</p> <ul> <li>The \"client\" is the program being profiled.</li> <li>The \"server\" is:<ul> <li>Either the Tracy profiler UI (which we build as <code>iree-tracy-profiler</code>),</li> <li>Or the Tracy command-line capture tool (<code>iree-tracy-capture</code>) that can     save a trace for later loading in the Tracy profiler UI.</li> </ul> </li> </ul>"},{"location":"developers/performance/profiling-with-tracy/#the-tracy-manual","title":"The Tracy manual","text":"<p>The primary source of Tracy documentation, including for build instructions, is a PDF manual that's part of each numbered release. Download or view in browser.</p>"},{"location":"developers/performance/profiling-with-tracy/#overview","title":"Overview","text":"<p>We will go through each steps below, but here is an overview. It highlights the simpler subset of instructions when only instrumentation is needed, vs. the additional steps needed when Sampling is also wanted.</p> Component Instrumentation only Instrumentation and Sampling Build Tracy capture (<code>iree-tracy-capture</code>) Base instructions below for dependencies and build Same Build Tracy profiler (<code>iree-tracy-profiler</code>) Base instructions below for dependencies and build Same plus <code>capstone-next</code> instructions for CPU disassembly to work Build the IREE compiler (<code>iree-compile</code>) for profiling your own modules Nothing particular Same Build the IREE compiler (<code>iree-compile</code>) for profiling the compiler itself Also need CMake setting: <code>IREE_ENABLE_COMPILER_TRACING</code> Same Compile your IREE module (run <code>iree-compile</code>) Nothing particular Also need to pass <code>--iree-llvmcpu-link-embedded=false</code> (and also, for <code>llvm-cpu</code> backend, pass <code>--iree-llvmcpu-debug-symbols=true</code>, but that is currently default). Build IREE device binaries (<code>iree-run-module</code> etc) Base instructions below (CMake: set <code>IREE_ENABLE_RUNTIME_TRACING</code>) Also need debug information (Set <code>CMAKE_BUILD_TYPE</code> to <code>RelWithDebInfo</code>). Run IREE device binaries loading your modules Nothing particular (May need to set the environment variable <code>TRACY_NO_EXIT=1</code> for short-running benchmarks) Also need to set the environment variable <code>IREE_PRESERVE_DYLIB_TEMP_FILES</code> and adjust device security settings or run as root depending on OS. Run Tracy capture (<code>iree-tracy-capture</code>) to collect the trace If device!=host (e.g. Android), set up TCP port forwarding. Same Build IREE's own tests and benchmark suites with Tracy instrumentation As above, CMake: set <code>IREE_ENABLE_RUNTIME_TRACING</code>. Also need the CMake setting <code>IREE_BYTECODE_MODULE_FORCE_LLVM_SYSTEM_LINKER</code> so that <code>--iree-llvmcpu-link-embedded=false</code> will be passed to <code>iree-compile</code>."},{"location":"developers/performance/profiling-with-tracy/#install-dependencies","title":"Install dependencies","text":""},{"location":"developers/performance/profiling-with-tracy/#do-you-need-capstone-next","title":"Do you need capstone-next?","text":"<p>You can skip this section if you don't need disassembly of CPU code.</p> <p>Capstone is the disassembly framework used by Tracy. The default branch, which is what OS packages still distribute, is running a few years behind current CPU architectures.</p> <p>Newer CPU architectures such as RISC-V, or newer extensions of existing architectures (e.g. new SIMD instructions in the ARM architecture) are typically only supported in the <code>next</code> branch. If you need that support, check out and build that branch. Consider uninstalling any OS package for <code>capstone</code> or otherwise ensure that your IREE build will pick up your <code>next</code> branch build.</p>"},{"location":"developers/performance/profiling-with-tracy/#linux","title":"Linux","text":"<p>If you haven't opted to build <code>capstone-next</code> (see above section), install the OS package for <code>capstone</code> now (Debian-based distributions):</p> <pre><code>sudo apt install libcapstone-dev\n</code></pre> <p>Install other dependencies:</p> <pre><code>sudo apt install libtbb-dev libzstd-dev libglfw3-dev libfreetype6-dev libgtk-3-dev\n</code></pre> <p>If you only build the command-line tool <code>iree-tracy-capture</code> and not the graphical <code>iree-tracy-profiler</code>, you can install only:</p> <pre><code>sudo apt install libtbb-dev libzstd-dev\n</code></pre> <p>The zstd version on Ubuntu 18.04 is old. You will need to install it from source from https://github.com/facebook/zstd.git</p>"},{"location":"developers/performance/profiling-with-tracy/#mac","title":"Mac","text":"<p>If you haven't opted to build <code>capstone-next</code> (see above section), install the system <code>capstone</code> now:</p> <pre><code>brew install capstone\n</code></pre> <p>Install other dependencies:</p> <pre><code>brew install pkg-config glfw freetype tbb zstd\n</code></pre>"},{"location":"developers/performance/profiling-with-tracy/#build-the-tracy-tools","title":"Build the Tracy tools","text":"<p>A CMake-based build system for Tracy is maintained as part of IREE. In your IREE desktop build directory, set the following CMake option:</p> <pre><code>cmake -DIREE_BUILD_TRACY=ON -DIREE_ENABLE_LLD=ON .\n</code></pre> <p>That enables building the Tracy server tools, <code>iree-tracy-profiler</code> and <code>iree-tracy-capture</code>, introduced above. It also enables building the tool <code>iree-tracy-csvexport</code> which can be used to export a captured trace as a CSV file (see Section 6 \"Exporting zone statistics to CSV\" in the Tracy manual).</p> <p>If profiling on Android/ARM, you might need the patch discussed in the next paragraph.</p> <p>Consider building without assertions (<code>cmake -DIREE_ENABLE_ASSERTIONS=OFF</code>). At least <code>iree-tracy-profiler</code> has some faulty assertions that can cause the profiler UI to crash during normal usage.</p> <p>Rebuild, either everything or just these specific targets:</p> <pre><code>cmake --build . --target iree-tracy-profiler iree-tracy-capture iree-tracy-csvexport\n</code></pre> <p>This should have created the <code>iree-tracy-profiler</code>, <code>iree-tracy-capture</code>, and <code>iree-tracy-csvexport</code> binaries:</p> <pre><code>$ find . -name iree-tracy-*\n./tracy/iree-tracy-profiler\n./tracy/iree-tracy-capture\n./tracy/iree-tracy-csvexport\n</code></pre>"},{"location":"developers/performance/profiling-with-tracy/#build-the-iree-compiler-iree-compile","title":"Build the IREE compiler (<code>iree-compile</code>)","text":"<p>Most people don't need to rebuild <code>iree-compile</code> at all for Tracy and can skip this section.</p> <p>If you want to profile <code>iree-compile</code> itself as opposed to just profiling modules compiled with it, then rebuild it with the CMake setting <code>IREE_ENABLE_COMPILER_TRACING</code> set to <code>ON</code>.</p>"},{"location":"developers/performance/profiling-with-tracy/#compile-your-iree-module-run-iree-compile","title":"Compile your IREE module (run <code>iree-compile</code>)","text":"<p>If you only want Instrumentation and not Sampling then you don't need anything particular here. Just run <code>iree-compile</code> as usual.</p>"},{"location":"developers/performance/profiling-with-tracy/#additional-steps-for-sampling","title":"Additional steps for Sampling","text":"<p>In order for Sampling to work with your compiled modules, add this flag to your <code>iree-compile</code> command line: <code>--iree-llvmcpu-link-embedded=false</code>.</p> <p>For the <code>llvm-cpu</code> target backend, sampling features also rely on debug information in the compiled module, enabled by <code>--iree-llvmcpu-debug-symbols=true</code>, but that is currently the default.</p> <p>When building IREE's own test and benchmark suites, if Tracy Sampling support is wanted, set the CMake setting <code>IREE_BYTECODE_MODULE_FORCE_LLVM_SYSTEM_LINKER</code> to <code>ON</code>. It has the effect of passing that <code>--iree-llvmcpu-link-embedded=false</code> when compiling test/benchmark modules.</p>"},{"location":"developers/performance/profiling-with-tracy/#build-iree-device-binaries-with-tracy-instrumentation-clients","title":"Build IREE device binaries with Tracy instrumentation (\"clients\")","text":"<p>Set the CMake setting <code>IREE_ENABLE_RUNTIME_TRACING</code> to <code>ON</code> and rebuild IREE device binaries, e.g.</p> <pre><code>cd iree-device-build-dir\ncmake -DIREE_ENABLE_RUNTIME_TRACING=ON .\ncmake --build .\n</code></pre> <p>Tip - python bindings</p> <p>The <code>iree-runtime</code> Python package includes instrumented tools too. Set the <code>IREE_PY_RUNTIME=tracy</code> environment variable to use them:</p> <pre><code>$ python -m pip install iree-runtime\n$ IREE_PY_RUNTIME=tracy iree-run-module ...\n</code></pre> <p>See this section in the Python bindings documentation for more details.</p>"},{"location":"developers/performance/profiling-with-tracy/#additional-steps-for-sampling_1","title":"Additional steps for Sampling","text":"<p>In order for Sampling features to work, make sure that binaries contain debug information. That usually means changing the <code>CMAKE_BUILD_TYPE</code> to <code>RelWithDebInfo</code> instead of <code>Release</code>.</p> <p>In your IREE device build directory, set the following CMake options:</p> <pre><code>cd iree-device-build-dir\ncmake -DCMAKE_BUILD_TYPE=RelWithDebInfo .\n</code></pre>"},{"location":"developers/performance/profiling-with-tracy/#running-the-profiled-program","title":"Running the profiled program","text":"<p>The basic recipe is to just run your program as usual on the device and, while it is running, run <code>iree-tracy-capture</code> on the host to connect to it.</p> <p>In the typical case of a short-running benchmark, one usually runs with the environment variable <code>TRACY_NO_EXIT</code> defined so that the benchmark does not exit until <code>iree-tracy-capture</code> has connected to it.</p> <p>Example:</p> <pre><code>TRACY_NO_EXIT=1 /data/local/tmp/iree-benchmark-module ... (usual flags)\n</code></pre>"},{"location":"developers/performance/profiling-with-tracy/#additional-steps-for-sampling_2","title":"Additional steps for Sampling","text":"<p>In order for Sampling to work, the IREE compiled module code mapping must still be accessible by the time Tracy tries to read symbols code. This requires setting the environment variable <code>IREE_PRESERVE_DYLIB_TEMP_FILES</code>. It is easiest to set it to <code>1</code> but one may also set it to an explicit path where to preserve the temporary files.</p> <p>Example:</p> <pre><code>TRACY_NO_EXIT=1 IREE_PRESERVE_DYLIB_TEMP_FILES=1 /data/local/tmp/iree-benchmark-module ... (usual flags)\n</code></pre> <p>Tracing doesn't work properly on VMs (see \"Problematic Platforms / Virtual Machines\" section 2.1.6.4 of the manual). To get sampling, you should run the profiled program on bare metal.</p>"},{"location":"developers/performance/profiling-with-tracy/#operating-system-settings-required-for-sampling-and-systrace","title":"Operating system settings required for Sampling and SysTrace","text":""},{"location":"developers/performance/profiling-with-tracy/#desktop-linux","title":"Desktop Linux","text":"<p>On desktop Linux, the profiled application must be run as root, e.g. with <code>sudo</code>. Otherwise, profile data will lack important components.</p>"},{"location":"developers/performance/profiling-with-tracy/#android","title":"Android","text":"<p>When profiling on an Android device, in order to get the most useful information in the trace, tweak system permissions as follows before profiling. This needs to be done again after every reboot of the Android device.</p> <p>From your desktop, get a shell on the Android device:</p> <pre><code>adb shell\n</code></pre> <p>The following commands are meant to be run from that Android device shell. First, get root access for this shell:</p> <pre><code>$ su\n#\n</code></pre> <p>Now run the following commands as root on the Android device:</p> <pre><code>setenforce 0\nmount -o remount,hidepid=0 /proc\necho 0 &gt; /proc/sys/kernel/perf_event_paranoid\necho 0 &gt; /proc/sys/kernel/kptr_restrict\n</code></pre> <p>Note: in order for this to work, the device needs to be rooted, which means that the above <code>su</code> command must succeed. This is sometimes confused with the <code>adb root</code> command, but that's not the same. <code>adb root</code> restarts the <code>adbd</code> daemon as root, which causes device shells to be root shells by default. This is unnecessary here and we don't recommend it: real Android applications never run as root, so Tracy/Android has to support running benchmarks as regular user and it's best to stick to this for the sake of realistic benchmarks. Internally, Tracy executes <code>su</code> commands to perform certain actions, so it too relies on the device being rooted without relying on the benchmark process being run as root.</p>"},{"location":"developers/performance/profiling-with-tracy/#resource_exhausted-failed-to-open-file-issue","title":"\"RESOURCE_EXHAUSTED; failed to open file\" issue","text":"<p>This is a known issue with how tracy operates. One way to workaround it is to manually increase the total number of files that can be kept opened simultaneously and run the benchmark command with that setting:</p> <pre><code>sudo sh -c \"ulimit -n &lt;bigNum&gt; &amp;&amp; &lt;myTracyInstrumentedProgram&gt;\"\n</code></pre> <p>Explanation:</p> <p>Tracy keeps a number of file descriptors open that, depending on the machine and its settings, may exceed the limit allowed by the system resulting in <code>iree</code> to fail to open more files. In particular, it is commom to have a relatively low limit when running with <code>sudo</code>.</p>"},{"location":"developers/performance/profiling-with-tracy/#running-the-tracy-capture-cli-connecting-and-saving-profiles","title":"Running the Tracy Capture CLI, connecting and saving profiles","text":"<p>While the program that you want to profile is still running (thanks to <code>TRACY_NO_EXIT=1</code>), start the Tracy capture tool in another terminal. From the IREE build directory:</p> <pre><code>tracy/iree-tracy-capture -o myprofile.tracy\nConnecting to 127.0.0.1:8086...\n</code></pre> <p>It should connect to the IREE client and save the output to myprofile.tracy that can be visualized by the client below. You can start the capture tool first to make sure you don't miss any capture events.</p> <p>Note that the connection uses TCP port 8086. If the Tracy-instrumented program is running on a separate machine, this port needs to be forwarded. In particular, when benchmarking on Android, this is needed:</p> <pre><code>adb forward tcp:8086 tcp:8086\n</code></pre>"},{"location":"developers/performance/profiling-with-tracy/#running-the-tracy-profiler-ui-connecting-and-visualizing","title":"Running the Tracy profiler UI, connecting and visualizing","text":"<p>If you have previously captured a tracy file (previous section), this command should succeed loading it (from the IREE build directory):</p> <pre><code>tracy/iree-tracy-profiler myprofile.tracy\n</code></pre> <p>Alternatively, while the program that you want to profile is still running (possibly thanks to <code>TRACY_NO_EXIT=1</code>), the Tracy profiler can connect to it directly (so it is not required to capture the trace into a file): just running</p> <pre><code>tracy/iree-tracy-profiler\n</code></pre> <p>should show a dialog offering to connect to a client i.e. a profiled program:</p> <p></p> <p>If connecting doesn't work:</p> <ul> <li>If the profiled program is on a separate machine, make sure you've correctly     set up port forwarding.</li> <li>On Android, the <code>adb forward</code> may need to be run again.</li> <li>Make sure that the profiled program is still running. Do you need     <code>TRACY_NO_EXIT=1</code>?</li> <li>Kill the profiled program and restart it.</li> </ul> <p>You should now start seeing a profile. The initial view should look like this:</p> <p></p> <p>Before going further, take a second to check that your recorded profile data has all the data that it should have. Permissions issues, as discussed above, could cause it to lack \"sampling\" or \"CPU data\" information, particularly on Android. For example, here is what he initial view looks like when one forgot to run the profiled program as root on Desktop Linux (where running as root is required, as explained above):</p> <p></p> <p>Notice how the latter screenshot is lacking the following elements:</p> <ul> <li>No 'CPU data' header on the left side, with the list of all CPU cores. The     'CPU usage' graph is something else.</li> <li>No 'ghost' icon next to the 'Main thread' header.</li> </ul> <p>Click the 'Statistics' button at the top. It will open a window like this:</p> <p></p> <p>See how the above screenshot has two radio buttons at the top: 'Instrumentation' and 'Sampling'. At this point, if you don't see the 'Sampling' radio button, you need to resolve that first, as discussed above about possible permissions issues.</p> <p>These 'Instrumentation' and 'Sampling' statistics correspond the two kinds of data that Tracy collects about your program. In the Tracy main view, they correspond, respectively, to 'instrumentation' and 'ghost' zones. Refer to the Tracy PDF manual for a general introduction to these concepts. For each thread, the ghost icon toggles the view between these two kinds of zones.</p> <p>Back to the main view, look for the part of the timeline that is of interest to you. Your area of interest might not be on the Main thread. In fact, it might be on a thread that's not visible in the initial view at all. To pan around with the mouse, hold the right mouse button down (or its keyboard equivalent on macOS). Alternatively, look for the 'Frame' control at the top of the Tracy window. Use the 'next frame' arrow button until more interesting threads appear.</p> <p>IREE module code tends to run on a thread whose name contains the word <code>worker</code>.</p> <p>Once you have identified the thread of interest, you typically want to click its ghost icon to view its \"ghost\" (i.e. sampling) zones.</p> <p>Here is what you should get when clicking on a ghost zone:</p> <p></p> <p>The percentages column to the left of the disassembly shows where time is being spent. This is unique to the sampling data (ghost zones) and has no equivalent in the instrumentation data (instrumentation zones). Here is what we get clicking on the corresponding instrumentation zone:</p> <p></p> <p>This still has a 'Source' button but that only shows the last C++ caller that had explicit Tracy information, so here we see a file under <code>iree/hal</code> whereas the Ghost zone saw into the IREE compiled module that that calls into, with the source view pointing to the <code>.mlir</code> file.</p>"},{"location":"developers/performance/profiling-with-tracy/#configuring-tracy-instrumentation","title":"Configuring Tracy instrumentation","text":"<p>Set IREE's <code>IREE_TRACING_MODE</code> value (defined in iree/base/tracing.h) to adjust which tracing features, such as allocation tracking and callstacks, are enabled.</p>"},{"location":"developers/performance/profiling/","title":"Profiling overview","text":"<p>IREE benchmarking gives us an accurate and reproducible view of program performance at specific levels of granularity. To analyze system behavior in more depth, there are various ways to profile IREE.</p>"},{"location":"developers/performance/profiling/#cpu-cache-and-other-cpu-event-profiling","title":"CPU cache and other CPU event profiling","text":"<p>For some advanced CPU profiling needs such as querying CPU cache and other events, one may need to use some OS-specific profilers. See Profiling CPUs.</p>"},{"location":"developers/performance/profiling/#vulkan-gpu-profiling","title":"Vulkan GPU Profiling","text":"<p>Tracy offers great insights into CPU/GPU interactions and Vulkan API usage details. However, information at a finer granularity, especially inside a particular shader dispatch, is missing. To supplement general purpose tools like Tracy, vendor-specific tools can be used. Refer to Profiling GPUs using Vulkan.</p>"},{"location":"developers/performance/profiling/#tracy","title":"Tracy","text":"<p>Tracy is a profiler that's been used for a wide range of profiling tasks on IREE. Refer to Profiling with Tracy.</p>"},{"location":"guides/","title":"Guides","text":""},{"location":"guides/#ml-frameworks","title":"ML frameworks","text":"<p>Start here: ML frameworks overview</p> <p>Guides for specific frameworks:</p> <ul> <li> TensorFlow and    TensorFlow Lite</li> <li> JAX</li> <li> PyTorch</li> </ul>"},{"location":"guides/#deployment-configurations","title":"Deployment configurations","text":"<p>Start here: Deplyment configurations overview</p> <p>Guides for specific configurations:</p> <ul> <li> CPU for general   purpose CPU deployment</li> <li> CPU - Bare-Metal   with minimal platform dependencies</li> <li> GPU - Vulkan   for cross-platform usage and interop with graphics applications</li> <li> GPU - CUDA   for NVIDIA-specific solutions</li> <li> GPU - ROCm   for AMD-specific solutions</li> <li> GPU - Metal   for running on Apple hardware</li> </ul>"},{"location":"guides/deployment-configurations/","title":"Deployment configurations","text":"<p>IREE provides a flexible set of tools for various deployment scenarios. Fully featured environments can use IREE to load programs on demand and to take advantage of multi-threaded hardware, while embedded systems can bypass IREE's runtime entirely or interface with custom accelerators.</p>"},{"location":"guides/deployment-configurations/#stable-configurations","title":"Stable configurations","text":"<ul> <li> CPU for general   purpose CPU deployment</li> <li> CPU - Bare-Metal   with minimal platform dependencies</li> <li> GPU - Vulkan   for cross-platform usage and interop with graphics applications</li> <li> GPU - CUDA   for NVIDIA-specific solutions</li> <li> GPU - ROCm   for AMD-specific solutions</li> <li> GPU - Metal   for running on Apple hardware</li> </ul> <p>These are just the most stable configurations IREE supports. Feel free to reach out on any of IREE's communication channels if you have questions about a specific platform, hardware accelerator, or set of system features.</p>"},{"location":"guides/deployment-configurations/#compiler-target-backends","title":"Compiler target backends","text":"<p>Compiler target backends are used to generate executable code for hardware APIs and device architectures. Compiler targets may implement special optimizations or generate distinct code for certain device/architecture/performance profiles.</p> <p>When compiling programs, a list of target backends must be specified via</p> <ul> <li><code>--iree-hal-target-backends=</code> (command-line)</li> <li><code>target_backends=[...]</code> (Python)</li> </ul> Target backend Description Compatible HAL devices <code>llvm-cpu</code> Code generation for CPU-like devices supported by LLVM <code>local-sync</code>, <code>local-task</code> <code>vmvx</code> Portable interpreter powered by a microkernel library <code>local-sync</code>, <code>local-task</code> <code>vulkan</code> or<code>vulkan-spirv</code> Portable GPU support via SPIR-V for Vulkan <code>vulkan</code> <code>cuda</code> NVIDIA GPU support via PTX for CUDA <code>cuda</code> <code>metal</code> or<code>metal-spirv</code> GPU support on Apple platforms via MSL for Metal <code>metal</code> <code>rocm</code> Experimental  AMD GPU support via HSACO for ROCm <code>rocm</code> <code>webgpu-wgsl</code> Experimental  GPU support on the Web via WGSL for WebGPU <code>webgpu</code> <p>Tip - listing available backends</p> <p>The list of compiler target backends can be queried:</p> Command-linePython bindings <pre><code>$ iree-compile --iree-hal-list-target-backends\n\nRegistered target backends:\n    cuda\n    llvm-cpu\n    metal\n    metal-spirv\n    rocm\n    vmvx\n    vmvx-inline\n    vulkan\n    vulkan-spirv\n</code></pre> <pre><code>iree.compiler.query_available_targets()\n\n['cuda',\n 'llvm-cpu',\n 'metal',\n 'metal-spirv',\n 'rocm',\n 'vmvx',\n 'vmvx-inline',\n 'vulkan',\n 'vulkan-spirv']\n</code></pre>"},{"location":"guides/deployment-configurations/#runtime-hal-driversdevices","title":"Runtime HAL drivers/devices","text":"<p>Runtime HAL devices call into hardware APIs to load and run executable code. Devices may use multithreading or other system resources, depending on their focus and the build configuration.</p> HAL device Description <code>local-sync</code> Synchronous local CPU device with inline execution <code>local-task</code> Multithreaded local CPU device using a 'task' executor <code>vulkan</code> Portable GPU execution using the Vulkan API <code>cuda</code> NVIDIA GPU execution using CUDA <code>metal</code> GPU execution on Apple platforms using Metal <code>rocm</code> Experimental  AMD GPU execution using ROCm <code>webgpu</code> Experimental  GPU execution on the web using WebGPU <p>Additional HAL drivers can also be defined external to the core project via <code>IREE_EXTERNAL_HAL_DRIVERS</code>.</p>"},{"location":"guides/deployment-configurations/bare-metal/","title":"Running on a bare-metal platform","text":"<p>IREE supports model execution via CPU on bare-metal platforms. Bare metal platforms have no operating system support, and executables are built using machine-specific linker scripts and/or board support packages (BSPs).</p> <p>Bare-metal deployment typically uses IREE's LLVM compiler target backend much like the CPU configuration, but using a limited subset of IREE's CPU HAL driver code at runtime to load and execute compiled programs.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#prerequisites","title":"Prerequisites","text":"<p>Out-of-tree bare-metal platform tools and source code for the system should be ready, such as</p> <ul> <li>Compilation toolchain</li> <li>Platform linker script</li> <li>Firmware libraries</li> </ul> <p>Please follow the instructions to retrieve the IREE compiler.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#compile-the-model-for-bare-metal","title":"Compile the model for bare-metal","text":"<p>The model can be compiled with the following command:</p> <pre><code>iree-compile \\\n--iree-stream-partitioning-favor=min-peak-memory \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-llvmcpu-target-triple=x86_64-pc-linux-elf \\\n--iree-llvmcpu-debug-symbols=false \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_cpu.vmfb\n</code></pre> <p>In which</p> <ul> <li><code>--iree-stream-partitioning-favor=min-peak-memory</code>: Optimize for minimum peak     memory usage at the cost of concurrency - include when targeting     single-threaded execution to reduce memory consumption.</li> <li><code>--iree-hal-target-backends=llvm-cpu</code>: Compile using the LLVM CPU target</li> <li><code>--iree-llvmcpu-target-triple</code>: Use the <code>&lt;arch&gt;-pc-linux-elf</code> LLVM target triple     so the artifact has a fixed ABI to be rendered by the     elf_module library</li> <li><code>--iree-llvmcpu-debug-symbols=false</code>: To reduce the artifact size</li> </ul> <p>See generate.sh for example command-line instructions of some common architectures.</p> <p>You can replace the MLIR file with the other MLIR model files, following the instructions.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#compiling-the-bare-metal-model-for-static-library-support","title":"Compiling the bare-metal model for static-library support","text":"<p>See the static_library demo sample for an example and instructions on running a model with IREE's <code>static_library_loader</code>.</p> <p>By default, the demo targets the host machine when compiling. To produce a bare-metal compatible model, run <code>iree-compile</code> as in the previous example and add the additional <code>-iree-llvmcpu-static-library-output-path=</code> flag to specify the static library destination. This will produce a <code>.h\\.o</code> file to link directly into the target application.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#build-bare-metal-runtime-from-source","title":"Build bare-metal runtime from source","text":"<p>A few CMake options and macros should be set to build a subset of IREE runtime libraries compatible with the bare-metal platform. We assume there's no multi-thread control nor system library support in the bare-metal system. The model execution is in a single-thread synchronous fashion.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#set-cmake-options","title":"Set CMake options","text":"<pre><code># Build the IREE runtime only\nset(IREE_BUILD_COMPILER OFF)\n\n# Tell CMake to skip targeting a specific operating system\nset(CMAKE_SYSTEM_NAME Generic)\n\n# Disable multi-thread library support\nset(IREE_ENABLE_THREADING OFF)\n\n# Only enable the local synchronous HAL driver\nset(IREE_HAL_DRIVER_DEFAULTS OFF)\nset(IREE_HAL_DRIVER_LOCAL_SYNC ON)\n\n# Only enable some executable loaders\nset(IREE_HAL_EXECUTABLE_LOADER_DEFAULTS OFF)\nset(IREE_HAL_EXECUTABLE_LOADER_EMBEDDED_ELF ON)\nset(IREE_HAL_EXECUTABLE_LOADER_VMVX_MODULE ON)\n\n# Only enable the embedded ELF executable plugin\nset(IREE_HAL_EXECUTABLE_PLUGIN_DEFAULTS OFF)\nset(IREE_HAL_EXECUTABLE_PLUGIN_EMBEDDED_ELF ON)\n\n# Disable tests until IREE supports running them on bare-metal platforms\nset(IREE_BUILD_TESTS OFF)\n\n# Build samples\nset(IREE_BUILD_SAMPLES ON)\n</code></pre> <p>Todo</p> <p>Clean the list up after #6353 is fixed.</p> <p>Also, set the toolchain-specific cmake file to match the tool path, target architecture, target abi, linker script, system library path, etc.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#define-iree-macros","title":"Define IREE macros","text":"<p>These macros should be defined, either in C/C++ or via CMake options like</p> <pre><code>set(MY_FLAGS \"-DIREE_PLATFORM_GENERIC=1\")\nset(CMAKE_C_FLAGS ${MY_FLAGS} ${CMAKE_C_FLAGS})\nset(CMAKE_CXX_FLAGS ${MY_FLAGS} ${CMAKE_CXX_FLAGS})\n</code></pre> Macro Description <code>IREE_PLATFORM_GENERIC</code> Let IREE build the runtime library without targeting a specific platform. <code>IREE_SYNCHRONIZATION_DISABLE_UNSAFE=1</code> Disable thread synchronization support.Must only be used if there's a single thread. <code>IREE_FILE_IO_ENABLE=0</code> Disable file I/O. <code>IREE_TIME_NOW_FN</code> A function to return the system time. For the bare-metal systems, it can be set as <code>IREE_TIME_NOW_FN=\\\"\\{ return 0;\\}\\\"</code> as there's no asynchronous wait handling. <code>IREE_WAIT_UNTIL_FN</code> A function to wait until the given time in nanoseconds. Must match the signature <code>bool(uint64_t nanos)</code> and return false if the wait failed. <p>Examples of how to setup the CMakeLists.txt and .cmake file:</p> <ul> <li>IREE RISC-V toolchain cmake</li> <li>IREE Bare-Metal Arm Sample</li> <li>IREE Bare-Metal RV32 Sample</li> </ul>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#bare-metal-execution-example","title":"Bare-metal execution example","text":"<p>See simple_embedding for generic platform to see how to use the IREE runtime library to build/run the IREE model for the bare-metal target.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/","title":"CPU deployment","text":"<p>IREE supports efficient program execution on CPU devices by using LLVM to compile all dense computations in each program into highly optimized CPU native instruction streams, which are embedded in one of IREE's deployable formats.</p> <p>To compile a program for CPU execution, pick one of IREE's supported executable formats:</p> Executable Format Description embedded ELF portable, high performance dynamic library system library platform-specific dynamic library (.so, .dll, etc.) VMVX reference target <p>At runtime, CPU executables can be loaded using one of IREE's CPU HAL drivers:</p> <ul> <li><code>local-task</code>: asynchronous, multithreaded driver built on IREE's \"task\"    system</li> <li><code>local-sync</code>: synchronous, single-threaded driver that executes work inline</li> </ul> <p>Todo</p> <p>Add IREE's CPU support matrix: what architectures are supported; what architectures are well optimized; etc.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#prerequisites","title":"Prerequisites","text":"","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#get-the-iree-compiler","title":"Get the IREE compiler","text":"","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"<p>Python packages are regularly published to PyPI. See the Python Bindings page for more details. The core <code>iree-compiler</code> package includes the LLVM-based CPU compiler:</p> Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install iree-compiler\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://iree.dev/pip-release-links.html \\\n--upgrade iree-compiler\n</code></pre> <p>Tip</p> <p><code>iree-compile</code> is installed to your python module installation path. If you pip install with the user mode, it is under <code>${HOME}/.local/bin</code>, or <code>%APPDATA%Python</code> on Windows. You may want to include the path in your system's <code>PATH</code> environment variable:</p> <pre><code>export PATH=${HOME}/.local/bin:${PATH}\n</code></pre>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for your host platform and the Android cross-compilation or iOS cross-compilation page if you are cross compiling for a mobile device. The <code>llvm-cpu</code> compiler backend is compiled in by default on all platforms.</p> <p>Ensure that the <code>IREE_TARGET_BACKEND_LLVM_CPU</code> CMake option is <code>ON</code> when configuring for the host.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>You will need to get an IREE runtime that supports the local CPU HAL driver, along with the appropriate executable loaders for your application.</p> <p>You can check for CPU support by looking for the <code>local-sync</code> and <code>local-task</code> drivers:</p> <pre><code>$ iree-run-module --list_drivers\n\n        cuda: CUDA (dynamic)\n  local-sync: Local execution using a lightweight inline synchronous queue\n  local-task: Local execution using the IREE multithreading task system\n      vulkan: Vulkan 1.x (dynamic)\n</code></pre>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for your host platform and the Android cross-compilation page if you are cross compiling for Android. The local CPU HAL drivers are compiled in by default on all platforms.</p> <p>Ensure that the <code>IREE_HAL_DRIVER_LOCAL_TASK</code> and <code>IREE_HAL_EXECUTABLE_LOADER_EMBEDDED_ELF</code> (or other executable loader) CMake options are <code>ON</code> when configuring for the target.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#compile-and-run-a-program","title":"Compile and run a program","text":"<p>With the requirements out of the way, we can now compile a model and run it.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run the following command to compile with the <code>llvm-cpu</code> target:</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=llvm-cpu \\\nmobilenet_iree_input.mlir -o mobilenet_cpu.vmfb\n</code></pre> <p>Tip - CPU targets</p> <p>The <code>--iree-llvmcpu-target-triple</code> flag tells the compiler to generate code for a specific type of CPU. You can see the list of supported targets with <code>iree-compile --iree-llvmcpu-list-targets</code>, or pass \"host\" to let LLVM infer the triple from your host machine (e.g. <code>x86_64-linux-gnu</code>).</p> <pre><code>$ iree-compile --iree-llvmcpu-list-targets\n\n  Registered Targets:\n    aarch64    - AArch64 (little endian)\n    aarch64_32 - AArch64 (little endian ILP32)\n    aarch64_be - AArch64 (big endian)\n    arm        - ARM\n    arm64      - ARM64 (little endian)\n    arm64_32   - ARM64 (little endian ILP32)\n    armeb      - ARM (big endian)\n    riscv32    - 32-bit RISC-V\n    riscv64    - 64-bit RISC-V\n    wasm32     - WebAssembly 32-bit\n    wasm64     - WebAssembly 64-bit\n    x86        - 32-bit X86: Pentium-Pro and above\n    x86-64     - 64-bit X86: EM64T and AMD64\n</code></pre> <p>Tip - CPU features</p> <p>The <code>--iree-llvmcpu-target-cpu-features</code> flag tells the compiler to generate code using certain CPU \"features\", like SIMD instruction sets. Like the target triple, you can pass \"host\" to this flag to let LLVM infer the features supported by your host machine.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#run-a-compiled-program","title":"Run a compiled program","text":"<p>In the build directory, run the following command:</p> <pre><code>tools/iree-run-module \\\n--device=local-task \\\n--module=mobilenet_cpu.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/gpu-cuda/","title":"GPU deployment using CUDA","text":"<p>IREE can accelerate model execution on Nvidia GPUs using CUDA.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#prerequisites","title":"Prerequisites","text":"<p>In order to use CUDA to drive the GPU, you need to have a functional CUDA environment. It can be verified by the following steps:</p> <pre><code>nvidia-smi | grep CUDA\n</code></pre> <p>If <code>nvidia-smi</code> does not exist, you will need to install the latest CUDA Toolkit SDK.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#get-the-iree-compiler","title":"Get the IREE compiler","text":"","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"<p>Python packages are regularly published to PyPI. See the Python Bindings page for more details. The core <code>iree-compiler</code> package includes the CUDA compiler:</p> Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install iree-compiler\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://iree.dev/pip-release-links.html \\\n--upgrade iree-compiler\n</code></pre> <p>Tip</p> <p><code>iree-compile</code> is installed to your python module installation path. If you pip install with the user mode, it is under <code>${HOME}/.local/bin</code>, or <code>%APPDATA%Python</code> on Windows. You may want to include the path in your system's <code>PATH</code> environment variable:</p> <pre><code>export PATH=${HOME}/.local/bin:${PATH}\n</code></pre>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build the IREE compiler, then enable the CUDA compiler target with the <code>IREE_TARGET_BACKEND_CUDA</code> option.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>Next you will need to get an IREE runtime that includes the CUDA HAL driver.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE from source, then enable the CUDA HAL driver with the <code>IREE_HAL_DRIVER_CUDA</code> option.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#compile-and-run-a-program-model","title":"Compile and run a program model","text":"<p>With the compiler and runtime ready, we can now compile programs and run them on GPUs.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run one of the following commands to compile:</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=cuda \\\n--iree-hal-cuda-llvm-target-arch=&lt;...&gt; \\\nmobilenet_iree_input.mlir -o mobilenet_cuda.vmfb\n</code></pre> <p>Note that a cuda target architecture (<code>iree-hal-cuda-llvm-target-arch</code>) of the form <code>sm_&lt;arch_number&gt;</code> is needed to compile towards each GPU architecture. If no architecture is specified then we will default to <code>sm_35</code>.</p> <p>Here is a table of commonly used architectures:</p> CUDA GPU Target Architecture Nvidia K80 <code>sm_35</code> Nvidia P100 <code>sm_60</code> Nvidia V100 <code>sm_70</code> Nvidia A100 <code>sm_80</code>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda/#run-a-compiled-program","title":"Run a compiled program","text":"<p>Run the following command:</p> <pre><code>iree-run-module \\\n--device=cuda \\\n--module=mobilenet_cuda.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-metal/","title":"GPU deployment using Metal","text":"<p>Documentation coming soon!</p>","tags":["GPU","iOS"]},{"location":"guides/deployment-configurations/gpu-rocm/","title":"GPU deployment using ROCm","text":"<p>IREE can accelerate model execution on AMD GPUs using ROCm.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#prerequisites","title":"Prerequisites","text":"<p>In order to use ROCm to drive the GPU, you need to have a functional ROCm environment. It can be verified by the following steps:</p> <pre><code>rocm-smi | grep rocm\n</code></pre> <p>If <code>rocm-smi</code> does not exist, you will need to install the latest ROCm Toolkit SDK for Windows or Linux.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#get-the-iree-compiler","title":"Get the IREE compiler","text":"","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"<p>Currently ROCm is NOT supported for the Python interface.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build the IREE compiler, then enable the ROCm compiler target with the <code>IREE_TARGET_BACKEND_ROCM</code> option.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>Next you will need to get an IREE runtime that includes the ROCm HAL driver.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE from source, then enable the experimental ROCm HAL driver with the <code>IREE_EXTERNAL_HAL_DRIVERS=rocm</code> option.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#compile-and-run-a-program-model","title":"Compile and run a program model","text":"<p>With the compiler and runtime ready, we can now compile programs and run them on GPUs.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run one of the following commands to compile:</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=rocm \\\n--iree-rocm-target-chip=&lt;...&gt; \\\n--iree-rocm-link-bc=true \\\n--iree-rocm-bc-dir=&lt;...&gt; \\\nmobilenet_iree_input.mlir -o mobilenet_rocm.vmfb\n</code></pre> <p>Note ROCm Bitcode Dir (<code>iree-rocm-bc-dir</code>) path is required. If the system you are compiling IREE in has ROCm installed, then the default value of <code>/opt/rocm/amdgcn/bitcode</code> will usually suffice. If you intend on building ROCm compiler in a non-ROCm capable system, please set <code>iree-rocm-bc-dir</code> to the absolute path where you might have saved the amdgcn bitcode.</p> <p>Note that a ROCm target chip (<code>iree-rocm-target-chip</code>) of the form <code>gfx&lt;arch_number&gt;</code> is needed to compile towards each GPU architecture. If no architecture is specified then we will default to <code>gfx908</code>.</p> <p>Here is a table of commonly used architectures:</p> AMD GPU Target Chip AMD MI25 <code>gfx900</code> AMD MI50 <code>gfx906</code> AMD MI60 <code>gfx906</code> AMD MI100 <code>gfx908</code>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-rocm/#run-a-compiled-program","title":"Run a compiled program","text":"<p>Run the following command:</p> <pre><code>iree-run-module \\\n--device=rocm \\\n--module=mobilenet_rocm.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p>","tags":["GPU"]},{"location":"guides/deployment-configurations/gpu-vulkan/","title":"GPU deployment using Vulkan","text":"<p>IREE can accelerate model execution on GPUs via Vulkan, a low-overhead graphics and compute API. Vulkan is cross-platform: it is available on many operating systems, including Android, Linux, and Windows. Vulkan is also cross-vendor: it is supported by most GPU vendors, including AMD, ARM, Intel, NVIDIA, and Qualcomm.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#support-matrix","title":"Support matrix","text":"<p>As IREE and the compiler ecosystem it operates within matures, more target specific optimizations will be implemented. At this stage, expect reasonable performance across all GPUs and for improvements to be made over time for specific vendors and architectures.</p> GPU Vendor Category Performance Focus Architecture ARM Mali GPU Mobile Good Valhall Qualcomm Adreno GPU Mobile Reasonable 640+ AMD GPU Desktop/server Reasonable - NVIDIA GPU Desktop/server Good -","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#prerequisites","title":"Prerequisites","text":"<p>In order to use Vulkan to drive the GPU, you need to have a functional Vulkan environment. IREE requires Vulkan 1.1 on Android and 1.2 elsewhere. It can be verified by the following steps:</p> Android Linux Windows <p>Android mandates Vulkan 1.1 support since Android 10. You just need to make sure the device's Android version is 10 or higher.</p> <p>Run the following command in a shell:</p> <pre><code>vulkaninfo | grep apiVersion\n</code></pre> <p>If <code>vulkaninfo</code> does not exist, you will need to install the latest Vulkan SDK. Installing via LunarG's package repository is recommended, as it places Vulkan libraries and tools under system paths so it's easy to discover.</p> <p>If the listed version is lower than Vulkan 1.2, you will need to update the driver for your GPU.</p> <p>Run the following command in a shell:</p> <pre><code>vulkaninfo | grep apiVersion\n</code></pre> <p>If <code>vulkaninfo</code> does not exist, you will need to install the latest Vulkan SDK.</p> <p>If the listed version is lower than Vulkan 1.2, you will need to update the driver for your GPU.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#get-the-iree-compiler","title":"Get the IREE compiler","text":"<p>Vulkan expects the program running on GPU to be expressed by the SPIR-V binary exchange format, which the model must be compiled into.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"<p>Python packages are regularly published to PyPI. See the Python Bindings page for more details. The core <code>iree-compiler</code> package includes the SPIR-V compiler:</p> Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install iree-compiler\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://iree.dev/pip-release-links.html \\\n--upgrade iree-compiler\n</code></pre> <p>Tip</p> <p><code>iree-compile</code> is installed to your python module installation path. If you pip install with the user mode, it is under <code>${HOME}/.local/bin</code>, or <code>%APPDATA%Python</code> on Windows. You may want to include the path in your system's <code>PATH</code> environment variable:</p> <pre><code>export PATH=${HOME}/.local/bin:${PATH}\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for your host platform and the Android cross-compilation page if you are cross compiling for Android. The SPIR-V compiler backend is compiled in by default on all platforms.</p> <p>Ensure that the <code>IREE_TARGET_BACKEND_VULKAN_SPIRV</code> CMake option is <code>ON</code> when configuring for the host.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>Next you will need to get an IREE runtime that supports the Vulkan HAL driver.</p> <p>You can check for Vulkan support by looking for a matching driver and device:</p> <pre><code>$ iree-run-module --list_drivers\n\n        cuda: CUDA (dynamic)\n  local-sync: Local execution using a lightweight inline synchronous queue\n  local-task: Local execution using the IREE multithreading task system\n      vulkan: Vulkan 1.x (dynamic)\n</code></pre> <pre><code>$ iree-run-module --list_devices\n\n  cuda://GPU-00000000-1111-2222-3333-444444444444\n  local-sync://\n  local-task://\n  vulkan://00000000-1111-2222-3333-444444444444\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for Linux/Windows and the Android cross-compilation page for Android. The Vulkan HAL driver is compiled in by default on non-Apple platforms.</p> <p>Ensure that the <code>IREE_HAL_DRIVER_VULKAN</code> CMake option is <code>ON</code> when configuring for the target.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#compile-and-run-a-program","title":"Compile and run a program","text":"<p>With the SPIR-V compiler and Vulkan runtime, we can now compile programs and run them on GPUs.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run the following command to compile with the <code>vulkan-spirv</code> target:</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=vulkan-spirv \\\n--iree-vulkan-target-triple=&lt;...&gt; \\\nmobilenet_iree_input.mlir -o mobilenet_vulkan.vmfb\n</code></pre> <p>Note</p> <p>A target triple of the form <code>&lt;vendor/arch&gt;-&lt;product&gt;-&lt;os&gt;</code> is needed to compile towards each GPU architecture. If no triple is specified then a safe but more limited default will be used. We don't support the full spectrum here<sup>1</sup>; the following table summarizes the currently recognized ones:</p> GPU Vendor Target Triple ARM Mali GPU e.g., <code>valhall-g78-android30</code> Qualcomm Adreno GPU e.g., <code>adreno-unknown-android30</code> AMD GPU e.g., <code>rdna1-5700xt-linux</code> NVIDIA GPU e..g, <code>ampere-rtx3080-windows</code> SwiftShader CPU <code>cpu-swiftshader-unknown</code>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#run-a-compiled-program","title":"Run a compiled program","text":"<p>In the build directory, run the following command:</p> <pre><code>tools/iree-run-module \\\n--device=vulkan \\\n--module=mobilenet_vulkan.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p> <ol> <li> <p>It's also impossible to capture all details of a Vulkan implementation with a target triple, given the allowed variances on extensions, properties, limits, etc. So the target triple is just an approximation for usage.\u00a0\u21a9</p> </li> </ol>","tags":["GPU","Vulkan"]},{"location":"guides/ml-frameworks/","title":"ML frameworks","text":"<p>IREE supports popular machine learning frameworks using the same underlying technology.</p> <pre><code>graph LR\n  accTitle: ML framework to runtime deployment workflow overview\n  accDescr {\n    Programs start in some ML framework.\n    Programs are imported into MLIR.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  A[ML frameworks]\n  B[Imported MLIR]\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>"},{"location":"guides/ml-frameworks/#supported-frameworks","title":"Supported frameworks","text":"<p>See end-to-end examples of how to use each framework with IREE:</p> <ul> <li> TensorFlow and    TensorFlow Lite</li> <li> JAX</li> <li> PyTorch</li> </ul> <p>Importing from other frameworks is planned - stay tuned!</p>"},{"location":"guides/ml-frameworks/#samples","title":"Samples","text":"<p>Check out the samples in IREE's <code>samples/</code> directory, as well as the iree-samples repository.</p>"},{"location":"guides/ml-frameworks/#exportimport","title":"Export/Import","text":"<p>Each machine learning framework has some \"export\" mechanism that snapshots the structure and data in your program. These exported programs can then be \"imported\" into IREE's compiler by using either a stable import format or one of IREE's importer tools.</p> <p>This export/import process is specific to each frontend and typically involves a number of stages:</p> <ol> <li>Capture/trace/freeze the ML model into a graph</li> <li>Write that graph to an interchange format (e.g. SavedModel, TorchScript)</li> <li>Load the saved program into an import tool and convert to MLIR</li> <li>Legalize the graph's operations so only IREE-compatible operations remain</li> <li>Write the imported MLIR to a file</li> </ol> <p>This fully imported form can then be compiled indepedently of the source language and framework.</p>"},{"location":"guides/ml-frameworks/#compilation","title":"Compilation","text":"<p>IREE compiles MLIR files for specified sets of backends (CPU, GPU, etc). Each backend generates optimized native code custom to the input program and intended target platform. Once compiled, modules can be executed using IREE's runtime.</p> <p>See the deployment configuration guides for details on selecting a compiler backend and tuning options for your choice of target platform(s) or device(s).</p>"},{"location":"guides/ml-frameworks/#execution","title":"Execution","text":"<p>Compiled modules can be executed by selecting what compute devices to use, loading the module, and then executing it with the intended inputs. IREE provides several language bindings for its runtime API.</p>"},{"location":"guides/ml-frameworks/jax/","title":"JAX integration","text":"<p>Note</p> <p>IREE's JAX support is under active development. This page is still under construction.</p>","tags":["Python","JAX"]},{"location":"guides/ml-frameworks/jax/#overview","title":"Overview","text":"<p>IREE offers two ways to interface with JAX programs:</p> <ul> <li>An API for extracting and compiling full models ahead of time (AOT) for   execution apart from JAX. This API is being developed in the   iree-org/iree-jax repository.</li> <li>A PJRT plugin that adapts IREE as a native JAX backend for online / just in   time (JIT) use. This plugin is being developed in the   openxla/openxla-pjrt-plugin repository.</li> </ul>","tags":["Python","JAX"]},{"location":"guides/ml-frameworks/pytorch/","title":"PyTorch + IREE =","text":"<p>Caution - under development</p> <p>We are still validating and fixing specific models. Between bug fixes in flight and releases running behind, we don't expect that you will be able to do a lot of advanced things without using nightly releases or working with us.</p> <p>Stay tuned and join the discussion in our Discord server's <code>#pytorch</code> channel.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#overview","title":"Overview","text":"<p>SHARK-Turbine offers a tight integration between compatible versions of IREE, torch-mlir, and PyTorch.</p> <ul> <li> Seamless integration with standard PyTorch workflows</li> <li> Deployment support for running PyTorch models on cloud and edge devices</li> <li> General purpose model compilation and execution tools</li> </ul> <p>Both just-in-time (JIT) and ahead-of-time (AOT) workflows are supported:</p> <pre><code>graph LR\n  accTitle: PyTorch integration overview\n  accDescr {\n    PyTorch programs can be optimized within a Python session with\n    SHARK-Turbine's just-in-time tools.\n    PyTorch programs can be exported out of Python to native binaries using\n    SHARK-Turbine's ahead-of-time export toolkit.\n  }\n\n  subgraph Python\n    pytorch(PyTorch)\n    subgraph turbine [SHARK-Turbine]\n      jit(\"Eager execution (JIT)\")\n      aot(\"Export toolkit (AOT)\")\n    end\n\n    pytorch --&gt; jit\n    jit --&gt; pytorch\n    pytorch --&gt; aot\n  end\n\n  subgraph Native\n    binary([\"binary (.vmfb)\"])\n  end\n\n  aot -.-&gt; binary</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#prerequisites","title":"Prerequisites","text":"<p>Install Turbine and its requirements:</p> <pre><code>python -m pip install shark-turbine\n</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#just-in-time-jit-execution","title":"Just-in-time (JIT) execution","text":"<p>Just-in-time integration allows for Python code using TorchDynamo to optimize PyTorch models/functions using IREE, all within an interactive Python session.</p> <pre><code>graph TD\n  accTitle: PyTorch JIT workflow overview\n  accDescr {\n    Programs start as either PyTorch nn.Module objects or callable functions.\n    Programs are compiled into optimized modules using torch.compile.\n    Within torch.compile, Dynamo runs the program through Turbine and IREE.\n  }\n\n  subgraph Python\n    input([nn.Module / function])\n\n    subgraph compile [\"torch.compile()\"]\n      direction LR\n      dynamo{{TorchDynamo}}\n      turbine{{SHARK-Turbine}}\n      iree{{IREE}}\n      dynamo --&gt; turbine --&gt; iree\n    end\n\n    output([Optimized module])\n    input --&gt; compile --&gt; output\n  end</code></pre> <p>For deployment outside of Python, see the ahead-of-time sections below.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#quickstart","title":"Quickstart","text":"<p>Turbine integrates into PyTorch as a custom backend for <code>torch.compile</code>.</p> <p>Behind the scenes, PyTorch captures the structure of the input model into a computation graph and feeds that graph through to the selected backend compiler.</p> <pre><code>import torch\n\n# Define the `nn.Module` or Python function to run.\nclass LinearModule(torch.nn.Module):\n  def __init__(self, in_features, out_features):\n    super().__init__()\n    self.weight = torch.nn.Parameter(torch.randn(in_features, out_features))\n    self.bias = torch.nn.Parameter(torch.randn(out_features))\n\n  def forward(self, input):\n    return (input @ self.weight) + self.bias\n\nlinear_module = LinearModule(4, 3)\n\n# Compile the program using the turbine backend.(1)\nopt_linear_module = torch.compile(linear_module, backend=\"turbine_cpu\")\n\n# Use the compiled program as you would the original program.\nargs = torch.randn(4)\nturbine_output = opt_linear_module(args)\n</code></pre> <ol> <li>Initial integration only supports CPU, but support for many of IREE's other    targets is coming soon.</li> </ol>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#samples","title":"Samples","text":"Code samples JIT compilation notebook Simple MLP eager <code>examples/eager_mlp/mlp_eager_simple.py</code>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#ahead-of-time-aot-export","title":"Ahead-of-time (AOT) export","text":"<p>The ahead-of-time toolkit allows developers to define a program's structure in Python and then export deployment-ready artifacts that can be used in IREE's deployment configurations via the API bindings.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#simple-api","title":"Simple API","text":"<p>For simple models, a one-shot export API is available.</p> <pre><code>graph LR\n  accTitle: PyTorch simple AOT workflow overview\n  accDescr {\n    Programs start as PyTorch nn.Module objects.\n    Modules are exported using the \"aot\" API.\n    Exported outputs are then compiled to .vmfb files with executable binaries.\n  }\n\n  subgraph Python\n    input([nn.Module])\n    export([\"ExportOutput (MLIR)\"])\n    input -- \"aot.export()\" --&gt; export\n  end\n\n  subgraph Native\n    binary([\"binary (.vmfb)\"])\n  end\n\n  export -. \"compile()\" .-&gt; binary</code></pre> <pre><code>import iree.runtime as ireert\nimport numpy as np\nimport shark_turbine.aot as aot\nimport torch\n\n# Define the `nn.Module` to export.\nclass LinearModule(torch.nn.Module):\n  def __init__(self, in_features, out_features):\n    super().__init__()\n    self.weight = torch.nn.Parameter(torch.randn(in_features, out_features))\n    self.bias = torch.nn.Parameter(torch.randn(out_features))\n\n  def forward(self, input):\n    return (input @ self.weight) + self.bias\n\nlinear_module = LinearModule(4, 3)\n\n# Export the program using the simple API.\nexample_arg = torch.randn(4)\nexport_output = aot.export(linear_module, example_arg)\n\n# Compile to a deployable artifact.\nbinary = export_output.compile(save_to=None)\n\n# Use the IREE runtime API to test the compiled program.\nconfig = ireert.Config(\"local-task\")\nvm_module = ireert.load_vm_module(\n    ireert.VmModule.wrap_buffer(config.vm_instance, binary.map_memory()),\n    config,\n)\ninput = np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float32)\nresult = vm_module.main(input)\nprint(result.to_host())\n</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#samples_1","title":"Samples","text":"Code samples Simple AOT export notebook Simple MLP export <code>examples/aot_mlp/mlp_export_simple.py</code>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#advanced-api","title":"Advanced API","text":"<p>For more complex models, an underlying advanced API is available that gives access to more features.</p> <pre><code>graph LR\n  accTitle: PyTorch advanced AOT workflow overview\n  accDescr {\n    Programs are represented using the aot.CompiledModule class.\n    CompiledModules can extend nn.Module objects, export globals, and set\n    shapes and dtypes for each function.\n    Modules are exported using the \"aot\" API.\n    Exported outputs are then compiled to .vmfb files with executable binaries.\n  }\n\n  subgraph Python\n    compiledmodule(\"aot.CompiledModule\\n\\n- extend nn.Module\\n- export globals\\n- set shapes/dtypes\")\n    export([\"ExportOutput (MLIR)\"])\n    compiledmodule -- \"aot.export()\" --&gt; export\n  end\n\n  subgraph Native\n    binary([\"binary (.vmfb)\"])\n  end\n\n  export -. \"compile()\" .-&gt; binary</code></pre> <p>Advanced export workflows can use the <code>aot.CompiledModule</code> class to define and constrain the structure of a program prior to compiling it.</p> <pre><code>import shark_turbine.aot as aot\n\n# A minimal program, with no functions or variables.\nclass BasicModule(aot.CompiledModule):\n  ...\n\n# Create an instance of the program and convert it to MLIR.\nfrom iree.compiler.ir import Context\ninstance = BasicModule(context=Context())\nmodule_str = str(aot.CompiledModule.get_mlir_module(instance))\n\nprint(module_str)\n# module @basic {\n# }\n</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#exporting-functions","title":"Exporting functions","text":"<p>Exported functions are the API entry points into a compiled program.</p> <p>Simple feed-forward neural networks used for inference may have a single exported function (typically called \"forward\"), while more complex programs can have multiple computation functions, initialization functions, \"backward\" methods for training, state management functions, debugging functions, etc.</p> <ul> <li> <p>Each instance method on a <code>aot.CompiledModule</code>-derived class is exported.   These instance methods can include calls to other <code>aot</code> components, such as   <code>aot.jittable</code> compute functions:</p> <pre><code>class GetOnesModule(aot.CompiledModule):\n  @aot.jittable\n  def compute_ones():\n    return torch.ones(3)\n\n  def get_ones(self):\n    return self.compute_ones()\n</code></pre> </li> <li> <p>Instance methods can use <code>aot.AbstractTensor</code> to specify data types:</p> <pre><code>class IntSumModule(aot.CompiledModule):\n  @aot.jittable\n  def compute_sum(a, b):\n    return a + b\n\n  def sum_int32(\n    self,\na=aot.AbstractTensor(2, dtype=torch.int32),\nb=aot.AbstractTensor(2, dtype=torch.int32),\n):\n    return self.compute_sum(a, b)\n</code></pre> </li> <li> <p>Shapes can be made dynamic using <code>aot.AbstractTensor</code> and <code>aot.jittable</code>   constraints:</p> <pre><code>class DynamicSumModule(aot.CompiledModule):\n  @aot.jittable\n  def compute_sum(a, b):\n    return a + b\n\n  def sum_dynamic(\n    self,\na=aot.AbstractTensor(None),\nb=aot.AbstractTensor(None),\n):\n    return self.compute_sum(\n        a,\n        b,\nconstraints=[\na.dynamic_dim(0) == b.dynamic_dim(0),\n],\n)\n</code></pre> </li> </ul>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#global-variables","title":"Global variables","text":"<p>Global variables are used to represent persistent state within a program instance.</p> <p>For example, they can be used to represent the weights and biases in a neural network, and exporting these as mutable variables can allow for setting their values independently at runtime.</p> <ul> <li> <p>Individual globals can be exported using <code>aot.export_global()</code>:</p> <pre><code>state_example = torch.tensor(0, dtype=torch.int32)\nupdate_example = torch.tensor(0, dtype=torch.int32)\n\nclass SampleModule(aot.CompiledModule):\n  value = aot.export_global(state_example, mutable=True)\n\n  def get_value(self):\n    return self.value\n\n  def update_value(self, new_value=aot.abstractify(update_example)):\n    self.value = new_value\n</code></pre> </li> <li> <p>All named parameters on a <code>nn.Module</code> can be exported using   <code>export_parameters()</code>:</p> <pre><code>class SimpleParams(torch.nn.Module):\n  def __init__(self):\n    super().__init__()\n    self.classifier = torch.nn.Linear(20, 30)\n\n  def forward(self, x):\n    return self.classifier(x)\n\nm = SimpleParams()\n\nclass SimpleParamsModule(aot.CompiledModule):\nparams = aot.export_parameters(m)\ncompute = aot.jittable(m.forward)\n\n  def run(self, x=aot.AbstractTensor(128, 20)):\n    return self.compute(x)\n\n# torch.nn.Linear has 'weight' and 'bias' variables:\n#   https://pytorch.org/docs/stable/generated/torch.nn.Linear.html\n# Add getters for both exported parameters.\ndef get_weight(self):\nreturn self.params[\"classifier.weight\"]\ndef get_bias(self):\nreturn self.params[\"classifier.bias\"]\n</code></pre> </li> </ul>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#samples_2","title":"Samples","text":"Code samples Advanced AOT export notebook PyTorch dynamic shapes notebook Unit tests <code>tests/aot/</code> Dynamic MLP export <code>examples/aot_mlp/mlp_export_dynamic.py</code> llama2 inference example <code>examples/llama2_inference/stateless_llama.py</code>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#alternate-workflows","title":"Alternate workflows","text":"<p>Caution - These are due for migration to SHARK-Turbine.</p> Code samples (Deprecated) Inference on BERT","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#native-on-device-training","title":"Native / on-device training","text":"<p>A small (~100-250KB), self-contained binary can be built for deploying to resource-constrained environments without a Python interpreter.</p> Example scripts Basic Inference and Training Example Native On-device Training Example","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/tensorflow/","title":"TensorFlow integration","text":"","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#overview","title":"Overview","text":"<p>IREE supports compiling and running TensorFlow programs represented as <code>tf.Module</code> classes or stored in the <code>SavedModel</code> format.</p> <pre><code>graph LR\n  accTitle: TensorFlow to runtime deployment workflow overview\n  accDescr {\n    Programs start as either TensorFlow SavedModel or tf.Module programs.\n    Programs are imported into MLIR as StableHLO.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  subgraph A[TensorFlow]\n    direction TB\n    A1[SavedModel]\n    A2[tf.Module]\n\n    A1 --- A2\n  end\n\n  subgraph B[MLIR]\n    B1[StableHLO]\n  end\n\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A -- iree-import-tf --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Install TensorFlow by following the     official documentation:</p> <pre><code>python -m pip install tf-nightly\n</code></pre> </li> <li> <p>Install IREE packages, either by     building from source     or from pip:</p> Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install \\\niree-compiler \\\niree-runtime \\\niree-tools-tf\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://iree.dev/pip-release-links.html \\\n--upgrade \\\niree-compiler \\\niree-runtime \\\niree-tools-tf\n</code></pre> </li> </ol>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#importing-models","title":"Importing models","text":"<p>IREE compilers transform a model into its final deployable format in several sequential steps. The first step for a TensorFlow model is to use either the <code>iree-import-tf</code> command-line tool or IREE's Python APIs to import the model into a format (i.e., MLIR) compatible with the generic IREE compilers.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#from-savedmodel-on-tensorflow-hub","title":"From SavedModel on TensorFlow Hub","text":"<p>IREE supports importing and using SavedModels from TensorFlow Hub.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#using-the-command-line-tool","title":"Using the command-line tool","text":"<p>First download the SavedModel and load it to get the serving signature, which is used as the entry point for IREE compilation flow:</p> <pre><code>import tensorflow.compat.v2 as tf\nloaded_model = tf.saved_model.load('/path/to/downloaded/model/')\nprint(list(loaded_model.signatures.keys()))\n</code></pre> <p>Note</p> <p>If there are no serving signatures in the original SavedModel, you may add them by yourself by following \"Missing serving signature in SavedModel\".</p> <p>Then you can import the model with <code>iree-import-tf</code>. You can read the options supported via <code>iree-import-tf -help</code>. Using MobileNet v2 as an example and assuming the serving signature is <code>predict</code>:</p> <pre><code>iree-import-tf\n  --tf-import-type=savedmodel_v1 \\\n--tf-savedmodel-exported-names=predict \\\n/path/to/savedmodel -o iree_input.mlir\n</code></pre> <p>Tip</p> <p><code>iree-import-tf</code> is installed as <code>/path/to/python/site-packages/iree/tools/tf/iree-import-tf</code>. You can find out the full path to the <code>site-packages</code> directory via the <code>python -m site</code> command.</p> <p>Tip</p> <p><code>-tf-import-type</code> needs to match the SavedModel version. You can try both v1 and v2 if you see one of them gives an empty dump.</p> <p>Next, you can compile the model in <code>iree_input.mlir</code> for one of IREE's supported targets by following one of the deployment configuration guides.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#samples","title":"Samples","text":"Colab notebooks Training an MNIST digits classifier Edge detection Pretrained ResNet50 inference TensorFlow Hub import <p>End-to-end execution tests can be found in IREE's integrations/tensorflow/e2e/ directory.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#troubleshooting","title":"Troubleshooting","text":"","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#missing-serving-signature-in-savedmodel","title":"Missing serving signature in SavedModel","text":"<p>Sometimes SavedModels are exported without explicit serving signatures. This happens by default for TensorFlow Hub SavedModels. However, serving signatures are required as entry points for IREE compilation flow. You can use Python to load and re-export the SavedModel to give it serving signatures. For example, for MobileNet v2, assuming we want the serving signature to be <code>predict</code> and operating on a 224x224 RGB image:</p> <pre><code>import tensorflow.compat.v2 as tf\nloaded_model = tf.saved_model.load('/path/to/downloaded/model/')\ncall = loaded_model.__call__.get_concrete_function(\n         tf.TensorSpec([1, 224, 224, 3], tf.float32))\nsignatures = {'predict': call}\ntf.saved_model.save(loaded_model,\n  '/path/to/resaved/model/', signatures=signatures)\n</code></pre> <p>The above will create a new SavedModel with a serving signature, <code>predict</code>, and save it to <code>/path/to/resaved/model/</code>.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/","title":"TensorFlow Lite integration","text":"","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#overview","title":"Overview","text":"<p>IREE supports compiling and running TensorFlow Lite (TFLite) programs stored as TFLite FlatBuffers. These files can be imported into an IREE-compatible format then compiled to a series of backends.</p> <pre><code>graph LR\n  accTitle: TFLite to runtime deployment workflow overview\n  accDescr {\n    Programs start as TensorFlow Lite FlatBuffers.\n    Programs are imported into MLIR's TOSA dialect using iree-import-tflite.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  subgraph A[TFLite]\n    A1[FlatBuffer]\n  end\n\n  subgraph B[MLIR]\n    B1[TOSA]\n  end\n\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A -- iree-import-tflite --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Install TensorFlow by following the     official documentation:</p> <pre><code>python -m pip install tf-nightly\n</code></pre> </li> <li> <p>Install IREE packages, either by     building from source     or from pip:</p> Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install \\\niree-compiler \\\niree-runtime \\\niree-tools-tflite\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://iree.dev/pip-release-links.html \\\n--upgrade \\\niree-compiler \\\niree-runtime \\\niree-tools-tflite\n</code></pre> </li> </ol>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#importing-and-compiling","title":"Importing and Compiling","text":"<p>IREE's tooling is divided into two components: import and compilation.</p> <ol> <li>The import tool converts the TFLite FlatBuffer to an IREE compatible form,   validating that only IREE compatible operations remain. Containing a combination   of TOSA and IREE operations.</li> <li>The compilation stage generates the bytecode module for a list of targets,   which can be executed by IREE.</li> </ol>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#using-command-line-tools","title":"Using Command Line Tools","text":"<p>These two stages can be completed entirely via the command line.</p> <pre><code>WORKDIR=\"/tmp/workdir\"\nTFLITE_URL=\"https://storage.googleapis.com/iree-model-artifacts/tflite-integration-tests/posenet_i8.tflite\"\nTFLITE_PATH=${WORKDIR}/model.tflite\nIMPORT_PATH=${WORKDIR}/tosa.mlir\nMODULE_PATH=${WORKDIR}/module.vmfb\n\n# Fetch the sample model\nwget ${TFLITE_URL} -O ${TFLITE_PATH}\n\n# Import the sample model to an IREE compatible form\niree-import-tflite ${TFLITE_PATH} -o ${IMPORT_PATH}\n\n# Compile for the CPU backend\niree-compile \\\n--iree-input-type=tosa \\\n--iree-hal-target-backends=llvm-cpu \\\n${IMPORT_PATH} \\\n-o ${MODULE_PATH}\n</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#using-the-python-api","title":"Using the Python API","text":"<p>The example below demonstrates downloading, compiling, and executing a TFLite model using the Python API. This includes some initial setup to declare global variables, download the sample module, and download the sample inputs.</p> <p>Declaration of absolute paths for the sample repo and import all required libraries. The default setup uses the CPU backend as the only target. This can be reconfigured to select alternative targets.</p> <pre><code>import iree.compiler.tflite as iree_tflite_compile\nimport iree.runtime as iree_rt\nimport numpy\nimport os\nimport urllib.request\n\nfrom PIL import Image\n\nworkdir = \"/tmp/workdir\"\nos.makedirs(workdir, exist_ok=True)\n\ntfliteFile = \"/\".join([workdir, \"model.tflite\"])\njpgFile = \"/\".join([workdir, \"input.jpg\"])\ntfliteIR = \"/\".join([workdir, \"tflite.mlir\"])\ntosaIR = \"/\".join([workdir, \"tosa.mlir\"])\nbytecodeModule = \"/\".join([workdir, \"iree.vmfb\"])\n\nbackends = [\"llvm-cpu\"]\nconfig = \"local-task\"\n</code></pre> <p>The TFLite sample model and input are downloaded locally.</p> <pre><code>tfliteUrl = \"https://storage.googleapis.com/iree-model-artifacts/tflite-integration-tests/posenet_i8.tflite\"\njpgUrl = \"https://storage.googleapis.com/iree-model-artifacts/tflite-integration-tests/posenet_i8_input.jpg\"\n\nurllib.request.urlretrieve(tfliteUrl, tfliteFile)\nurllib.request.urlretrieve(jpgUrl, jpgFile)\n</code></pre> <p>Once downloaded we can compile the model for the selected backends. Both the TFLite and TOSA representations of the model are saved for debugging purposes. This is optional and can be omitted.</p> <pre><code>iree_tflite_compile.compile_file(\n  tfliteFile,\n  input_type=\"tosa\",\n  output_file=bytecodeModule,\n  save_temp_tfl_input=tfliteIR,\n  save_temp_iree_input=tosaIR,\n  target_backends=backends,\n  import_only=False)\n</code></pre> <p>After compilation is completed we configure the VmModule using the local-task configuration and compiled IREE module.</p> <pre><code>config = iree_rt.Config(\"local-task\")\ncontext = iree_rt.SystemContext(config=config)\nwith open(bytecodeModule, 'rb') as f:\n  vm_module = iree_rt.VmModule.from_flatbuffer(config.vm_instance, f.read())\n  context.add_vm_module(vm_module)\n</code></pre> <p>Finally, the IREE module is loaded and ready for execution. Here we load the sample image, manipulate to the expected input size, and execute the module. By default TFLite models include a single function named 'main'. The final results are printed.</p> <pre><code>im = numpy.array(Image.open(jpgFile).resize((192, 192))).reshape((1, 192, 192, 3))\nargs = [im]\n\ninvoke = context.modules.module[\"main\"]\niree_results = invoke(*args)\nprint(iree_results)\n</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#samples","title":"Samples","text":"<ul> <li> <p>The tflitehub folder in the iree-samples repository contains test scripts to compile, run, and compare various TensorFlow Lite models sourced from TensorFlow Hub.</p> </li> <li> <p>An example smoke test of the TensorFlow Lite C API is available here.</p> </li> </ul> Colab notebooks Text classification with TFLite and IREE","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#troubleshooting","title":"Troubleshooting","text":"<p>Failures during the import step usually indicate a failure to lower from TensorFlow Lite's operations to TOSA, the intermediate representation used by IREE. Many TensorFlow Lite operations are not fully supported, particularly those than use dynamic shapes. Please reach out on one of IREE's communication channels if you notice something missing.</p>","tags":["Python","TensorFlow"]},{"location":"reference/","title":"Reference pages","text":""},{"location":"reference/#api-bindings","title":"API bindings","text":"<p>IREE offers API bindings for compiling and running programs from various languages.</p> <ul> <li>Index page</li> </ul>"},{"location":"reference/#mlir-dialects","title":"MLIR dialects","text":"<p>Automatically generated documentation for the MLIR dialects defined in the IREE repository.</p> <ul> <li>Index page</li> </ul>"},{"location":"reference/#other-topics","title":"Other topics","text":"<ul> <li>Glossary</li> <li>Optimization options</li> <li>Extensions</li> </ul>"},{"location":"reference/extensions/","title":"Extension mechanisms","text":"<p>Note</p> <p>Much of this describes provisions for extension within IREE but until the core of the system has settled little work will be done to fully flesh-out and document them in detail. A large majority of things that would make someone want to extend IREE can instead be accomplished much easier and performantly using native MLIR dialects that are then processed by the IREE compiler.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#guidelines","title":"Guidelines","text":"<p>IREE has a compiler and runtime separation, a multi-layered architecture, and split between execution of \"host code\" that schedules compute-heavy work and SPMD \"device code\" that performs the bulk of compute operations. Each axis has a different set of extension mechanisms that can be used independently or combined.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#extension-philosophy","title":"Extension philosophy","text":"<p>Organized below are some of the mechanisms IREE provides for extending the core compiler and runtime and when they should(n't) be used. The goal of these progressively lower-level extension mechanisms is to make it easier for users to fall into the pit of success:</p> <p>Quote</p> <p>\"a well-designed system makes it easy to do the right things and annoying (but not impossible) to do the wrong things.\" - Jeff Atwood</p> <p>The amount of engineering complexity for initial bring-up and maintenance increases with each subsequently lower-level approach and it is best to start from the top and exit as fast as possible: this is a choose-your-own-adventure where you're trying to escape the dungeon with both the loot and your limbs . Avoid the temptation of immediately dropping down to making external C calls at runtime because that's how it's been done before as it's easier, more robust, and more performant to use the system as it is intended to be used.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#when-to-extend","title":"When to extend","text":"<p>The primary goal when extending any framework should first be to avoid extending it at all. There is no mechanism that is free - whether in terms of engineering effort to develop and maintain over time, include in compiler deployments, or include in runtime deployments. As a system scales in deployment configurations the available mechanisms for extension increase but so too does the chaos introduced by extensions that do not also scale with that design. Users are the only ones who can determine the tradeoffs they are willing to accept: for example, the mechanism to extend device code with a custom runtime call to a C function does not work on GPUs and gets significantly more complicated on CPUs as sandboxes/enclaves are used - but if the user scenario is for local process CPU-only execution that may not matter.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#where-to-extend-inputscompilerruntime","title":"Where to extend (inputs/compiler/runtime)","text":"<p>Consider in normal software development when one would choose to write more code (possibly packaging it into a reusable library) vs. changing the programming language or compiler they are using to compile their code vs. changing the operating systems their code runs on. The further one gets from the problem they are trying to solve the more work, coordination, and maintenance is involved and though there are reasons to make changes across the stack they should be done only when a simpler solution would not suffice.</p> <p>An author will retain more control over their logic the closer they sit to the inputs to the compiler. IREE provides several mechanisms that try to keep control with the author and robust to changes in IREE or MLIR internals and it is strongly encouraged that those looking to extend take those routes first. Contributions that help everyone are very welcome but do have a higher cost and it's often much easier to design and justify upstream changes with working examples in forks or at higher levels of the stack.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#where-to-extend-hostdevice","title":"Where to extend (host/device)","text":"<p>From a performance perspective the rule is to colocate code with the data it is acting on: tensor data, for example, should almost exclusively be manipulated by device code as tensors live on device. Attempting to use tensor data with host code will result in synchronization points and host/device transfers that can decimate performance. This can lead to seemingly paradoxical situations where swapping out compiler-generated code for a human-authored \"fast path\" can be slower than even the most naive compiler results. An important thing to keep in mind with compilers is that it is exceedingly difficult to produce code by hand that is consistently more performant across a broad range of deployments and the first temptation should always be to improve the compiler - extending it via other mechanisms when not required by the task is often just premature optimization.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#1-target-iree-input-dialects","title":"1. Target IREE input dialects","text":"<p>TL;DR</p> <p>Convert your custom ops into standard MLIR dialects.</p> <pre><code>+------------+      +--------+      +---------------+\n| Your input | -+-&gt; |  iree  | -+-&gt; | IREE compiler |\n+------------+  |   +--------+  |   +---------------+\n                |   +--------+  |\n                +-&gt; | linalg | -+\n                |   +--------+  |\n                |      ....     |\n</code></pre> <p>The easiest, cleanest, and most robust path to extend IREE is to make use of what MLIR is designed for: composing dialects and converting between them. IREE supports several input dialects such as <code>tosa</code>, <code>mhlo</code>, <code>linalg</code>, and the standard <code>arith</code>, <code>math</code>, <code>tensor</code>, and <code>scf</code> dialects. Any source IR that can be turned into that mix of dialects (directly or transitively) will work with the whole IREE pipeline for all deployment configurations and targets. If possible to express the computation in this form it will always be the best route to getting small deployments without the need to modify or include any additional code at runtime and run on all device types and execution modes.</p> <p>This mechanism can also be layered with any of the subsequent lower-level ones: if some part of the operation runs on the host and some part on device then decomposing it such that it contains as many standard ops for flow control as possible and linear algebra/custom ops for the dense math will reduce the engineering effort required on both sides and lead to an easier to maintain solution even if lower-level extension is required.</p> <p>A large majority of classic ML \"custom ops\" can be accomplished with this approach. When bringing up projects built on IREE it's best to concisely describe the operation in more elemental mathematical representations and then add optimizations where required knowing that things will still work even if those optimizations never happen.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#pros","title":"Pros","text":"<ul> <li>No IREE compiler or runtime code changes required.<ul> <li>Can use standard IREE packaged releases and tools.</li> <li>No versioning issues at runtime.</li> </ul> </li> <li>IREE's host/device partitioning can partition your code.</li> <li>Fusion and other compiler techniques (CSE/DCE/inlining/etc) work on your code.</li> <li>All target backends (CPU/GPU/accelerators/enclaves/etc) work.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#cons","title":"Cons","text":"<ul> <li>Input dialects cannot natively represent all possible programs (such as file   IO and other syscalls).</li> <li>Performance-sensitive host code (b-trees and other in-memory databases) will   run through the slower VM paths if not authored as dense compute.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#when-to-use","title":"When to use","text":"<ul> <li> Targeting multiple MLIR toolchains of which IREE is just   one (as little to no IREE-specific code is required).</li> <li> Operation represents host code in addition to device code.</li> <li> All code is known statically or symbolically at   compile-time (instead of independently versioned libraries at runtime).</li> <li> Complex high-performance code not representable as linear algebra.</li> <li> External runtime interactions (file/network/user IO). Use   custom modules.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#implementation","title":"Implementation","text":"<p>To make use of this approach one just needs to follow the standard MLIR dialect conversion behavior: add a dialect with ops, add a conversion pass, and run that pass before providing the resulting IR to the IREE compiler. See Creating a Dialect.</p> <p>Think of this like authoring C++ sources with templates that you compile into your application: Clang (and LLVM beyond) don't know about your library details and instead just process it as it would any other code. You can take the same source and pass it to GCC and it'll be robust to underlying changes in the system.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#2-extend-host-code-with-custom-modules","title":"2. Extend host code with custom modules","text":"<p>TL;DR</p> <p>Import MLIR functions in the compiler and custom modules at runtime.</p> <pre><code>// Main user module compiled by IREE:\nmodule @model {\n  // Declare a synchronous external function:\n  func.func private @my_custom_module.sync_func(%input: tensor&lt;?xf32&gt;) -&gt; i32\n  // Declare an asynchronous external function:\n  func.func private @my_custom_module.async_func(%input: tensor&lt;?xf32&gt;) -&gt; tensor&lt;?xf32&gt; attributes {\n    iree.abi.model = \"coarse-fences\",\n    nosideeffects\n  }\n  func.func @predict() {\n    ...\n    // Call a synchronous/blocking external function:\n    %sync_result = call @my_custom_module.sync_func(%sync_input) : (tensor&lt;?xf32&gt;) -&gt; i32\n    ...\n    ...\n    // Call an asynchronous/non-blocking external function:\n    %async_result = call @my_custom_module.async_func(%async_input) : (tensor&lt;?xf32&gt;) -&gt; tensor&lt;?xf32&gt;\n    ...\n  }\n}\n</code></pre> <p>IREE provides dynamic linking at runtime via its VM interfaces. For code that runs on the host and requires syscalls or calling out to existing libraries - such as file IO, text processing, and JPEG decoding - this is an easy way to interop without paying attention to the more complex details of device code. An IREE module compiled using custom modules is portable and dynamically deployable so long as the custom module is registered at runtime.</p> <p>This approach conceptually matches what normal native binaries do in an OS: imports are declared and at runtime they are resolved based on the available exports of modules in the system. Just as with normal systems engineering design of the API between modules is up to the user and depending on rigor can have several pitfalls but these problems and their solutions are not IREE specific and anyone who has designed a shared library interface can apply the same rules here in IREE around versioning, performance, etc. One does not add 2 integers via a syscall and the same holds here: custom modules and the functions within should perform a large amount of work to hide overheads involved in the cross-module calls and users must be aware that the compiler cannot optimize across the call boundaries.</p> <p>See the synchronous tensor I/O and asynchronous tensor I/O samples.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#pros_1","title":"Pros","text":"<ul> <li>No IREE compiler code changes required.</li> <li>Produced artifacts are portable across IREE deployment configurations.</li> <li>Full system access is allowed - the VM just calls external functions.</li> <li>Runtime modules can be implemented (via shims) in other languages/runtimes.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#cons_1","title":"Cons","text":"<ul> <li>Custom modules must be registered at runtime by the user.</li> <li>The VM custom module ABI goo must be authored by the user (such as with JNI or   pybind to move between java/python and C).</li> <li>All custom module code must be compiled and deployed regardless of how much   any modules use. The granularity of modules and their versioning is up to the   user.</li> <li>Custom module code cannot be optimized by the IREE compiler to avoid   host/device readbacks and unnecessary data type conversion.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#when-to-use_1","title":"When to use","text":"<ul> <li> Interactions with large libraries or system calls.</li> <li> Performance-sensitive host code that cannot easily be   represented as device code (like UTF-8 string transformation using libicu).</li> <li> Extensively using tensor resources.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#implementation_1","title":"Implementation","text":"<p>The runtime portion requires that the code be exported to the VM system by way of an <code>iree_vm_module_t</code> interface. A low-level native interface exists with minimal overhead and is used for example by the IREE HAL itself. There is also a C++ wrapper that is significantly easier to work with however it needs some performance improvements.</p> <p>Full end-to-end examples can be found under <code>samples/custom_modules/</code>:</p> <ul> <li>The basic sample shows how to add VM modules with custom types and take advantage of ABI features like fallback functions and optional imports.</li> <li>The synchronous tensor I/O sample shows a call taking and returning a tensor and performing blocking work.</li> <li>The asynchronous tensor I/O sample shows the same thing but with fences for asynchronous scheduling.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#3-extend-target-specific-device-conversion-patterns","title":"3. Extend target-specific device conversion patterns","text":"<p>TL;DR</p> <p>Add patterns to <code>iree/Compiler/Codegen/</code> to emit target code.</p> <p>The easiest and most robust path for specializations of device code is to emit such code mixed with the IREE compiler generated code at the highest possible level of abstraction within the target pipeline. For example, if the code can be represented with the <code>vector</code> dialect then inserting conversion patterns between <code>linalg</code> and <code>vector</code> enables the emitted code to be specialized further based on user configuration and optimized with the full set of available passes that run in the pipeline. For each level lower one goes the more flexibility they gain such as being able to emit inline assembly blocks that do anything while trading off generality and multi-targeting applicability.</p> <p>How much the tradeoff matters is based on the behavior of the extension. If a pattern changing a transcendental function to an approximation can operate at the vector level then all IREE deployment targets can benefit from the pattern and as new targets are made available they will automatically receive the benefits. In contrast, a pattern at the vector level that turns generic vector operations into architecture-specific LLVM intrinsics by its nature only pertains to a single target family and can be done at a lower level. As a rule of thumb if a particular pattern is going to need ~N implementations for ~N targets that are all mostly the same it's better to try to move that higher in the stack.</p> <p>At this point the complexity of extending things is still fairly constrained: a C++ pass or pattern is verified with normal lit tests and can be upstreamed easily either into MLIR or IREE (a large number of IREE patterns are upstreamed, benefiting all users of MLIR). Cross-compilation and versioning are not a factor and the IREE artifacts can be considered durable at a coarse level (outside of major target architectural changes).</p> <p>Note that depending on the target there are various mechanisms for representing code in MLIR, up to including inline assembly snippets in IR via <code>llvm.inline_asm</code>.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#pros_2","title":"Pros","text":"<ul> <li>Not limited to what is possible to represent in any particular MLIR dialect.</li> <li>Rich target configuration available; multiple passes can contribute info.</li> <li>Produced executable binaries are hermetic and no runtime changes are required.</li> <li>Specialization can happen in MLIR dialects like <code>linalg</code> or <code>vector</code> as well   as target-specific representations like SPIR-V and LLVM IR.</li> <li>The compiler can perform deep optimizations across both the generated code and   the provided code (hoisting/loop invariant code motion/cse/etc).</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#cons_2","title":"Cons","text":"<ul> <li>Requires implementing the patterns as code in the IREE compiler or via TBD   interfaces.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#when-to-use_2","title":"When to use","text":"<ul> <li> Code that must be emitted during target lowering - such as   something optimizing for a particular CPU architecture.</li> <li> Hot code mixed with generated code at a fine granularity   (within the innermost loop).</li> <li> External existing hand-authored libraries. Either statically   or dynamically link instead.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#implementation_2","title":"Implementation","text":"<p>There are several ways to author patterns and passes in MLIR. As examples:</p> <ul> <li>A majority of patterns are authored in C++ using PatternRewriter.</li> <li>PDL is an MLIR-based way to   express rewrite operations with strong typing, compile-time verification, and   easily-readable and less-verbose IR.</li> <li><code>linalg</code> uses a python-based DSL   for defining some of its extended ops.</li> </ul> <p>There are many examples within both MLIR and IREE, one specifically being the polynomial approximation expansion patterns.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#4-include-external-target-specific-device-code","title":"4. Include external target-specific device code","text":"<p>TL;DR</p> <p>Statically link external object files into IREE executables.</p> <p>For large bodies of existing device code or library calls that are available for static linkage the work involved to reimplement them at higher levels of the stack can be cost prohibitive even if it leads to better results. In these cases just as with a normal toolchain one would just want to declare an external function, call it, and add the object file to the linker command line. In IREE the same can be performed by way of taking compatible bitcode or native object files and linking them in with the generated code. An MLIR pattern would declare and emit the call and the target-specific IREE linker would pull in the objects.</p> <p>As the linking behavior varies per target (for example, some targets like SPIR-V don't have traditional linkers) how this is performed is up to the IREE target backends. The complexity involved in producing the object files to link will also vary per-backend and the complexity of the deployment: cross-compiling for multiple architectures or compilation modes (ASAN, etc) will require unique copies of the object files matching that precise configuration.</p> <p>At this point generality is largely out as is the ability to cleanly upstream such files. It should be apparent how a few dozen lines of C++ or PDL that avoids the need for any of this complexity is more appealing. In extremely specific cases of a single platform/architecture/version for a single program deployed via a specific artifact composition it's not so bad but IREE is designed such that extreme specificity is an optional mode of the more general solution. This does not mean this mechanism is not useful in some situations and only that it should be a last-resort when one of the easier to manage solutions is not viable - not a shortcut to avoid writing some C++ patterns.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#pros_3","title":"Pros","text":"<ul> <li>Works with hand-authored code in compatible object files from any toolchain.</li> <li>No IREE runtime changes required.<ul> <li>All deployment modes still work, including multi-targeting.</li> <li>No versioning concerns as custom code is included in artifacts.</li> </ul> </li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#cons_3","title":"Cons","text":"<ul> <li>Users must provide per-target precompiled object files on disk.</li> <li>IREE compiler changes are still needed for generating the external calls.</li> <li>Though LTO may be able to optimize across the calls it is not guaranteed.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#when-to-use_3","title":"When to use","text":"<ul> <li> Existing math libraries or architecture-specific functions   that cannot be ported into a more MLIR-friendly form.</li> <li> Mixing in hand-authored code written in C/rust/etc with   generated code from MLIR.</li> <li> External code can be represented as either <code>linalg</code>,   <code>vector</code>, or LLVM IR. Use target-specific conversion patterns instead.</li> <li> External code size is large and unlikely to benefit from   link-time optimizations (such as something like libjpeg). Dynamically link   instead.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#implementation_3","title":"Implementation","text":"<p>As the linking behavior varies per target backend there is no general solution at this level: if targeting the CPU then the system native linker or lld need to be provided the object files, while SPIR-V will need to merge the SPIR-V binaries directly, and Metal shader libraries will need to be constructed with the Apple-specific <code>metallib</code> tooling. Producing these files and performing the linking is outside the scope of IREE.</p> <p>If the files can be acquired then compiler changes will be required to emit calls to them and invoke the linker with the the files.</p> <p>On the CPU an alternative is to use the static library output mode where IREE produces an object file and then the user invokes the linker themselves; this still requires the compiler changes to emit the calls but avoids needing to teach the compiler how to link the files.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#5-dynamically-link-target-specific-device-code-cpu-only","title":"5. Dynamically link target-specific device code (CPU only)","text":"<p>TL;DR</p> <p>Dynamically link external C functions at runtime from device code.</p> <p>It is pitch black. You are likely to be eaten by a grue.</p> <p>This is the lowest-level integration in the system and is designed to act as an escape hatch and - as with any emergency escape hatch - it's not designed for ergonomics. Users should try first to come in through the door and attempting to use this mechanism should trigger alarms about the approach being attempted.</p> <p>IREE's execution model for device code and native machine binary deployment mechanisms are designed with several constraints in order to make all of the above approaches possible and performant. Calling arbitrary C functions from deep within the system can introduce subtle (and not-so-subtle) bugs that are extremely difficult to track down and versioning between the compiler emitting the calls and the runtime providing the implementations can cause skew unless held carefully. Consider the methods added here like syscalls in that they must be extremely focused and if they are ever likely to change (including being removed) then care will be needed just as with versioning or redirecting a syscall. Designing good stable interfaces is hard and a classic pit of failure.</p> <p>Some things to note:</p> <ul> <li>Device code executes in a tiled fashion and single dispatches may invoke the   same function many times from many threads concurrently to perform   the larger work.</li> <li>Tiles may execute in any order and on any thread; performing fine-grained   locking within the tile can lead to deadlocks.</li> <li>Device code is stateless in order to allow for access restrictions and caching   across multiple loaded models - any library state required must be externally   managed via process globals.</li> <li>Device code may be running out-of-process (sandbox/enclave) and the library   functions must be available where the dispatches run and not where they are   launched (such as being linked into the sandbox binary, if separate from the   main process binary).</li> <li>The stack must be used to pass arguments/results to external calls via a   single pointer and there is no libffi-like functionality for magically calling   arbitrary C functions. Users must provide the shims they need.</li> <li>Thread-local storage is unavailable in the called code (it may be usable, but   it is not guaranteed it'll work on all platforms and leaks are likely).</li> <li>No heap allocator is provided and the use of libc malloc is unsupported.</li> </ul> <p>Most of the constraints here come from the SPMD parallelism model, platform-agnostic deployment format, and overall data-oriented design of IREE. Code operating in this fashion has a certain shape and that is usually not the same as big legacy single-threaded CPU-focused BLAS libraries that perform their own caching, internal thread and state management, and other shenanigans. IREE is not designed to wrap such things and if any of these notes are issues it is more an indicator that the approach needs adjustment than anything else. Trying to bypass or workaround the constraints is possible - after all IREE is an open source project and any user is welcome to fork it - but unsupported by the core IREE team.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#pros_4","title":"Pros","text":"<ul> <li>Function resolution at runtime is orthogonal to compiler target specification.</li> <li>Machine code can be shared between the application and IREE artifacts.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#cons_4","title":"Cons","text":"<ul> <li>IREE compiler and runtime must both be modified.</li> <li>Deeper integration with the IREE codegen compiler infrastructure required.</li> <li>ABI versioning complexity between compiler and runtime.</li> <li>Runtimes must ship the imports for the lifetime of any artifact compiled to   use them.<ul> <li>Humans are bad at predicting the future.</li> <li>Using the same artifact in different binaries at runtime requires changes   to each binary - including those that may not be owned by the person   producing the artifact.</li> <li>Weak imports and conditional usage can help but still leads to bloat.</li> </ul> </li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#when-to-use_4","title":"When to use","text":"<ul> <li> Calling into opaque closed-source BLAS-like microkernel   libraries.</li> <li> Any other cases covered above can be used, especially   microkernels that can be represented in MLIR or as statically linked   libraries.</li> </ul>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/extensions/#implementation_4","title":"Implementation","text":"<p>The compiler is changed to produce calls to imports via a dynamic import table provided to each dispatch function. The import table is declared in the executable library for use at runtime. Runtime applications register an import provider to resolve named symbols in the import table to C functions that marshal arguments and results.</p> <p>The compiler-side needs some additional work but an example is included here: Issue 7504. The runtime-side is complete and resolution is performed by a user-supplied <code>iree_hal_executable_import_provider_t</code>.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/","title":"Glossary","text":"<p>IREE exists in an ecosystem of projects and acts as a bridge between machine learning frameworks and a variety of hardware platforms. This glossary outlines some of those projects and technologies.</p> <p>Something missing?</p> <p>Don't see a project of technology here that you think should be? We welcome contributions on our GitHub page!</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#jax","title":"JAX","text":"<p>JAX is Python framework supporting high-performance machine learning research by bridging automatic differentiation and ML compilers like XLA and IREE.</p> <p>See the JAX Integration guide for details on how to use JAX programs with IREE.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#mlir","title":"MLIR","text":"<p>Multi-Level Intermediate Representation (MLIR) is the compiler framework that IREE is built around. Beyond the tooling this includes a set of common dialects and transformations that IREE utilizes for its code generation system.</p> <p>For general discussion on MLIR see the project's discourse forum.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#linalg","title":"Linalg","text":"<p>Linalg is an MLIR dialect that defines Linear Algebra operations in a generalized fashion by modeling iteration spaces together with compute payloads. Linalg includes a set of commonly used operations as well as generic interfaces.</p> <p>IREE uses the Linalg dialect during its code generation pipeline to define tensor operations then generate loop structures for its various backend targets.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#openxla","title":"OpenXLA","text":"<p>OpenXLA is a community-driven, open source ML compiler ecosystem.</p> <p>IREE is one project under the OpenXLA GitHub Organization, and it interfaces with many of the other projects, such as StableHLO.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#pytorch","title":"PyTorch","text":"<p>PyTorch is an optimized tensor library for deep learning.</p> <p>PyTorch uses the Torch-MLIR project to interface with projects like IREE. See the PyTorch Integration guide for details on how to use PyTorch programs with IREE.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#spir-v","title":"SPIR-V","text":"<p>SPIR-V is a shader and kernel intermediate language for expressing parallel computation typically used for GPUs. It serves as a hardware agnostic assembly format for distributing complex, computationally intensive programs.</p> <p>IREE uses the SPIR-V MLIR Dialect in its code generation pipeline for Vulkan and other compute APIs.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#stablehlo","title":"StableHLO","text":"<p>StableHLO is a set of versioned high-level operations (HLOs) for ML models with backward and forward compatibility guarantees. StableHLO aims to improve interoperability between frameworks (such as TensorFlow, JAX, and PyTorch) and ML compilers.</p> <p>StableHLO has both a specification and an MLIR dialect.</p> <p>IREE uses the StableHLO MLIR Dialect as one of its input formats.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#tosa","title":"TOSA","text":"<p>Tensor Operator Set Architecture (TOSA) provides a set of tensor operations commonly employed by Deep Neural Networks. TOSA defines accuracy and compatibility constraints so frameworks that use it can trust that applications will produce similar results on a variety of hardware targets.</p> <p>TOSA has both a specification and an MLIR dialect.</p> <p>IREE uses the TOSA MLIR dialect as one of its input formats.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#tflite","title":"TFLite","text":"<p>TensorFlow Lite (TFLite) is a library for deploying models on mobile and other edge devices.</p> <p>IREE supports running TFLite programs that have been imported into MLIR using the TOSA dialect. See the TFLite Integration guide for details on how to use TFLite programs with IREE.</p> <p>IREE also has bindings for the TFLite C API, see the <code>runtime/bindings/tflite/</code> directory for details.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/optimization-options/","title":"Optimization options","text":"<p>This page documents various supported flags for optimizing IREE programs. Each is presented with its English name, flag to enable/disable, and default state.</p> <p>These flags can be passed to the:</p> <ul> <li><code>iree-compile</code> command line tool</li> <li><code>extra_args=[\"--flag\"]</code> argument to <code>iree.compiler.tools</code> Python wrappers</li> <li>In-process Python compiler API   <code>iree.compiler.transforms.iree-compile.CompilerOptions(\"--flag\", \"--flag2\")</code>   constructor</li> <li><code>ireeCompilerOptionsSetFlags()</code> compiler C API function</li> </ul>"},{"location":"reference/optimization-options/#high-level-program-optimizations","title":"High level program optimizations","text":""},{"location":"reference/optimization-options/#constant-evaluation-iree-opt-const-eval-on","title":"Constant evaluation (<code>--iree-opt-const-eval</code> (on))","text":"<p>Performs compile-time evaluation of any global initializers which produce the initial values for global constants, storing the global directly in the program as constant data. This extracts such constant program fragments and recursively compiles them, using the runtime to evaluate the results.</p> <p>Note that this only has any effect on computations in module initializer functions, not free-standing operations in the program which may produce constant-derived results. See <code>--iree-opt-const-expr-hoisting</code> for options to optimize these.</p>"},{"location":"reference/optimization-options/#constant-expression-hoisting-iree-opt-const-expr-hoisting-off","title":"Constant expression hoisting (<code>--iree-opt-const-expr-hoisting</code> (off))","text":"<p>Identifies all trees of constant expressions in the program and uses a heuristic to determine which would be profitable to hoist into global initializers for evaluation at module load. Together with <code>--iree-opt-const-eval</code>, this will convert eligible trees of expressions to purely static data embedded in the module.</p> <p>The heuristic is currently relatively primitive, using static information to disable hoisting of leaf operations which are metadata only (i.e. broadcasts, etc) or are expected to fold away as part of operator fusion. Notably, the current heuristic is likely to pessimize module size in the case of complicated programs with trees of constant, large tensors.</p>"},{"location":"reference/optimization-options/#numeric-precision-reduction-iree-opt-numeric-precision-reduction-off","title":"Numeric precision reduction (<code>--iree-opt-numeric-precision-reduction</code> (off))","text":"<p>Analyzes program constant data and program flow to identify math operations which can be safely evaluated with reduced precision (currently with a minimum of 8bit integers but being extended to infer any bit depth) and inserts appropriate casts. In conjunction with Constant Expression Hoisting, Constant Evaluation and other automatic optimizations, this can produce programs where large amounts (up to the whole) have had their numeric operations and constant data rewritten to lower precision types.</p> <p>This feature is actively evolving and will be the subject of dedicated documentation when ready.</p>"},{"location":"reference/optimization-options/#strip-debug-assertions-iree-opt-strip-assertions-off","title":"Strip Debug Assertions (<code>--iree-opt-strip-assertions</code> (off))","text":"<p>Strips all <code>std.assert</code> ops in the input program after useful information for optimization analysis has been extracted. Assertions provide useful user-visible error messages but can prevent critical optimizations. Assertions are not, however, a substitution for control flow and frontends that want to check errors in optimized release builds should do so via actual code - similar to when one would <code>if (foo) return false;</code> vs. <code>assert(foo);</code> in a normal program.</p>"},{"location":"reference/bindings/","title":"API bindings","text":"<p>API bindings allow for programmatic use of IREE's compiler and runtime components. The core IREE project is written in C<sup>1</sup>, allowing for API bindings to be written in a variety of other languages.</p> <p>Something missing?</p> <p>Want to use another language? Looking for something specific out of one of those already listed?</p> <p>We welcome discussions on our communication channels and contributions on our GitHub page!</p>"},{"location":"reference/bindings/#official-api-bindings","title":"Official API bindings","text":"<p>Members of the core project team and OpenXLA partners maintain these official bindings:</p> Language Compiler API? Runtime API? Published packages? C/C++  Supported  Supported  Unsupported Python  Supported  Supported  Supported JavaScript  Experimental  Experimental  Unsupported"},{"location":"reference/bindings/#cc","title":"C/C++","text":"<p>See the C API reference page.</p>"},{"location":"reference/bindings/#python","title":"Python","text":"<p>See the Python reference page.</p>"},{"location":"reference/bindings/#javascript","title":"JavaScript","text":"<ul> <li>JavaScript bindings for WebAssembly and WebGPU are under development in IREE's <code>experimental/web/</code> directory.</li> </ul>"},{"location":"reference/bindings/#unofficial-api-bindings","title":"Unofficial API bindings","text":"<p>Members of our developer community have authored bindings using other languages:</p> Language Compiler API? Runtime API? Published packages? Julia  Experimental  Experimental  Unsupported Rust  Unsupported  Experimental  Experimental"},{"location":"reference/bindings/#julia","title":"Julia","text":"<ul> <li>Coil.jl is an experimental package to lower and execute Julia tensor operations to IREE.</li> </ul>"},{"location":"reference/bindings/#rust","title":"Rust","text":"<ul> <li>iree-rs is a crate containing rustic bindings for the IREE runtime.</li> </ul> <ol> <li> <p>with some C++ tools and utilities\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/bindings/c-api/","title":"C API bindings","text":""},{"location":"reference/bindings/c-api/#overview","title":"Overview","text":"<p>The IREE compiler and IREE runtime both have their own C/C++ APIs. This page introduces the available APIs and describes how to use them from your applications.</p> <p>Note</p> <p>There are multiple ways to distribute and depend on C/C++ projects, each with varying levels of portability, flexibility, and toolchain compatibility. IREE aims to support common configurations and platforms.</p>"},{"location":"reference/bindings/c-api/#compiler-api","title":"Compiler API","text":"<p>The IREE compiler is structured as a monolithic shared object with a dynamic plugin system allowing for extensions. The shared object exports symbols for versioned API functions.</p> <pre><code>graph TD\n  accTitle: IREE compiler linkage model diagram\n  accDescr {\n    The libIREECompiler.so or IREECompiler.dll shared object contains pipelines,\n    target backends, and general passes as private implementation details.\n    Compiler plugins interface with the compiler shared object to extend it with\n    custom targets, dialects, etc.\n    Applications interface with the compiler shared object through the compiler\n    C API's exported symbols.\n  }\n\n  subgraph compiler[libIREECompiler.so / IREECompiler.dll]\n    pipelines(\"Pipelines\n\n    \u2022 Flow\n    \u2022 Stream\n    \u2022 etc.\")\n\n    targets(\"Target backends\n\n    \u2022 llvm-cpu\n    \u2022 vulkan-spirv\n    \u2022 etc.\")\n\n    passes(\"General passes\n\n    \u2022 Const eval\n    \u2022 DCE\n    \u2022 etc.\")\n  end\n\n  plugins(\"Compiler plugins\n\n    \u2022 Custom targets\n    \u2022 Custom dialects\n    \u2022 etc.\")\n\n  application(Your application)\n\n  compiler &lt;-- \"Plugin API&lt;br&gt;(static or dynamic linking)\" --&gt; plugins\n  compiler -. \"Compiler C API&lt;br&gt;(exported symbols)\" .-&gt; application</code></pre> <p>API definitions can be found in the following locations:</p> Source location Overview <code>iree/compiler/embedding_api.h</code> Top-level IREE compiler embedding API <code>iree/compiler/PluginAPI/</code> directory IREE compiler plugin API <code>mlir/include/mlir-c/</code> directory MLIR C API headers"},{"location":"reference/bindings/c-api/#concepts","title":"Concepts","text":"<p>The compiler API is centered around running pipelines to translate inputs to artifacts. These are modeled via sessions, invocations, sources, and outputs.</p> <pre><code>stateDiagram-v2\n  accTitle: IREE compiler session and invocation state diagram\n  accDescr {\n    Input files are opened (or buffers are wrapped) as sources in a session.\n    Sources are parsed into invocations, which run pipelines.\n    Output files are written (or buffers are mapped) for compilation artifacts.\n    Sessions can contain multiple sources and run multiple invocations.\n  }\n\n  direction LR\n  InputFile --&gt; Source1 : open file\n  InputBuffer --&gt; Source2 : wrap buffer\n\n  state Session {\n    Source1 --&gt; Invocation1\n    Source2 --&gt; Invocation2\n    Invocation1 --&gt; Invocation1 : run pipeline\n    Invocation2 --&gt; Invocation2 : run pipeline\n  }\n\n  Invocation1 --&gt; Output1File   : write file\n  Invocation1 --&gt; Output1Buffer : map memory\n  Invocation2 --&gt; Output2Buffer : map memory</code></pre>"},{"location":"reference/bindings/c-api/#sessions","title":"Sessions","text":"<p>A session (<code>iree_compiler_session_t</code>) is a scope where one or more invocations can run.</p> <ul> <li>Internally, sessions consist of an <code>MLIRContext</code> and a private set of   options.</li> <li>Sessions may activate available plugins based on their options.</li> </ul>"},{"location":"reference/bindings/c-api/#invocations","title":"Invocations","text":"<p>An invocation (<code>iree_compiler_invocation_t</code>) is a discrete run of the compiler.</p> <ul> <li>Invocations run pipelines, consisting of passes, to translate from   sources to outputs.</li> </ul>"},{"location":"reference/bindings/c-api/#sources","title":"Sources","text":"<p>A source (<code>iree_compiler_source_t</code>) represents an input program, including operations and data.</p> <ul> <li>Sources may refer to files or buffers in memory.</li> </ul>"},{"location":"reference/bindings/c-api/#outputs","title":"Outputs","text":"<p>An output (<code>iree_compiler_output_t</code>) represents a compilation artifact.</p> <ul> <li>Outputs can be standalone files or more advanced streams.</li> </ul>"},{"location":"reference/bindings/c-api/#plugins","title":"Plugins","text":"<p>A plugin extends the compiler with some combination of target backends, options, passes, or pipelines.</p>"},{"location":"reference/bindings/c-api/#usage","title":"Usage","text":"<p>This snippet shows the general layout of the API. For working examples, see the samples below.</p> <pre><code># CMakeLists.txt\nset(_IREE_COMPILER_API \"${_IREE_COMPILER_ROOT}/bindings/c/iree/compiler\")\ntarget_include_directories(${_NAME} SYSTEM PRIVATE ${_IREE_COMPILER_API})\ntarget_link_libraries(${_NAME} iree_compiler_bindings_c_loader)\n</code></pre> <pre><code>// iree_compiler_demo.c\n\n#include &lt;iree/compiler/embedding_api.h&gt;\n#include &lt;iree/compiler/loader.h&gt;\n\nint main(int argc, char** argv) {\n// Load the compiler library then initialize it.\nireeCompilerLoadLibrary(\"libIREECompiler.so\");\nireeCompilerGlobalInitialize();\n\n// Create a session to track compiler state and set flags.\niree_compiler_session_t *session = ireeCompilerSessionCreate();\nireeCompilerSessionSetFlags(session, argc, argv);\n\n// Open a file as an input source to the compiler.\niree_compiler_source_t *source = NULL;\nireeCompilerSourceOpenFile(session, \"input.mlir\", &amp;source);\n\n// Use an invocation to compile from the input source to one or more outputs.\niree_compiler_invocation_t *inv = ireeCompilerInvocationCreate(session);\nireeCompilerInvocationPipeline(inv, IREE_COMPILER_PIPELINE_STD);\n\n// Output the compiled artifact to a file.\niree_compiler_output_t *output = NULL;\nireeCompilerOutputOpenFile(\"output.vmfb\", &amp;output);\nireeCompilerInvocationOutputVMBytecode(inv, output);\n\n// Cleanup state.\nireeCompilerInvocationDestroy(inv);\nireeCompilerOutputDestroy(output);\nireeCompilerSourceDestroy(source);\nireeCompilerSessionDestroy(session);\nireeCompilerGlobalShutdown();\n}\n</code></pre>"},{"location":"reference/bindings/c-api/#samples","title":"Samples","text":"Project Source Description iree-org/iree-template-compiler-cmake <code>hello_compiler.c</code> Compiler application template openxla/openxla-pjrt-plugin <code>iree_compiler.cc</code> JIT for TensorFlow + JAX to IREE openxla/iree <code>samples/compiler_plugins/</code> In-tree demos of compiler plugins"},{"location":"reference/bindings/c-api/#runtime-api","title":"Runtime API","text":"<p>The IREE runtime is structured as a modular set of library components. Each component is designed to be linked into applications directly and compiled with LTO style optimizations.</p> <p>The low level library components can be used directly or through a higher level API.</p> High level APILow level API <p>The high level 'runtime' API sits on top of the low level components. It is relatively terse but does not expose the full flexibility of the underlying systems.</p> <pre><code>graph TD\n  accTitle: IREE runtime high level API diagram\n  accDescr {\n    The IREE runtime includes 'base', 'HAL', and 'VM' components, each with\n    their own types and API methods.\n    A high level \"runtime API\" sits on top of these component APIs.\n    Applications can interface indirectly with the IREE runtime via this\n    high level runtime API.\n  }\n\n  subgraph iree_runtime[IREE Runtime]\n    subgraph base\n      base_types(\"Types\n\n      \u2022 allocator\n      \u2022 status\n      \u2022 etc.\")\n    end\n\n    subgraph hal[HAL]\n      hal_types(\"Types\n\n      \u2022 buffer\n      \u2022 device\n      \u2022 etc.\")\n\n      hal_drivers(\"Drivers\n\n      \u2022 local-*\n      \u2022 vulkan\n      \u2022 etc.\")\n    end\n\n    subgraph vm[VM]\n      vm_types(\"Types\n\n      \u2022 context\n      \u2022 invocation\n      \u2022 etc.\")\n    end\n\n    runtime_api(\"Runtime API\n\n    \u2022 instance\n    \u2022 session\n    \u2022 call\")\n\n    base_types &amp; hal_types &amp; hal_drivers &amp; vm_types --&gt; runtime_api\n  end\n\n  application(Your application)\n\n  runtime_api --&gt; application</code></pre> <p>Each runtime component has its own low level API. The low level APIs are typically verbose as they expose the full flexibility of each underlying system.</p> <pre><code>graph TD\n  accTitle: IREE runtime low level API diagram\n  accDescr {\n    The IREE runtime includes 'base', 'HAL', and 'VM' components, each with\n    their own types and API methods.\n    Applications can interface directly with the IREE runtime via the low\n    level component APIs.\n  }\n\n  subgraph iree_runtime[IREE Runtime]\n    subgraph base\n      base_types(\"Types\n\n      \u2022 allocator\n      \u2022 status\n      \u2022 etc.\")\n    end\n    subgraph hal[HAL]\n      hal_types(\"Types\n\n      \u2022 buffer\n      \u2022 device\n      \u2022 etc.\")\n\n      hal_drivers(\"Drivers\n\n      \u2022 local-*\n      \u2022 vulkan\n      \u2022 etc.\")\n    end\n    subgraph vm[VM]\n      vm_types(\"Types\n\n      \u2022 context\n      \u2022 invocation\n      \u2022 etc.\")\n    end\n  end\n\n  application(Your application)\n\n  base_types &amp; hal_types &amp; hal_drivers &amp; vm_types --&gt; application</code></pre> <p>Runtime API header files are organized by component:</p> Component header file Overview <code>iree/runtime/api.h</code> High level runtime API <code>iree/base/api.h</code> Core API, type definitions, ownership policies, utilities <code>iree/vm/api.h</code> VM APIs: loading modules, I/O, calling functions <code>iree/hal/api.h</code> HAL APIs: device management, synchronization, accessing hardware features"},{"location":"reference/bindings/c-api/#high-level-concepts","title":"High level concepts","text":"<p>The high level API uses instances, sessions, and calls to run programs with a small API surface.</p> <pre><code>stateDiagram-v2\n  accTitle: IREE runtime high level API state diagram\n  accDescr {\n    Instances track sessions and state: options, drivers, devices.\n    Sessions track calls and state: a device and bytecode/VM modules.\n    Calls track input and output lists.\n  }\n\n  state iree_runtime_instance_t {\n    instance_state: state&lt;br&gt;- options&lt;br&gt;- drivers&lt;br&gt;- devices\n\n    state iree_runtime_session_t {\n      session_state: state&lt;br&gt;- device&lt;br&gt;- VM / bytecode modules\n      state iree_runtime_call_t  {\n        inputs\n        outputs\n      }\n    }\n  }</code></pre>"},{"location":"reference/bindings/c-api/#instance","title":"Instance","text":"<p>An instance (<code>iree_runtime_instance_t</code>) isolates runtime usage and manages device resources.</p> <ul> <li>Instances may service multiple sessions to avoid extra device interaction   and reuse caches/pools.</li> <li>Separate instances are isolated/sandboxed from one another.</li> </ul>"},{"location":"reference/bindings/c-api/#session","title":"Session","text":"<p>A session (<code>iree_runtime_session_t</code>) contains a set of loaded modules and their state.</p> <ul> <li>Sessions that share an instance may share resources directly.</li> <li>Sessions that do not share an instance can transfer resources using   import and export APIs.</li> </ul>"},{"location":"reference/bindings/c-api/#call","title":"Call","text":"<p>A call (<code>iree_runtime_call_t</code>) is a stateful VM function call builder.</p> <ul> <li>Calls can be reused to avoid having to construct input lists for each   invocation.</li> </ul>"},{"location":"reference/bindings/c-api/#low-level-concepts","title":"Low level concepts","text":""},{"location":"reference/bindings/c-api/#base","title":"Base","text":"<p>Under construction, more coming soon</p>"},{"location":"reference/bindings/c-api/#vm","title":"VM","text":"<p>IREE uses its own Virtual Machine (VM) at runtime to interpret program instructions on the host system.</p> Tip - EmitC alternate lowering path <p>VM instructions may be further lowered to C source code for static or resource constrained deployment.</p> <p>See the <code>--output-format=vm-c</code> compiler option and the samples in <code>samples/emitc_modules/</code> for more information.</p> <p>The VM supports generic operations like loads, stores, arithmetic, function calls, and control flow. The VM builds streams of more complex program logic and dense math into HAL command buffers that are dispatched to hardware backends.</p> <ul> <li>VM instances can serve multiple isolated execution contexts.</li> <li>VM contexts are effectively sandboxes for loading modules and running   programs.</li> <li> <p>VM modules provide all functionality to execution contexts, including   access to hardware accelerators through the HAL. Compiled user programs are   also modules.</p> <pre><code>stateDiagram-v2\n  accTitle: Sample VM Modules\n  accDescr {\n    Bytecode modules contain program state, program functions, and debug\n    information.\n    HAL modules contain devices, executables, HAL functions, and HAL types.\n    Custom modules may contain external functions and custom types.\n  }\n\n  state \"Bytecode module\" as bytecode {\n    bytecode_contents: Module state&lt;br&gt;Program functions&lt;br&gt;Debug information\n  }\n\n  state \"HAL module\" as HAL {\n    hal_contents: Devices&lt;br&gt;Executables&lt;br&gt;HAL functions&lt;br&gt;HAL types\n  }\n\n  state \"Custom module\" as custom {\n    custom_contents: External functions&lt;br&gt;Custom types\n  }</code></pre> </li> </ul>"},{"location":"reference/bindings/c-api/#hal","title":"HAL","text":"<p>IREE uses a Hardware Abstraction Layer (HAL) to model and interact with hardware devices like CPUs, GPUs and other accelerators.</p> <ul> <li>HAL drivers are used to enumerate and create HAL devices.</li> <li>HAL devices interface with hardware, such as by allocating device memory,   preparing executables, recording and dispatching command buffers, and   synchronizing with the host.</li> <li>HAL buffers represent data storage and buffer views represent views into   that storage with associated shapes and types (similar to \"tensors\").</li> </ul>"},{"location":"reference/bindings/c-api/#usage_1","title":"Usage","text":"<p>This snippet shows the general layout of the API. For working examples, see the samples below.</p> <pre><code># CMakeLists.txt\ntarget_include_directories(${_NAME} SYSTEM PRIVATE ${_IREE_RUNTIME_ROOT})\ntarget_link_libraries(${_NAME} iree_runtime_runtime)\n</code></pre> <pre><code>// iree_runtime_demo.c\n\n#include &lt;iree/runtime/api.h&gt;\n\nint main(int argc, char** argv) {\n// Setup the shared runtime instance.\niree_runtime_instance_options_t instance_options;\niree_runtime_instance_options_initialize(&amp;instance_options);\niree_runtime_instance_options_use_all_available_drivers(&amp;instance_options);\niree_runtime_instance_t* instance = NULL;\niree_runtime_instance_create(\n&amp;instance_options, iree_allocator_system(), &amp;instance);\n\n// Create the HAL device used to run the workloads.\niree_hal_device_t* device = NULL;\niree_runtime_instance_try_create_default_device(\ninstance, iree_make_cstring_view(\"local-task\"), &amp;device);\n\n// Create a session to hold the module state.\niree_runtime_session_options_t session_options;\niree_runtime_session_options_initialize(&amp;session_options);\niree_runtime_session_t* session = NULL;\niree_runtime_session_create_with_device(\ninstance, &amp;session_options, device,\niree_runtime_instance_host_allocator(instance), &amp;session);\n\n// Load the compiled user module from a file.\niree_runtime_session_append_bytecode_module_from_file(\nsession, \"program.vmfb\");\n\n// Build and issue the call.\niree_runtime_call_t call;\niree_runtime_call_initialize_by_name(\nsession, iree_make_cstring_view(\"module.entry_function_name\"), &amp;call);\n// iree_runtime_call_inputs_push_back_buffer_view(...);\niree_runtime_call_invoke(&amp;call, /*flags=*/0);\n\n// Retrieve the function outputs and clean up the call.\n// iree_runtime_call_outputs_pop_front_buffer_view(...);\niree_runtime_call_deinitialize(&amp;call);\n\n// Cleanup state.\niree_runtime_session_release(session);\niree_hal_device_release(device);\niree_runtime_instance_release(instance);\n}\n</code></pre>"},{"location":"reference/bindings/c-api/#samples_1","title":"Samples","text":"Project Source Description iree-org/iree-template-runtime-cmake <code>hello_world.c</code> Runtime application template openxla/iree <code>runtime/demo/</code> In-tree demos of the high level runtime API openxla/iree <code>samples/</code> In-tree sample applications iree-org/iree-samples <code>runtime-library/</code> Shared runtime library builderBuilds <code>libireert.so</code> to aid development iml130/iree-template-cpp <code>simple_embedding.c</code> Demo integration into a project"},{"location":"reference/bindings/c-api/#compiler-runtime-jit","title":"Compiler + Runtime = JIT","text":"<p>The compiler and runtime APIs may be used together to build a \"just in time\" (JIT) execution engine. JIT compilation allows for last-minute specialization with no prior knowledge of target devices and avoids issues with version drift, but it can also constrain deployment options and usage scenarios.</p>"},{"location":"reference/bindings/python/","title":"Python bindings","text":"","tags":["Python"]},{"location":"reference/bindings/python/#overview","title":"Overview","text":"<p>IREE offers Python bindings split into several packages, covering different components:</p> PIP package name Description <code>iree-compiler</code> IREE's generic compiler tools and helpers <code>iree-runtime</code> IREE's runtime, including CPU and GPU backends <code>iree-tools-tf</code> Tools for importing from TensorFlow <code>iree-tools-tflite</code> Tools for importing from TensorFlow Lite <code>iree-jax</code> Tools for importing from JAX <p>Collectively, these packages allow for importing from frontends, compiling towards various targets, and executing compiled code on IREE's backends.</p>","tags":["Python"]},{"location":"reference/bindings/python/#prerequisites","title":"Prerequisites","text":"<p>To use IREE's Python bindings, you will first need to install Python 3 and pip, as needed.</p> Tip - Virtual environments <p>We recommend using virtual environments to manage python packages, such as through <code>venv</code> (about, tutorial):</p>  Linux macOS Windows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate.bat\n</code></pre> <p>When done, run <code>deactivate</code>.</p>","tags":["Python"]},{"location":"reference/bindings/python/#installing-iree-packages","title":"Installing IREE packages","text":"","tags":["Python"]},{"location":"reference/bindings/python/#prebuilt-packages","title":"Prebuilt packages","text":"Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install \\\niree-compiler \\\niree-runtime\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://iree.dev/pip-release-links.html \\\n--upgrade \\\niree-compiler \\\niree-runtime\n</code></pre>","tags":["Python"]},{"location":"reference/bindings/python/#building-from-source","title":"Building from source","text":"<p>See Building Python bindings page for instructions for building from source.</p>","tags":["Python"]},{"location":"reference/bindings/python/#usage","title":"Usage","text":"<p>Info - API reference pages</p> <p>API reference pages for IREE's runtime and compiler Python APIs are hosted on readthedocs.</p> <p>Documentation for the MLIR compiler Python APIs can be found at https://mlir.llvm.org/docs/Bindings/Python/.</p>","tags":["Python"]},{"location":"reference/bindings/python/#compile-a-program","title":"Compile a program","text":"<pre><code>from iree import compiler as ireec\n\n# Compile a module.\nINPUT_MLIR = \"\"\"\nmodule @arithmetic {\n  func.func @simple_mul(%arg0: tensor&lt;4xf32&gt;, %arg1: tensor&lt;4xf32&gt;) -&gt; tensor&lt;4xf32&gt; {\n    %0 = arith.mulf %arg0, %arg1 : tensor&lt;4xf32&gt;\n    return %0 : tensor&lt;4xf32&gt;\n  }\n}\n\"\"\"\n\n# Compile using the vmvx (reference) target:\ncompiled_flatbuffer = ireec.tools.compile_str(\n    INPUT_MLIR,\n    target_backends=[\"vmvx\"])\n</code></pre>","tags":["Python"]},{"location":"reference/bindings/python/#run-a-compiled-program","title":"Run a compiled program","text":"<pre><code>from iree import runtime as ireert\nimport numpy as np\n\n# Register the module with a runtime context.\n# Use the \"local-task\" CPU driver, which can load the vmvx executable:\nconfig = ireert.Config(\"local-task\")\nctx = ireert.SystemContext(config=config)\nvm_module = ireert.VmModule.copy_buffer(ctx.instance, compiled_flatbuffer)\nctx.add_vm_module(vm_module)\n\n# Invoke the function and print the result.\nprint(\"INVOKE simple_mul\")\narg0 = np.array([1., 2., 3., 4.], dtype=np.float32)\narg1 = np.array([4., 5., 6., 7.], dtype=np.float32)\nf = ctx.modules.arithmetic[\"simple_mul\"]\nresults = f(arg0, arg1).to_host()\nprint(\"Results:\", results)\n</code></pre>","tags":["Python"]},{"location":"reference/bindings/python/#samples","title":"Samples","text":"<p>Check out the samples in IREE's samples/colab/ directory and the iree-samples repository for examples using the Python APIs.</p>","tags":["Python"]},{"location":"reference/bindings/python/#console-scripts","title":"Console scripts","text":"<p>The Python packages include console scripts for most of IREE's native tools like <code>iree-compile</code> and <code>iree-run-module</code>.  After installing a package from pip, these should be added to your path automatically:</p> <pre><code>$ python -m pip install iree-runtime\n$ which iree-run-module\n\n/projects/.venv/Scripts/iree-run-module\n</code></pre>","tags":["Python"]},{"location":"reference/bindings/python/#profiling","title":"Profiling","text":"<p>The tools in the <code>iree-runtime</code> package support variants:</p> Variant name Description default Standard runtime tools tracy Runtime tools instrumented using the Tracy profiler <p>Switch between variants of the installed tools using the <code>IREE_PY_RUNTIME</code> environment variable:</p> <pre><code>IREE_PY_RUNTIME=tracy iree-run-module ...\n</code></pre> <p>See the developer documentation page on Profiling with Tracy for information on using Tracy.</p>","tags":["Python"]},{"location":"reference/mlir-dialects/","title":"MLIR dialects","text":"<p>These pages contain automatically generated documentation for the MLIR dialects defined in the IREE repository. IREE also makes extensive use of dialects from the upstream MLIR repository, which are documented at https://mlir.llvm.org/docs/Dialects/.</p>"},{"location":"reference/mlir-dialects/#iree-internal-dialects","title":"IREE internal dialects","text":"<p>These dialects are an implementation detail of the IREE compiler, though they can be used by plugins and other advanced integrations. The sources for most of these dialects can be found in the <code>iree/compiler/Dialect/</code> directory.</p> Dialect Description Check Defines assertions for IREE tests Flow Models execution data flow and partitioning HAL Represents operations against the IREE HAL<sup>1</sup> HAL/Inline Inline HAL interop runtime module dialect HAL/Loader HAL inline executable loader runtime module dialect IO/Parameters External parameter resource management APIs Stream Model execution partitioning and scheduling Util Types and ops common across IREE subdialects VM Represents operations against an abstract virtual machine VMVX Virtual Machine Vector Extensions"},{"location":"reference/mlir-dialects/#iree-public-dialects","title":"IREE public dialects","text":"<p>The ops in these dialects are legal to include in compiler inputs. The sources for these dialects can be found in the <code>llvm-external-projects/iree-dialects/</code> directory that is designed to be used from other projects via LLVM's external projects mechanism.</p> Dialect Description IREEInput Structural ops legal as input to IREE's compiler IREELinalgExt Extensions to the Linalg dialect for specific operations IREEVectorExt Extensions to the Vector dialect for specific operations <ol> <li> <p>Hardware Abstraction Layer\u00a0\u21a9</p> </li> </ol>"},{"location":"community/tags/","title":"Tags","text":"<p>Website pages sorted by tag:</p>"},{"location":"community/tags/#android","title":"Android","text":"<ul> <li>Android cross-compilation</li> <li>Android LLDB debugging</li> </ul>"},{"location":"community/tags/#cpu","title":"CPU","text":"<ul> <li>RISC-V cross-compilation</li> <li>Matrix Multiplication with MMT4D</li> <li>Profiling CPUs</li> <li>CPU - Bare-Metal</li> <li>CPU</li> </ul>"},{"location":"community/tags/#cuda","title":"CUDA","text":"<ul> <li>CUDA backend</li> <li>CUDA backend design</li> <li>GPU - CUDA</li> </ul>"},{"location":"community/tags/#gpu","title":"GPU","text":"<ul> <li>CUDA backend</li> <li>Vulkan environment setup</li> <li>CUDA backend design</li> <li>Profiling GPUs using Vulkan</li> <li>GPU - CUDA</li> <li>GPU - Metal</li> <li>GPU - ROCm</li> <li>GPU - Vulkan</li> </ul>"},{"location":"community/tags/#jax","title":"JAX","text":"<ul> <li>JAX</li> <li>Extensions</li> <li>Glossary</li> </ul>"},{"location":"community/tags/#pytorch","title":"PyTorch","text":"<ul> <li>PyTorch</li> <li>Extensions</li> <li>Glossary</li> </ul>"},{"location":"community/tags/#python","title":"Python","text":"<ul> <li>JAX</li> <li>PyTorch</li> <li>TensorFlow</li> <li>TensorFlow Lite</li> <li>Python</li> </ul>"},{"location":"community/tags/#tensorflow","title":"TensorFlow","text":"<ul> <li>TFLite support via TOSA</li> <li>TensorFlow</li> <li>TensorFlow Lite</li> <li>Extensions</li> <li>Glossary</li> </ul>"},{"location":"community/tags/#vulkan","title":"Vulkan","text":"<ul> <li>Vulkan environment setup</li> <li>Profiling GPUs using Vulkan</li> <li>GPU - Vulkan</li> </ul>"},{"location":"community/tags/#web","title":"Web","text":"<ul> <li>Building with Emscripten</li> </ul>"},{"location":"community/tags/#ios","title":"iOS","text":"<ul> <li>iOS cross-compilation</li> <li>GPU - Metal</li> </ul>"},{"location":"community/blog/archive/2021/","title":"2021","text":""},{"location":"community/blog/category/platforms/","title":"Platforms","text":""},{"location":"community/blog/category/performance/","title":"Performance","text":""},{"location":"community/blog/category/frontends/","title":"Frontends","text":""}]}